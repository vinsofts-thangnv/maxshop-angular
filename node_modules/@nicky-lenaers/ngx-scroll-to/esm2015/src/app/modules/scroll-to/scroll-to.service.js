/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { Injectable, PLATFORM_ID, Inject } from '@angular/core';
import { DOCUMENT } from '@angular/common';
import { isPlatformBrowser } from '@angular/common';
import { ScrollToAnimation } from './statics/scroll-to-animation';
import { stripHash, isString, isNumber, isElementRef, isWindow, DEFAULTS, isNativeElement } from './statics/scroll-to-helpers';
import { ReplaySubject, throwError } from 'rxjs/index';
/**
 * The ScrollToService handles starting, interrupting
 * and ending the actual Scroll Animation. It provides
 * some utilities to find the proper HTML Element on a
 * given page to setup Event Listeners and calculate
 * distances for the Animation.
 */
export class ScrollToService {
    /**
     * Construct and setup required paratemeters.
     *
     * @param {?} _document         A Reference to the Document
     * @param {?} _platformId       Angular Platform ID
     */
    constructor(_document, _platformId) {
        this._document = _document;
        this._platformId = _platformId;
        this._interruptiveEvents = ['mousewheel', 'DOMMouseScroll', 'touchstart'];
    }
    /**
     * Target an Element to scroll to. Notice that the `TimeOut` decorator
     * ensures the executing to take place in the next Angular lifecycle.
     * This allows for scrolling to elements that are e.g. initially hidden
     * by means of `*ngIf`, but ought to be scrolled to eventually.
     *
     * \@todo type 'any' in Observable should become custom type like 'ScrollToEvent' (base class), see issue comment:
     * 	- https://github.com/nicky-lenaers/ngx-scroll-to/issues/10#issuecomment-317198481
     *
     * @param {?} options         Configuration Object
     * @return {?} Observable
     */
    scrollTo(options) {
        if (!isPlatformBrowser(this._platformId))
            return new ReplaySubject().asObservable();
        return this._start(options);
    }
    /**
     * Start a new Animation.
     *
     * \@todo Emit proper events from subscription
     *
     * @param {?} options         Configuration Object
     * @return {?} Observable
     */
    _start(options) {
        // Merge config with default values
        const /** @type {?} */ mergedConfigOptions = /** @type {?} */ (Object.assign({}, /** @type {?} */ (DEFAULTS), options));
        if (this._animation)
            this._animation.stop();
        const /** @type {?} */ targetNode = this._getNode(mergedConfigOptions.target);
        if (mergedConfigOptions.target && !targetNode)
            return throwError('Unable to find Target Element');
        const /** @type {?} */ container = this._getContainer(mergedConfigOptions, targetNode);
        if (mergedConfigOptions.container && !container)
            return throwError('Unable to find Container Element');
        const /** @type {?} */ listenerTarget = this._getListenerTarget(container) || window;
        let /** @type {?} */ to = container ? container.getBoundingClientRect().top : 0;
        if (targetNode) {
            to = isWindow(listenerTarget) ? targetNode.offsetTop : targetNode.getBoundingClientRect().top;
        }
        // Create Animation
        this._animation = new ScrollToAnimation(container, listenerTarget, isWindow(listenerTarget), to, mergedConfigOptions, isPlatformBrowser(this._platformId));
        const /** @type {?} */ onInterrupt = () => this._animation.stop();
        this._addInterruptiveEventListeners(listenerTarget, onInterrupt);
        // Start Animation
        const /** @type {?} */ animation$ = this._animation.start();
        this._subscribeToAnimation(animation$, listenerTarget, onInterrupt);
        return animation$;
    }
    /**
     * Subscribe to the events emitted from the Scrolling
     * Animation. Events might be used for e.g. unsubscribing
     * once finished.
     *
     * @param {?} animation$              The Animation Observable
     * @param {?} listenerTarget          The Listener Target for events
     * @param {?} onInterrupt             The handler for Interruptive Events
     * @return {?} Void
     */
    _subscribeToAnimation(animation$, listenerTarget, onInterrupt) {
        const /** @type {?} */ subscription = animation$
            .subscribe(() => { }, () => { }, () => {
            this._removeInterruptiveEventListeners(this._interruptiveEvents, listenerTarget, onInterrupt);
            subscription.unsubscribe();
        });
    }
    /**
     * Get the container HTML Element in which
     * the scrolling should happen.
     *
     * @param {?} options         The Merged Configuration Object
     * @param {?} targetNode    the targeted HTMLElement
     * @return {?}
     */
    _getContainer(options, targetNode) {
        let /** @type {?} */ container = null;
        if (options.container) {
            container = this._getNode(options.container, true);
        }
        else if (targetNode) {
            container = this._getFirstScrollableParent(targetNode);
        }
        return container;
    }
    /**
     * Add listeners for the Animation Interruptive Events
     * to the Listener Target.
     *
     * @param {?} listenerTarget    Target to attach the listener on
     * @param {?} handler           Handler for when the listener fires
     * @return {?} Void
     */
    _addInterruptiveEventListeners(listenerTarget, handler) {
        if (!listenerTarget)
            listenerTarget = window;
        this._interruptiveEvents.forEach(event => listenerTarget.addEventListener(event, handler));
    }
    /**
     * Remove listeners for the Animation Interrupt Event from
     * the Listener Target. Specifying the correct handler prevents
     * memory leaks and makes the allocated memory available for
     * Garbage Collection.
     *
     * @param {?} events            List of Interruptive Events to remove
     * @param {?} listenerTarget    Target to attach the listener on
     * @param {?} handler           Handler for when the listener fires
     * @return {?} Void
     */
    _removeInterruptiveEventListeners(events, listenerTarget, handler) {
        if (!listenerTarget)
            listenerTarget = window;
        events.forEach(event => listenerTarget.removeEventListener(event, handler));
    }
    /**
     * Find the first scrollable parent Node of a given
     * Element. The DOM Tree gets searched upwards
     * to find this first scrollable parent. Parents might
     * be ignored by CSS styles applied to the HTML Element.
     *
     * @param {?} nativeElement     The Element to search the DOM Tree upwards from
     * @return {?} The first scrollable parent HTML Element
     */
    _getFirstScrollableParent(nativeElement) {
        let /** @type {?} */ style = window.getComputedStyle(nativeElement);
        const /** @type {?} */ overflowRegex = /(auto|scroll)/;
        if (style.position === 'fixed')
            return null;
        for (let /** @type {?} */ parent = nativeElement; parent = parent.parentElement; null) {
            style = window.getComputedStyle(parent);
            if (style.position === 'absolute'
                || style.overflow === 'hidden'
                || style.overflowY === 'hidden')
                continue;
            if (overflowRegex.test(style.overflow + style.overflowY + style.overflowX)
                || parent.tagName === 'BODY')
                return parent;
        }
        return null;
    }
    /**
     * Get the Target Node to scroll to.
     *
     * @param {?} id              The given ID of the node, either a string or
     *                        an element reference
     * @param {?=} allowBodyTag    Indicate whether or not the Document Body is
     *                        considered a valid Target Node
     * @return {?} The Target Node to scroll to
     */
    _getNode(id, allowBodyTag = false) {
        let /** @type {?} */ targetNode;
        if (isString(id)) {
            if (allowBodyTag && (id === 'body' || id === 'BODY')) {
                targetNode = this._document.body;
            }
            else {
                targetNode = this._document.getElementById(stripHash(id));
            }
        }
        else if (isNumber(id)) {
            targetNode = this._document.getElementById(String(id));
        }
        else if (isElementRef(id)) {
            targetNode = id.nativeElement;
        }
        else if (isNativeElement(id)) {
            targetNode = id;
        }
        return targetNode;
    }
    /**
     * Retrieve the Listener target. This Listener Target is used
     * to attach Event Listeners on. In case of the target being
     * the Document Body, we need the actual `window` to listen
     * for events.
     *
     * @param {?} container           The HTML Container element
     * @return {?} The Listener Target to attach events on
     */
    _getListenerTarget(container) {
        if (!container)
            return null;
        return this._isDocumentBody(container) ? window : container;
    }
    /**
     * Test if a given HTML Element is the Document Body.
     *
     * @param {?} element             The given HTML Element
     * @return {?} Whether or not the Element is the
     *                            Document Body Element
     */
    _isDocumentBody(element) {
        return element.tagName.toUpperCase() === 'BODY';
    }
}
ScrollToService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
ScrollToService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
function ScrollToService_tsickle_Closure_declarations() {
    /**
     * The animation that provides the scrolling
     * to happen smoothly over time. Defining it here
     * allows for usage of e.g. `start` and `stop`
     * methods within this Angular Service.
     * @type {?}
     */
    ScrollToService.prototype._animation;
    /**
     * Interruptive Events allow to scrolling animation
     * to be interrupted before it is finished. The list
     * of Interruptive Events represents those.
     * @type {?}
     */
    ScrollToService.prototype._interruptiveEvents;
    /** @type {?} */
    ScrollToService.prototype._document;
    /** @type {?} */
    ScrollToService.prototype._platformId;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2Nyb2xsLXRvLnNlcnZpY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Abmlja3ktbGVuYWVycy9uZ3gtc2Nyb2xsLXRvLyIsInNvdXJjZXMiOlsic3JjL2FwcC9tb2R1bGVzL3Njcm9sbC10by9zY3JvbGwtdG8uc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2hFLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMzQyxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQVFwRCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQztBQUNsRSxPQUFPLEVBQ0wsU0FBUyxFQUNULFFBQVEsRUFDUixRQUFRLEVBQ1IsWUFBWSxFQUNaLFFBQVEsRUFDUixRQUFRLEVBQ1IsZUFBZSxFQUNoQixNQUFNLDZCQUE2QixDQUFDO0FBQ3JDLE9BQU8sRUFBYyxhQUFhLEVBQUUsVUFBVSxFQUFFLE1BQU0sWUFBWSxDQUFDOzs7Ozs7OztBQVVuRSxNQUFNOzs7Ozs7O0lBdUJKLFlBQzRCLFNBQWMsRUFDWCxXQUFnQjtRQURuQixjQUFTLEdBQVQsU0FBUyxDQUFLO1FBQ1gsZ0JBQVcsR0FBWCxXQUFXLENBQUs7UUFFN0MsSUFBSSxDQUFDLG1CQUFtQixHQUFHLENBQUMsWUFBWSxFQUFFLGdCQUFnQixFQUFFLFlBQVksQ0FBQyxDQUFDO0tBQzNFOzs7Ozs7Ozs7Ozs7O0lBY00sUUFBUSxDQUFDLE9BQThCO1FBRTVDLEVBQUUsQ0FBQyxDQUFDLENBQUMsaUJBQWlCLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBQUMsTUFBTSxDQUFDLElBQUksYUFBYSxFQUFFLENBQUMsWUFBWSxFQUFFLENBQUM7UUFFcEYsTUFBTSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7Ozs7Ozs7Ozs7SUFXdEIsTUFBTSxDQUFDLE9BQThCOztRQUczQyx1QkFBTSxtQkFBbUIscUJBQUcsb0NBQ3ZCLFFBQWlDLEdBQ2pDLE9BQU8sQ0FDb0IsQ0FBQSxDQUFDO1FBRWpDLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUM7WUFBQyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxDQUFDO1FBRTVDLHVCQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQzdELEVBQUUsQ0FBQyxDQUFDLG1CQUFtQixDQUFDLE1BQU0sSUFBSSxDQUFDLFVBQVUsQ0FBQztZQUFDLE1BQU0sQ0FBQyxVQUFVLENBQUMsK0JBQStCLENBQUMsQ0FBQztRQUVsRyx1QkFBTSxTQUFTLEdBQWdCLElBQUksQ0FBQyxhQUFhLENBQUMsbUJBQW1CLEVBQUUsVUFBVSxDQUFDLENBQUM7UUFDbkYsRUFBRSxDQUFDLENBQUMsbUJBQW1CLENBQUMsU0FBUyxJQUFJLENBQUMsU0FBUyxDQUFDO1lBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxrQ0FBa0MsQ0FBQyxDQUFDO1FBRXZHLHVCQUFNLGNBQWMsR0FBRyxJQUFJLENBQUMsa0JBQWtCLENBQUMsU0FBUyxDQUFDLElBQUksTUFBTSxDQUFDO1FBRXBFLHFCQUFJLEVBQUUsR0FBRyxTQUFTLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxxQkFBcUIsRUFBRSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRS9ELEVBQUUsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxDQUFDLENBQUM7WUFDZixFQUFFLEdBQUcsUUFBUSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMscUJBQXFCLEVBQUUsQ0FBQyxHQUFHLENBQUM7U0FDL0Y7O1FBR0QsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLGlCQUFpQixDQUNyQyxTQUFTLEVBQ1QsY0FBYyxFQUNkLFFBQVEsQ0FBQyxjQUFjLENBQUMsRUFDeEIsRUFBRSxFQUNGLG1CQUFtQixFQUNuQixpQkFBaUIsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQ3BDLENBQUM7UUFDRix1QkFBTSxXQUFXLEdBQUcsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUNqRCxJQUFJLENBQUMsOEJBQThCLENBQUMsY0FBYyxFQUFFLFdBQVcsQ0FBQyxDQUFDOztRQUdqRSx1QkFBTSxVQUFVLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUMzQyxJQUFJLENBQUMscUJBQXFCLENBQUMsVUFBVSxFQUFFLGNBQWMsRUFBRSxXQUFXLENBQUMsQ0FBQztRQUVwRSxNQUFNLENBQUMsVUFBVSxDQUFDOzs7Ozs7Ozs7Ozs7SUFhWixxQkFBcUIsQ0FDekIsVUFBMkIsRUFDM0IsY0FBc0MsRUFDdEMsV0FBK0M7UUFDakQsdUJBQU0sWUFBWSxHQUFHLFVBQVU7YUFDNUIsU0FBUyxDQUNSLEdBQUcsRUFBRSxJQUFJLEVBQ1QsR0FBRyxFQUFFLElBQUksRUFDVCxHQUFHLEVBQUU7WUFDSCxJQUFJLENBQUMsaUNBQWlDLENBQUMsSUFBSSxDQUFDLG1CQUFtQixFQUFFLGNBQWMsRUFBRSxXQUFXLENBQUMsQ0FBQztZQUM5RixZQUFZLENBQUMsV0FBVyxFQUFFLENBQUM7U0FDNUIsQ0FDRixDQUFDOzs7Ozs7Ozs7O0lBV0UsYUFBYSxDQUFDLE9BQThCLEVBQUUsVUFBdUI7UUFFM0UscUJBQUksU0FBUyxHQUF1QixJQUFJLENBQUM7UUFFekMsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUM7WUFDdEIsU0FBUyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsQ0FBQztTQUNwRDtRQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1lBQ3RCLFNBQVMsR0FBRyxJQUFJLENBQUMseUJBQXlCLENBQUMsVUFBVSxDQUFDLENBQUM7U0FDeEQ7UUFFRCxNQUFNLENBQUMsU0FBUyxDQUFDOzs7Ozs7Ozs7O0lBWVgsOEJBQThCLENBQ3BDLGNBQXNDLEVBQ3RDLE9BQTJDO1FBRXpDLEVBQUUsQ0FBQyxDQUFDLENBQUMsY0FBYyxDQUFDO1lBQUMsY0FBYyxHQUFHLE1BQU0sQ0FBQztRQUUvQyxJQUFJLENBQUMsbUJBQW1CLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsY0FBYyxDQUFDLGdCQUFnQixDQUFDLEtBQUssRUFBRSxPQUFPLENBQUMsQ0FBQyxDQUFDOzs7Ozs7Ozs7Ozs7O0lBY3JGLGlDQUFpQyxDQUN2QyxNQUFnQixFQUNoQixjQUFzQyxFQUN0QyxPQUEyQztRQUUzQyxFQUFFLENBQUMsQ0FBQyxDQUFDLGNBQWMsQ0FBQztZQUFDLGNBQWMsR0FBRyxNQUFNLENBQUM7UUFDN0MsTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRSxDQUFDLGNBQWMsQ0FBQyxtQkFBbUIsQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLENBQUMsQ0FBQzs7Ozs7Ozs7Ozs7SUFZdEUseUJBQXlCLENBQUMsYUFBMEI7UUFFMUQscUJBQUksS0FBSyxHQUF3QixNQUFNLENBQUMsZ0JBQWdCLENBQUMsYUFBYSxDQUFDLENBQUM7UUFFeEUsdUJBQU0sYUFBYSxHQUFXLGVBQWUsQ0FBQztRQUU5QyxFQUFFLENBQUMsQ0FBQyxLQUFLLENBQUMsUUFBUSxLQUFLLE9BQU8sQ0FBQztZQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUM7UUFFNUMsR0FBRyxDQUFDLENBQUMscUJBQUksTUFBTSxHQUFHLGFBQWEsRUFBRSxNQUFNLEdBQUcsTUFBTSxDQUFDLGFBQWEsRUFBRSxJQUFJLEVBQUUsQ0FBQztZQUVyRSxLQUFLLEdBQUcsTUFBTSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxDQUFDO1lBRXhDLEVBQUUsQ0FBQyxDQUFDLEtBQUssQ0FBQyxRQUFRLEtBQUssVUFBVTttQkFDNUIsS0FBSyxDQUFDLFFBQVEsS0FBSyxRQUFRO21CQUMzQixLQUFLLENBQUMsU0FBUyxLQUFLLFFBQVEsQ0FBQztnQkFBQyxRQUFRLENBQUM7WUFFNUMsRUFBRSxDQUFDLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxHQUFHLEtBQUssQ0FBQyxTQUFTLEdBQUcsS0FBSyxDQUFDLFNBQVMsQ0FBQzttQkFDckUsTUFBTSxDQUFDLE9BQU8sS0FBSyxNQUFNLENBQUM7Z0JBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQztTQUMvQztRQUVELE1BQU0sQ0FBQyxJQUFJLENBQUM7Ozs7Ozs7Ozs7O0lBWU4sUUFBUSxDQUFDLEVBQWtCLEVBQUUsZUFBd0IsS0FBSztRQUVoRSxxQkFBSSxVQUF1QixDQUFDO1FBRTVCLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFFakIsRUFBRSxDQUFDLENBQUMsWUFBWSxJQUFJLENBQUMsRUFBRSxLQUFLLE1BQU0sSUFBSSxFQUFFLEtBQUssTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUVyRCxVQUFVLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUM7YUFFbEM7WUFBQyxJQUFJLENBQUMsQ0FBQztnQkFFTixVQUFVLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxjQUFjLENBQUMsU0FBUyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7YUFFM0Q7U0FFRjtRQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBRXhCLFVBQVUsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLGNBQWMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztTQUV4RDtRQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBRTVCLFVBQVUsR0FBRyxFQUFFLENBQUMsYUFBYSxDQUFDO1NBRS9CO1FBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDLGVBQWUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFFL0IsVUFBVSxHQUFHLEVBQUUsQ0FBQztTQUVqQjtRQUVELE1BQU0sQ0FBQyxVQUFVLENBQUM7Ozs7Ozs7Ozs7O0lBYVosa0JBQWtCLENBQUMsU0FBc0I7UUFDL0MsRUFBRSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7WUFBQyxNQUFNLENBQUMsSUFBSSxDQUFDO1FBQzVCLE1BQU0sQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQzs7Ozs7Ozs7O0lBVXRELGVBQWUsQ0FBQyxPQUFvQjtRQUMxQyxNQUFNLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxXQUFXLEVBQUUsS0FBSyxNQUFNLENBQUM7Ozs7WUExUm5ELFVBQVU7Ozs7NENBeUJOLE1BQU0sU0FBQyxRQUFROzRDQUNmLE1BQU0sU0FBQyxXQUFXIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgUExBVEZPUk1fSUQsIEluamVjdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBET0NVTUVOVCB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcbmltcG9ydCB7IGlzUGxhdGZvcm1Ccm93c2VyIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuXHJcbmltcG9ydCB7XHJcbiAgU2Nyb2xsVG9Db25maWdPcHRpb25zLFxyXG4gIFNjcm9sbFRvVGFyZ2V0LFxyXG4gIFNjcm9sbFRvTGlzdGVuZXJUYXJnZXQsXHJcbiAgU2Nyb2xsVG9Db25maWdPcHRpb25zVGFyZ2V0XHJcbn0gZnJvbSAnLi9tb2RlbHMvc2Nyb2xsLXRvLWNvbmZpZy5tb2RlbCc7XHJcbmltcG9ydCB7IFNjcm9sbFRvQW5pbWF0aW9uIH0gZnJvbSAnLi9zdGF0aWNzL3Njcm9sbC10by1hbmltYXRpb24nO1xyXG5pbXBvcnQge1xyXG4gIHN0cmlwSGFzaCxcclxuICBpc1N0cmluZyxcclxuICBpc051bWJlcixcclxuICBpc0VsZW1lbnRSZWYsXHJcbiAgaXNXaW5kb3csXHJcbiAgREVGQVVMVFMsXHJcbiAgaXNOYXRpdmVFbGVtZW50XHJcbn0gZnJvbSAnLi9zdGF0aWNzL3Njcm9sbC10by1oZWxwZXJzJztcclxuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgUmVwbGF5U3ViamVjdCwgdGhyb3dFcnJvciB9IGZyb20gJ3J4anMvaW5kZXgnO1xyXG5cclxuLyoqXHJcbiAqIFRoZSBTY3JvbGxUb1NlcnZpY2UgaGFuZGxlcyBzdGFydGluZywgaW50ZXJydXB0aW5nXHJcbiAqIGFuZCBlbmRpbmcgdGhlIGFjdHVhbCBTY3JvbGwgQW5pbWF0aW9uLiBJdCBwcm92aWRlc1xyXG4gKiBzb21lIHV0aWxpdGllcyB0byBmaW5kIHRoZSBwcm9wZXIgSFRNTCBFbGVtZW50IG9uIGFcclxuICogZ2l2ZW4gcGFnZSB0byBzZXR1cCBFdmVudCBMaXN0ZW5lcnMgYW5kIGNhbGN1bGF0ZVxyXG4gKiBkaXN0YW5jZXMgZm9yIHRoZSBBbmltYXRpb24uXHJcbiAqL1xyXG5ASW5qZWN0YWJsZSgpXHJcbmV4cG9ydCBjbGFzcyBTY3JvbGxUb1NlcnZpY2Uge1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgYW5pbWF0aW9uIHRoYXQgcHJvdmlkZXMgdGhlIHNjcm9sbGluZ1xyXG4gICAqIHRvIGhhcHBlbiBzbW9vdGhseSBvdmVyIHRpbWUuIERlZmluaW5nIGl0IGhlcmVcclxuICAgKiBhbGxvd3MgZm9yIHVzYWdlIG9mIGUuZy4gYHN0YXJ0YCBhbmQgYHN0b3BgXHJcbiAgICogbWV0aG9kcyB3aXRoaW4gdGhpcyBBbmd1bGFyIFNlcnZpY2UuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfYW5pbWF0aW9uOiBTY3JvbGxUb0FuaW1hdGlvbjtcclxuXHJcbiAgLyoqXHJcbiAgICogSW50ZXJydXB0aXZlIEV2ZW50cyBhbGxvdyB0byBzY3JvbGxpbmcgYW5pbWF0aW9uXHJcbiAgICogdG8gYmUgaW50ZXJydXB0ZWQgYmVmb3JlIGl0IGlzIGZpbmlzaGVkLiBUaGUgbGlzdFxyXG4gICAqIG9mIEludGVycnVwdGl2ZSBFdmVudHMgcmVwcmVzZW50cyB0aG9zZS5cclxuICAgKi9cclxuICBwcml2YXRlIF9pbnRlcnJ1cHRpdmVFdmVudHM6IHN0cmluZ1tdO1xyXG5cclxuICAvKipcclxuICAgKiBDb25zdHJ1Y3QgYW5kIHNldHVwIHJlcXVpcmVkIHBhcmF0ZW1ldGVycy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBfZG9jdW1lbnQgICAgICAgICBBIFJlZmVyZW5jZSB0byB0aGUgRG9jdW1lbnRcclxuICAgKiBAcGFyYW0gX3BsYXRmb3JtSWQgICAgICAgQW5ndWxhciBQbGF0Zm9ybSBJRFxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgQEluamVjdChET0NVTUVOVCkgcHJpdmF0ZSBfZG9jdW1lbnQ6IGFueSxcclxuICAgIEBJbmplY3QoUExBVEZPUk1fSUQpIHByaXZhdGUgX3BsYXRmb3JtSWQ6IGFueVxyXG4gICkge1xyXG4gICAgdGhpcy5faW50ZXJydXB0aXZlRXZlbnRzID0gWydtb3VzZXdoZWVsJywgJ0RPTU1vdXNlU2Nyb2xsJywgJ3RvdWNoc3RhcnQnXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRhcmdldCBhbiBFbGVtZW50IHRvIHNjcm9sbCB0by4gTm90aWNlIHRoYXQgdGhlIGBUaW1lT3V0YCBkZWNvcmF0b3JcclxuICAgKiBlbnN1cmVzIHRoZSBleGVjdXRpbmcgdG8gdGFrZSBwbGFjZSBpbiB0aGUgbmV4dCBBbmd1bGFyIGxpZmVjeWNsZS5cclxuICAgKiBUaGlzIGFsbG93cyBmb3Igc2Nyb2xsaW5nIHRvIGVsZW1lbnRzIHRoYXQgYXJlIGUuZy4gaW5pdGlhbGx5IGhpZGRlblxyXG4gICAqIGJ5IG1lYW5zIG9mIGAqbmdJZmAsIGJ1dCBvdWdodCB0byBiZSBzY3JvbGxlZCB0byBldmVudHVhbGx5LlxyXG4gICAqXHJcbiAgICogQHRvZG8gdHlwZSAnYW55JyBpbiBPYnNlcnZhYmxlIHNob3VsZCBiZWNvbWUgY3VzdG9tIHR5cGUgbGlrZSAnU2Nyb2xsVG9FdmVudCcgKGJhc2UgY2xhc3MpLCBzZWUgaXNzdWUgY29tbWVudDpcclxuICAgKiBcdC0gaHR0cHM6Ly9naXRodWIuY29tL25pY2t5LWxlbmFlcnMvbmd4LXNjcm9sbC10by9pc3N1ZXMvMTAjaXNzdWVjb21tZW50LTMxNzE5ODQ4MVxyXG4gICAqXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgICAgICAgICBDb25maWd1cmF0aW9uIE9iamVjdFxyXG4gICAqIEByZXR1cm5zICAgICAgICAgICAgICAgT2JzZXJ2YWJsZVxyXG4gICAqL1xyXG4gIHB1YmxpYyBzY3JvbGxUbyhvcHRpb25zOiBTY3JvbGxUb0NvbmZpZ09wdGlvbnMpOiBPYnNlcnZhYmxlPGFueT4ge1xyXG5cclxuICAgIGlmICghaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5fcGxhdGZvcm1JZCkpIHJldHVybiBuZXcgUmVwbGF5U3ViamVjdCgpLmFzT2JzZXJ2YWJsZSgpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLl9zdGFydChvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXJ0IGEgbmV3IEFuaW1hdGlvbi5cclxuICAgKlxyXG4gICAqIEB0b2RvIEVtaXQgcHJvcGVyIGV2ZW50cyBmcm9tIHN1YnNjcmlwdGlvblxyXG4gICAqXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgICAgICAgICBDb25maWd1cmF0aW9uIE9iamVjdFxyXG4gICAqIEByZXR1cm5zICAgICAgICAgICAgICAgT2JzZXJ2YWJsZVxyXG4gICAqL1xyXG4gIHByaXZhdGUgX3N0YXJ0KG9wdGlvbnM6IFNjcm9sbFRvQ29uZmlnT3B0aW9ucyk6IE9ic2VydmFibGU8bnVtYmVyPiB7XHJcblxyXG4gICAgLy8gTWVyZ2UgY29uZmlnIHdpdGggZGVmYXVsdCB2YWx1ZXNcclxuICAgIGNvbnN0IG1lcmdlZENvbmZpZ09wdGlvbnMgPSB7XHJcbiAgICAgIC4uLkRFRkFVTFRTIGFzIFNjcm9sbFRvQ29uZmlnT3B0aW9ucyxcclxuICAgICAgLi4ub3B0aW9uc1xyXG4gICAgfSBhcyBTY3JvbGxUb0NvbmZpZ09wdGlvbnNUYXJnZXQ7XHJcblxyXG4gICAgaWYgKHRoaXMuX2FuaW1hdGlvbikgdGhpcy5fYW5pbWF0aW9uLnN0b3AoKTtcclxuXHJcbiAgICBjb25zdCB0YXJnZXROb2RlID0gdGhpcy5fZ2V0Tm9kZShtZXJnZWRDb25maWdPcHRpb25zLnRhcmdldCk7XHJcbiAgICBpZiAobWVyZ2VkQ29uZmlnT3B0aW9ucy50YXJnZXQgJiYgIXRhcmdldE5vZGUpIHJldHVybiB0aHJvd0Vycm9yKCdVbmFibGUgdG8gZmluZCBUYXJnZXQgRWxlbWVudCcpO1xyXG5cclxuICAgIGNvbnN0IGNvbnRhaW5lcjogSFRNTEVsZW1lbnQgPSB0aGlzLl9nZXRDb250YWluZXIobWVyZ2VkQ29uZmlnT3B0aW9ucywgdGFyZ2V0Tm9kZSk7XHJcbiAgICBpZiAobWVyZ2VkQ29uZmlnT3B0aW9ucy5jb250YWluZXIgJiYgIWNvbnRhaW5lcikgcmV0dXJuIHRocm93RXJyb3IoJ1VuYWJsZSB0byBmaW5kIENvbnRhaW5lciBFbGVtZW50Jyk7XHJcblxyXG4gICAgY29uc3QgbGlzdGVuZXJUYXJnZXQgPSB0aGlzLl9nZXRMaXN0ZW5lclRhcmdldChjb250YWluZXIpIHx8IHdpbmRvdztcclxuXHJcbiAgICBsZXQgdG8gPSBjb250YWluZXIgPyBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIDogMDtcclxuXHJcbiAgICBpZiAodGFyZ2V0Tm9kZSkge1xyXG4gICAgICB0byA9IGlzV2luZG93KGxpc3RlbmVyVGFyZ2V0KSA/IHRhcmdldE5vZGUub2Zmc2V0VG9wIDogdGFyZ2V0Tm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ3JlYXRlIEFuaW1hdGlvblxyXG4gICAgdGhpcy5fYW5pbWF0aW9uID0gbmV3IFNjcm9sbFRvQW5pbWF0aW9uKFxyXG4gICAgICBjb250YWluZXIsXHJcbiAgICAgIGxpc3RlbmVyVGFyZ2V0LFxyXG4gICAgICBpc1dpbmRvdyhsaXN0ZW5lclRhcmdldCksXHJcbiAgICAgIHRvLFxyXG4gICAgICBtZXJnZWRDb25maWdPcHRpb25zLFxyXG4gICAgICBpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLl9wbGF0Zm9ybUlkKVxyXG4gICAgKTtcclxuICAgIGNvbnN0IG9uSW50ZXJydXB0ID0gKCkgPT4gdGhpcy5fYW5pbWF0aW9uLnN0b3AoKTtcclxuICAgIHRoaXMuX2FkZEludGVycnVwdGl2ZUV2ZW50TGlzdGVuZXJzKGxpc3RlbmVyVGFyZ2V0LCBvbkludGVycnVwdCk7XHJcblxyXG4gICAgLy8gU3RhcnQgQW5pbWF0aW9uXHJcbiAgICBjb25zdCBhbmltYXRpb24kID0gdGhpcy5fYW5pbWF0aW9uLnN0YXJ0KCk7XHJcbiAgICB0aGlzLl9zdWJzY3JpYmVUb0FuaW1hdGlvbihhbmltYXRpb24kLCBsaXN0ZW5lclRhcmdldCwgb25JbnRlcnJ1cHQpO1xyXG5cclxuICAgIHJldHVybiBhbmltYXRpb24kO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3Vic2NyaWJlIHRvIHRoZSBldmVudHMgZW1pdHRlZCBmcm9tIHRoZSBTY3JvbGxpbmdcclxuICAgKiBBbmltYXRpb24uIEV2ZW50cyBtaWdodCBiZSB1c2VkIGZvciBlLmcuIHVuc3Vic2NyaWJpbmdcclxuICAgKiBvbmNlIGZpbmlzaGVkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGFuaW1hdGlvbiQgICAgICAgICAgICAgIFRoZSBBbmltYXRpb24gT2JzZXJ2YWJsZVxyXG4gICAqIEBwYXJhbSBsaXN0ZW5lclRhcmdldCAgICAgICAgICBUaGUgTGlzdGVuZXIgVGFyZ2V0IGZvciBldmVudHNcclxuICAgKiBAcGFyYW0gb25JbnRlcnJ1cHQgICAgICAgICAgICAgVGhlIGhhbmRsZXIgZm9yIEludGVycnVwdGl2ZSBFdmVudHNcclxuICAgKiBAcmV0dXJucyAgICAgICAgICAgICAgICAgICAgICAgVm9pZFxyXG4gICAqL1xyXG4gIHByaXZhdGUgX3N1YnNjcmliZVRvQW5pbWF0aW9uKFxyXG4gICAgICBhbmltYXRpb24kOiBPYnNlcnZhYmxlPGFueT4sXHJcbiAgICAgIGxpc3RlbmVyVGFyZ2V0OiBTY3JvbGxUb0xpc3RlbmVyVGFyZ2V0LFxyXG4gICAgICBvbkludGVycnVwdDogRXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdCkge1xyXG4gICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gYW5pbWF0aW9uJFxyXG4gICAgICAuc3Vic2NyaWJlKFxyXG4gICAgICAgICgpID0+IHsgfSxcclxuICAgICAgICAoKSA9PiB7IH0sXHJcbiAgICAgICAgKCkgPT4ge1xyXG4gICAgICAgICAgdGhpcy5fcmVtb3ZlSW50ZXJydXB0aXZlRXZlbnRMaXN0ZW5lcnModGhpcy5faW50ZXJydXB0aXZlRXZlbnRzLCBsaXN0ZW5lclRhcmdldCwgb25JbnRlcnJ1cHQpO1xyXG4gICAgICAgICAgc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBjb250YWluZXIgSFRNTCBFbGVtZW50IGluIHdoaWNoXHJcbiAgICogdGhlIHNjcm9sbGluZyBzaG91bGQgaGFwcGVuLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgICAgICAgICBUaGUgTWVyZ2VkIENvbmZpZ3VyYXRpb24gT2JqZWN0XHJcbiAgICogQHBhcmFtIHRhcmdldE5vZGUgICAgdGhlIHRhcmdldGVkIEhUTUxFbGVtZW50XHJcbiAgICogQHJldHVybnNcclxuICAgKi9cclxuICBwcml2YXRlIF9nZXRDb250YWluZXIob3B0aW9uczogU2Nyb2xsVG9Db25maWdPcHRpb25zLCB0YXJnZXROb2RlOiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50IHwgbnVsbCB7XHJcblxyXG4gICAgbGV0IGNvbnRhaW5lcjogSFRNTEVsZW1lbnQgfCBudWxsID0gbnVsbDtcclxuXHJcbiAgICBpZiAob3B0aW9ucy5jb250YWluZXIpIHtcclxuICAgICAgY29udGFpbmVyID0gdGhpcy5fZ2V0Tm9kZShvcHRpb25zLmNvbnRhaW5lciwgdHJ1ZSk7XHJcbiAgICB9IGVsc2UgaWYgKHRhcmdldE5vZGUpIHtcclxuICAgICAgY29udGFpbmVyID0gdGhpcy5fZ2V0Rmlyc3RTY3JvbGxhYmxlUGFyZW50KHRhcmdldE5vZGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjb250YWluZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGQgbGlzdGVuZXJzIGZvciB0aGUgQW5pbWF0aW9uIEludGVycnVwdGl2ZSBFdmVudHNcclxuICAgKiB0byB0aGUgTGlzdGVuZXIgVGFyZ2V0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGV2ZW50cyAgICAgICAgICAgIExpc3Qgb2YgZXZlbnRzIHRvIGxpc3RlbiB0b1xyXG4gICAqIEBwYXJhbSBsaXN0ZW5lclRhcmdldCAgICBUYXJnZXQgdG8gYXR0YWNoIHRoZSBsaXN0ZW5lciBvblxyXG4gICAqIEBwYXJhbSBoYW5kbGVyICAgICAgICAgICBIYW5kbGVyIGZvciB3aGVuIHRoZSBsaXN0ZW5lciBmaXJlc1xyXG4gICAqIEByZXR1cm5zICAgICAgICAgICAgICAgICBWb2lkXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfYWRkSW50ZXJydXB0aXZlRXZlbnRMaXN0ZW5lcnMoXHJcbiAgICBsaXN0ZW5lclRhcmdldDogU2Nyb2xsVG9MaXN0ZW5lclRhcmdldCxcclxuICAgIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3QpOiB2b2lkIHtcclxuXHJcbiAgICAgIGlmICghbGlzdGVuZXJUYXJnZXQpIGxpc3RlbmVyVGFyZ2V0ID0gd2luZG93O1xyXG5cclxuICAgIHRoaXMuX2ludGVycnVwdGl2ZUV2ZW50cy5mb3JFYWNoKGV2ZW50ID0+IGxpc3RlbmVyVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZSBsaXN0ZW5lcnMgZm9yIHRoZSBBbmltYXRpb24gSW50ZXJydXB0IEV2ZW50IGZyb21cclxuICAgKiB0aGUgTGlzdGVuZXIgVGFyZ2V0LiBTcGVjaWZ5aW5nIHRoZSBjb3JyZWN0IGhhbmRsZXIgcHJldmVudHNcclxuICAgKiBtZW1vcnkgbGVha3MgYW5kIG1ha2VzIHRoZSBhbGxvY2F0ZWQgbWVtb3J5IGF2YWlsYWJsZSBmb3JcclxuICAgKiBHYXJiYWdlIENvbGxlY3Rpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0gZXZlbnRzICAgICAgICAgICAgTGlzdCBvZiBJbnRlcnJ1cHRpdmUgRXZlbnRzIHRvIHJlbW92ZVxyXG4gICAqIEBwYXJhbSBsaXN0ZW5lclRhcmdldCAgICBUYXJnZXQgdG8gYXR0YWNoIHRoZSBsaXN0ZW5lciBvblxyXG4gICAqIEBwYXJhbSBoYW5kbGVyICAgICAgICAgICBIYW5kbGVyIGZvciB3aGVuIHRoZSBsaXN0ZW5lciBmaXJlc1xyXG4gICAqIEByZXR1cm5zICAgICAgICAgICAgICAgICBWb2lkXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfcmVtb3ZlSW50ZXJydXB0aXZlRXZlbnRMaXN0ZW5lcnMoXHJcbiAgICBldmVudHM6IHN0cmluZ1tdLFxyXG4gICAgbGlzdGVuZXJUYXJnZXQ6IFNjcm9sbFRvTGlzdGVuZXJUYXJnZXQsXHJcbiAgICBoYW5kbGVyOiBFdmVudExpc3RlbmVyT3JFdmVudExpc3RlbmVyT2JqZWN0KTogdm9pZCB7XHJcblxyXG4gICAgaWYgKCFsaXN0ZW5lclRhcmdldCkgbGlzdGVuZXJUYXJnZXQgPSB3aW5kb3c7XHJcbiAgICBldmVudHMuZm9yRWFjaChldmVudCA9PiBsaXN0ZW5lclRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGaW5kIHRoZSBmaXJzdCBzY3JvbGxhYmxlIHBhcmVudCBOb2RlIG9mIGEgZ2l2ZW5cclxuICAgKiBFbGVtZW50LiBUaGUgRE9NIFRyZWUgZ2V0cyBzZWFyY2hlZCB1cHdhcmRzXHJcbiAgICogdG8gZmluZCB0aGlzIGZpcnN0IHNjcm9sbGFibGUgcGFyZW50LiBQYXJlbnRzIG1pZ2h0XHJcbiAgICogYmUgaWdub3JlZCBieSBDU1Mgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIEhUTUwgRWxlbWVudC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBuYXRpdmVFbGVtZW50ICAgICBUaGUgRWxlbWVudCB0byBzZWFyY2ggdGhlIERPTSBUcmVlIHVwd2FyZHMgZnJvbVxyXG4gICAqIEByZXR1cm5zICAgICAgICAgICAgICAgICBUaGUgZmlyc3Qgc2Nyb2xsYWJsZSBwYXJlbnQgSFRNTCBFbGVtZW50XHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfZ2V0Rmlyc3RTY3JvbGxhYmxlUGFyZW50KG5hdGl2ZUVsZW1lbnQ6IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnQge1xyXG5cclxuICAgIGxldCBzdHlsZTogQ1NTU3R5bGVEZWNsYXJhdGlvbiA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5hdGl2ZUVsZW1lbnQpO1xyXG5cclxuICAgIGNvbnN0IG92ZXJmbG93UmVnZXg6IFJlZ0V4cCA9IC8oYXV0b3xzY3JvbGwpLztcclxuXHJcbiAgICBpZiAoc3R5bGUucG9zaXRpb24gPT09ICdmaXhlZCcpIHJldHVybiBudWxsO1xyXG5cclxuICAgIGZvciAobGV0IHBhcmVudCA9IG5hdGl2ZUVsZW1lbnQ7IHBhcmVudCA9IHBhcmVudC5wYXJlbnRFbGVtZW50OyBudWxsKSB7XHJcblxyXG4gICAgICBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHBhcmVudCk7XHJcblxyXG4gICAgICBpZiAoc3R5bGUucG9zaXRpb24gPT09ICdhYnNvbHV0ZSdcclxuICAgICAgICB8fCBzdHlsZS5vdmVyZmxvdyA9PT0gJ2hpZGRlbidcclxuICAgICAgICB8fCBzdHlsZS5vdmVyZmxvd1kgPT09ICdoaWRkZW4nKSBjb250aW51ZTtcclxuXHJcbiAgICAgIGlmIChvdmVyZmxvd1JlZ2V4LnRlc3Qoc3R5bGUub3ZlcmZsb3cgKyBzdHlsZS5vdmVyZmxvd1kgKyBzdHlsZS5vdmVyZmxvd1gpXHJcbiAgICAgICAgfHwgcGFyZW50LnRhZ05hbWUgPT09ICdCT0RZJykgcmV0dXJuIHBhcmVudDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgVGFyZ2V0IE5vZGUgdG8gc2Nyb2xsIHRvLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGlkICAgICAgICAgICAgICBUaGUgZ2l2ZW4gSUQgb2YgdGhlIG5vZGUsIGVpdGhlciBhIHN0cmluZyBvclxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgYW4gZWxlbWVudCByZWZlcmVuY2VcclxuICAgKiBAcGFyYW0gYWxsb3dCb2R5VGFnICAgIEluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoZSBEb2N1bWVudCBCb2R5IGlzXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICBjb25zaWRlcmVkIGEgdmFsaWQgVGFyZ2V0IE5vZGVcclxuICAgKiBAcmV0dXJucyAgICAgICAgICAgICAgIFRoZSBUYXJnZXQgTm9kZSB0byBzY3JvbGwgdG9cclxuICAgKi9cclxuICBwcml2YXRlIF9nZXROb2RlKGlkOiBTY3JvbGxUb1RhcmdldCwgYWxsb3dCb2R5VGFnOiBib29sZWFuID0gZmFsc2UpOiBIVE1MRWxlbWVudCB7XHJcblxyXG4gICAgbGV0IHRhcmdldE5vZGU6IEhUTUxFbGVtZW50O1xyXG5cclxuICAgIGlmIChpc1N0cmluZyhpZCkpIHtcclxuXHJcbiAgICAgIGlmIChhbGxvd0JvZHlUYWcgJiYgKGlkID09PSAnYm9keScgfHwgaWQgPT09ICdCT0RZJykpIHtcclxuXHJcbiAgICAgICAgdGFyZ2V0Tm9kZSA9IHRoaXMuX2RvY3VtZW50LmJvZHk7XHJcblxyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICB0YXJnZXROb2RlID0gdGhpcy5fZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc3RyaXBIYXNoKGlkKSk7XHJcblxyXG4gICAgICB9XHJcblxyXG4gICAgfSBlbHNlIGlmIChpc051bWJlcihpZCkpIHtcclxuXHJcbiAgICAgIHRhcmdldE5vZGUgPSB0aGlzLl9kb2N1bWVudC5nZXRFbGVtZW50QnlJZChTdHJpbmcoaWQpKTtcclxuXHJcbiAgICB9IGVsc2UgaWYgKGlzRWxlbWVudFJlZihpZCkpIHtcclxuXHJcbiAgICAgIHRhcmdldE5vZGUgPSBpZC5uYXRpdmVFbGVtZW50O1xyXG5cclxuICAgIH0gZWxzZSBpZiAoaXNOYXRpdmVFbGVtZW50KGlkKSkge1xyXG5cclxuICAgICAgdGFyZ2V0Tm9kZSA9IGlkO1xyXG5cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGFyZ2V0Tm9kZTtcclxuXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXRyaWV2ZSB0aGUgTGlzdGVuZXIgdGFyZ2V0LiBUaGlzIExpc3RlbmVyIFRhcmdldCBpcyB1c2VkXHJcbiAgICogdG8gYXR0YWNoIEV2ZW50IExpc3RlbmVycyBvbi4gSW4gY2FzZSBvZiB0aGUgdGFyZ2V0IGJlaW5nXHJcbiAgICogdGhlIERvY3VtZW50IEJvZHksIHdlIG5lZWQgdGhlIGFjdHVhbCBgd2luZG93YCB0byBsaXN0ZW5cclxuICAgKiBmb3IgZXZlbnRzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGNvbnRhaW5lciAgICAgICAgICAgVGhlIEhUTUwgQ29udGFpbmVyIGVsZW1lbnRcclxuICAgKiBAcmV0dXJucyAgICAgICAgICAgICAgICAgICBUaGUgTGlzdGVuZXIgVGFyZ2V0IHRvIGF0dGFjaCBldmVudHMgb25cclxuICAgKi9cclxuICBwcml2YXRlIF9nZXRMaXN0ZW5lclRhcmdldChjb250YWluZXI6IEhUTUxFbGVtZW50KTogU2Nyb2xsVG9MaXN0ZW5lclRhcmdldCB7XHJcbiAgICBpZiAoIWNvbnRhaW5lcikgcmV0dXJuIG51bGw7XHJcbiAgICByZXR1cm4gdGhpcy5faXNEb2N1bWVudEJvZHkoY29udGFpbmVyKSA/IHdpbmRvdyA6IGNvbnRhaW5lcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRlc3QgaWYgYSBnaXZlbiBIVE1MIEVsZW1lbnQgaXMgdGhlIERvY3VtZW50IEJvZHkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gZWxlbWVudCAgICAgICAgICAgICBUaGUgZ2l2ZW4gSFRNTCBFbGVtZW50XHJcbiAgICogQHJldHVybnMgICAgICAgICAgICAgICAgICAgV2hldGhlciBvciBub3QgdGhlIEVsZW1lbnQgaXMgdGhlXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgRG9jdW1lbnQgQm9keSBFbGVtZW50XHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfaXNEb2N1bWVudEJvZHkoZWxlbWVudDogSFRNTEVsZW1lbnQpOiBlbGVtZW50IGlzIEhUTUxCb2R5RWxlbWVudCB7XHJcbiAgICByZXR1cm4gZWxlbWVudC50YWdOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdCT0RZJztcclxuICB9XHJcblxyXG59XHJcbiJdfQ==