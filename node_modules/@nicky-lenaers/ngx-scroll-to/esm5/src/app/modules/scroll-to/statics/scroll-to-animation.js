/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { ReplaySubject } from 'rxjs/index';
import { EASING } from '../statics/scroll-to-helpers';
/**
 * Scroll To Animation.
 */
var /**
 * Scroll To Animation.
 */
ScrollToAnimation = /** @class */ (function () {
    /**
     * Class Constructor.
     *
     * @param _container            The Container
     * @param _listenerTarget       The Element that listens for DOM Events
     * @param _isWindow             Whether or not the listener is the Window
     * @param _to                   Position to scroll to
     * @param _options              Additional options for scrolling
     * @param _isBrowser            Whether or not execution runs in the browser
     *                              (as opposed to the server)
     */
    function ScrollToAnimation(_container, _listenerTarget, _isWindow, _to, _options, _isBrowser) {
        var _this = this;
        this._container = _container;
        this._listenerTarget = _listenerTarget;
        this._isWindow = _isWindow;
        this._to = _to;
        this._options = _options;
        this._isBrowser = _isBrowser;
        /**
         * Recursively loop over the Scroll Animation.
         *
         * @return Void
         */
        this._loop = function () {
            _this._timeLapsed += _this._tick;
            _this._percentage = (_this._timeLapsed / _this._options.duration);
            _this._percentage = (_this._percentage > 1) ? 1 : _this._percentage;
            // Position Update
            // Position Update
            _this._position = _this._startPosition +
                ((_this._startPosition - _this._to <= 0 ? 1 : -1) *
                    _this._distance *
                    EASING[_this._options.easing](_this._percentage));
            if (_this._lastPosition !== null && _this._position === _this._lastPosition) {
                _this.stop();
            }
            else {
                _this._source$.next(_this._position);
                _this._isWindow
                    ? _this._listenerTarget.scrollTo(0, Math.floor(_this._position))
                    : _this._container.scrollTop = Math.floor(_this._position);
                _this._lastPosition = _this._position;
            }
        };
        this._tick = 16;
        this._interval = null;
        this._lastPosition = null;
        this._timeLapsed = 0;
        this._windowScrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
        if (!this._container) {
            this._startPosition = this._windowScrollTop;
        }
        else {
            this._startPosition = this._isWindow ? this._windowScrollTop : this._container.scrollTop;
        }
        // Correction for Starting Position of nested HTML Elements
        if (this._container && !this._isWindow) {
            this._to = this._to - this._container.getBoundingClientRect().top + this._startPosition;
        }
        // Set Distance
        var /** @type {?} */ directionalDistance = this._startPosition - this._to;
        this._distance = this._container ? Math.abs(this._startPosition - this._to) : this._to;
        this._mappedOffset = this._options.offset;
        // Set offset from Offset Map
        if (this._isBrowser) {
            this._options
                .offsetMap
                .forEach(function (value, key) { return _this._mappedOffset = window.innerWidth > key ? value : _this._mappedOffset; });
        }
        this._distance += this._mappedOffset * (directionalDistance <= 0 ? 1 : -1);
        this._source$ = new ReplaySubject();
    }
    /**
     * Start the new Scroll Animation.
     *
     * @return {?} Observable containing a number
     */
    ScrollToAnimation.prototype.start = /**
     * Start the new Scroll Animation.
     *
     * @return {?} Observable containing a number
     */
    function () {
        clearInterval(this._interval);
        this._interval = setInterval(this._loop, this._tick);
        return this._source$.asObservable();
    };
    /**
     * Stop the current Scroll Animation Loop.
     *
     * @return {?} Void
     */
    ScrollToAnimation.prototype.stop = /**
     * Stop the current Scroll Animation Loop.
     *
     * @return {?} Void
     */
    function () {
        clearInterval(this._interval);
        this._interval = null;
        this._source$.complete();
    };
    return ScrollToAnimation;
}());
/**
 * Scroll To Animation.
 */
export { ScrollToAnimation };
function ScrollToAnimation_tsickle_Closure_declarations() {
    /**
     * Number of milliseconds for each Tick.
     * @type {?}
     */
    ScrollToAnimation.prototype._tick;
    /**
     * JavaScript Interval.
     * @type {?}
     */
    ScrollToAnimation.prototype._interval;
    /**
     * Time Lapsed in milliseconds.
     * @type {?}
     */
    ScrollToAnimation.prototype._timeLapsed;
    /**
     * Percentage of time lapsed.
     * @type {?}
     */
    ScrollToAnimation.prototype._percentage;
    /**
     * Position of the Element.
     * @type {?}
     */
    ScrollToAnimation.prototype._position;
    /**
     * Last Position.
     * @type {?}
     */
    ScrollToAnimation.prototype._lastPosition;
    /**
     * Start Position of the Element.
     * @type {?}
     */
    ScrollToAnimation.prototype._startPosition;
    /**
     * The Distance to scroll.
     * @type {?}
     */
    ScrollToAnimation.prototype._distance;
    /**
     * Observable Source.
     * @type {?}
     */
    ScrollToAnimation.prototype._source$;
    /**
     * Scroll Top of the Window.
     * @type {?}
     */
    ScrollToAnimation.prototype._windowScrollTop;
    /**
     * Mapped Offset taken from the active Offset Map.
     * @type {?}
     */
    ScrollToAnimation.prototype._mappedOffset;
    /**
     * Recursively loop over the Scroll Animation.
     *
     * \@return Void
     * @type {?}
     */
    ScrollToAnimation.prototype._loop;
    /** @type {?} */
    ScrollToAnimation.prototype._container;
    /** @type {?} */
    ScrollToAnimation.prototype._listenerTarget;
    /** @type {?} */
    ScrollToAnimation.prototype._isWindow;
    /** @type {?} */
    ScrollToAnimation.prototype._to;
    /** @type {?} */
    ScrollToAnimation.prototype._options;
    /** @type {?} */
    ScrollToAnimation.prototype._isBrowser;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2Nyb2xsLXRvLWFuaW1hdGlvbi5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BuaWNreS1sZW5hZXJzL25neC1zY3JvbGwtdG8vIiwic291cmNlcyI6WyJzcmMvYXBwL21vZHVsZXMvc2Nyb2xsLXRvL3N0YXRpY3Mvc2Nyb2xsLXRvLWFuaW1hdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFjLGFBQWEsRUFBRSxNQUFNLFlBQVksQ0FBQztBQUV2RCxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sOEJBQThCLENBQUM7Ozs7QUFTdEQ7OztBQUFBO0lBeURFOzs7Ozs7Ozs7O09BVUc7SUFDSCwyQkFDVSxZQUNBLGlCQUNTLFdBQ0EsS0FDQSxVQUNUO1FBTlYsaUJBeUNDO1FBeENTLGVBQVUsR0FBVixVQUFVO1FBQ1Ysb0JBQWUsR0FBZixlQUFlO1FBQ04sY0FBUyxHQUFULFNBQVM7UUFDVCxRQUFHLEdBQUgsR0FBRztRQUNILGFBQVEsR0FBUixRQUFRO1FBQ2pCLGVBQVUsR0FBVixVQUFVOzs7Ozs7cUJBcURKO1lBRWQsS0FBSSxDQUFDLFdBQVcsSUFBSSxLQUFJLENBQUMsS0FBSyxDQUFDO1lBQy9CLEtBQUksQ0FBQyxXQUFXLEdBQUcsQ0FBQyxLQUFJLENBQUMsV0FBVyxHQUFHLEtBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLENBQUM7WUFDL0QsS0FBSSxDQUFDLFdBQVcsR0FBRyxDQUFDLEtBQUksQ0FBQyxXQUFXLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSSxDQUFDLFdBQVcsQ0FBQzs7WUFHakUsQUFEQSxrQkFBa0I7WUFDbEIsS0FBSSxDQUFDLFNBQVMsR0FBRyxLQUFJLENBQUMsY0FBYztnQkFDbEMsQ0FBQyxDQUFDLEtBQUksQ0FBQyxjQUFjLEdBQUcsS0FBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMs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LEtBQUksQ0FBQyxhQUFhLEVBQXpFLENBQXlFLENBQUMsQ0FBQztTQUN2RztRQUVELElBQUksQ0FBQyxTQUFTLElBQUksSUFBSSxDQUFDLGFBQWEsR0FBRyxDQUFDLG1CQUFtQixJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQzNFLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBSSxhQUFhLEVBQUUsQ0FBQztLQUNyQzs7Ozs7O0lBT00saUNBQUs7Ozs7OztRQUNWLGFBQWEsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDOUIsSUFBSSxDQUFDLFNBQVMsR0FBRyxXQUFXLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDckQsTUFBTSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsWUFBWSxFQUFFLENBQUM7Ozs7Ozs7SUFxQy9CLGdDQUFJOzs7Ozs7UUFDVCxhQUFhLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQzlCLElBQUksQ0FBQyxTQUFTLEdBQUcsSUFBSSxDQUFDO1FBQ3RCLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxFQUFFLENBQUM7OzRCQTFLN0I7SUE0S0MsQ0FBQTs7OztBQWpLRCw2QkFpS0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPYnNlcnZhYmxlLCBSZXBsYXlTdWJqZWN0IH0gZnJvbSAncnhqcy9pbmRleCc7XHJcblxyXG5pbXBvcnQgeyBFQVNJTkcgfSBmcm9tICcuLi9zdGF0aWNzL3Njcm9sbC10by1oZWxwZXJzJztcclxuaW1wb3J0IHtcclxuICBTY3JvbGxUb0NvbmZpZ09wdGlvbnMsXHJcbiAgU2Nyb2xsVG9MaXN0ZW5lclRhcmdldFxyXG59IGZyb20gJy4uL21vZGVscy9zY3JvbGwtdG8tY29uZmlnLm1vZGVsJztcclxuXHJcbi8qKlxyXG4gKiBTY3JvbGwgVG8gQW5pbWF0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFNjcm9sbFRvQW5pbWF0aW9uIHtcclxuXHJcbiAgLyoqXHJcbiAgICogTnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBmb3IgZWFjaCBUaWNrLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgX3RpY2s6IG51bWJlcjtcclxuXHJcbiAgLyoqXHJcbiAgICogSmF2YVNjcmlwdCBJbnRlcnZhbC5cclxuICAgKi9cclxuICBwcml2YXRlIF9pbnRlcnZhbDogYW55O1xyXG5cclxuICAvKipcclxuICAgKiBUaW1lIExhcHNlZCBpbiBtaWxsaXNlY29uZHMuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfdGltZUxhcHNlZDogbnVtYmVyO1xyXG5cclxuICAvKipcclxuICAgKiBQZXJjZW50YWdlIG9mIHRpbWUgbGFwc2VkLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgX3BlcmNlbnRhZ2U6IG51bWJlcjtcclxuXHJcbiAgLyoqXHJcbiAgICogUG9zaXRpb24gb2YgdGhlIEVsZW1lbnQuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfcG9zaXRpb246IG51bWJlcjtcclxuXHJcbiAgLyoqXHJcbiAgICogTGFzdCBQb3NpdGlvbi5cclxuICAgKi9cclxuICBwcml2YXRlIF9sYXN0UG9zaXRpb246IG51bWJlcjtcclxuXHJcbiAgLyoqXHJcbiAgICogU3RhcnQgUG9zaXRpb24gb2YgdGhlIEVsZW1lbnQuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfc3RhcnRQb3NpdGlvbjogbnVtYmVyO1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgRGlzdGFuY2UgdG8gc2Nyb2xsLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgX2Rpc3RhbmNlOiBudW1iZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIE9ic2VydmFibGUgU291cmNlLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgX3NvdXJjZSQ6IFJlcGxheVN1YmplY3Q8bnVtYmVyPjtcclxuXHJcbiAgLyoqXHJcbiAgICogU2Nyb2xsIFRvcCBvZiB0aGUgV2luZG93LlxyXG4gICAqL1xyXG4gIHByaXZhdGUgX3dpbmRvd1Njcm9sbFRvcDogbnVtYmVyO1xyXG5cclxuICAvKipcclxuICAgKiBNYXBwZWQgT2Zmc2V0IHRha2VuIGZyb20gdGhlIGFjdGl2ZSBPZmZzZXQgTWFwLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgX21hcHBlZE9mZnNldDogbnVtYmVyO1xyXG5cclxuICAvKipcclxuICAgKiBDbGFzcyBDb25zdHJ1Y3Rvci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBfY29udGFpbmVyICAgICAgICAgICAgVGhlIENvbnRhaW5lclxyXG4gICAqIEBwYXJhbSBfbGlzdGVuZXJUYXJnZXQgICAgICAgVGhlIEVsZW1lbnQgdGhhdCBsaXN0ZW5zIGZvciBET00gRXZlbnRzXHJcbiAgICogQHBhcmFtIF9pc1dpbmRvdyAgICAgICAgICAgICBXaGV0aGVyIG9yIG5vdCB0aGUgbGlzdGVuZXIgaXMgdGhlIFdpbmRvd1xyXG4gICAqIEBwYXJhbSBfdG8gICAgICAgICAgICAgICAgICAgUG9zaXRpb24gdG8gc2Nyb2xsIHRvXHJcbiAgICogQHBhcmFtIF9vcHRpb25zICAgICAgICAgICAgICBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHNjcm9sbGluZ1xyXG4gICAqIEBwYXJhbSBfaXNCcm93c2VyICAgICAgICAgICAgV2hldGhlciBvciBub3QgZXhlY3V0aW9uIHJ1bnMgaW4gdGhlIGJyb3dzZXJcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChhcyBvcHBvc2VkIHRvIHRoZSBzZXJ2ZXIpXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBwcml2YXRlIF9jb250YWluZXI6IEhUTUxFbGVtZW50LFxyXG4gICAgcHJpdmF0ZSBfbGlzdGVuZXJUYXJnZXQ6IFNjcm9sbFRvTGlzdGVuZXJUYXJnZXQsXHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9pc1dpbmRvdzogYm9vbGVhbixcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgX3RvOiBudW1iZXIsXHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9vcHRpb25zOiBTY3JvbGxUb0NvbmZpZ09wdGlvbnMsXHJcbiAgICBwcml2YXRlIF9pc0Jyb3dzZXI6IGJvb2xlYW5cclxuICApIHtcclxuICAgIHRoaXMuX3RpY2sgPSAxNjtcclxuICAgIHRoaXMuX2ludGVydmFsID0gbnVsbDtcclxuICAgIHRoaXMuX2xhc3RQb3NpdGlvbiA9IG51bGw7XHJcbiAgICB0aGlzLl90aW1lTGFwc2VkID0gMDtcclxuXHJcbiAgICB0aGlzLl93aW5kb3dTY3JvbGxUb3AgPSB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCB8fCAwO1xyXG5cclxuICAgIGlmICghdGhpcy5fY29udGFpbmVyKSB7XHJcbiAgICAgIHRoaXMuX3N0YXJ0UG9zaXRpb24gPSB0aGlzLl93aW5kb3dTY3JvbGxUb3A7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl9zdGFydFBvc2l0aW9uID0gdGhpcy5faXNXaW5kb3cgPyB0aGlzLl93aW5kb3dTY3JvbGxUb3AgOiB0aGlzLl9jb250YWluZXIuc2Nyb2xsVG9wO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENvcnJlY3Rpb24gZm9yIFN0YXJ0aW5nIFBvc2l0aW9uIG9mIG5lc3RlZCBIVE1MIEVsZW1lbnRzXHJcbiAgICBpZiAodGhpcy5fY29udGFpbmVyICYmICF0aGlzLl9pc1dpbmRvdykge1xyXG4gICAgICB0aGlzLl90byA9IHRoaXMuX3RvIC0gdGhpcy5fY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArIHRoaXMuX3N0YXJ0UG9zaXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2V0IERpc3RhbmNlXHJcbiAgICBjb25zdCBkaXJlY3Rpb25hbERpc3RhbmNlID0gdGhpcy5fc3RhcnRQb3NpdGlvbiAtIHRoaXMuX3RvO1xyXG4gICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9jb250YWluZXIgPyBNYXRoLmFicyh0aGlzLl9zdGFydFBvc2l0aW9uIC0gdGhpcy5fdG8pIDogdGhpcy5fdG87XHJcblxyXG4gICAgdGhpcy5fbWFwcGVkT2Zmc2V0ID0gdGhpcy5fb3B0aW9ucy5vZmZzZXQ7XHJcblxyXG4gICAgLy8gU2V0IG9mZnNldCBmcm9tIE9mZnNldCBNYXBcclxuICAgIGlmICh0aGlzLl9pc0Jyb3dzZXIpIHtcclxuICAgICAgdGhpcy5fb3B0aW9uc1xyXG4gICAgICAgIC5vZmZzZXRNYXBcclxuICAgICAgICAuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4gdGhpcy5fbWFwcGVkT2Zmc2V0ID0gd2luZG93LmlubmVyV2lkdGggPiBrZXkgPyB2YWx1ZSA6IHRoaXMuX21hcHBlZE9mZnNldCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fZGlzdGFuY2UgKz0gdGhpcy5fbWFwcGVkT2Zmc2V0ICogKGRpcmVjdGlvbmFsRGlzdGFuY2UgPD0gMCA/IDEgOiAtMSk7XHJcbiAgICB0aGlzLl9zb3VyY2UkID0gbmV3IFJlcGxheVN1YmplY3QoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXJ0IHRoZSBuZXcgU2Nyb2xsIEFuaW1hdGlvbi5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zICAgICAgICAgT2JzZXJ2YWJsZSBjb250YWluaW5nIGEgbnVtYmVyXHJcbiAgICovXHJcbiAgcHVibGljIHN0YXJ0KCk6IE9ic2VydmFibGU8bnVtYmVyPiB7XHJcbiAgICBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKTtcclxuICAgIHRoaXMuX2ludGVydmFsID0gc2V0SW50ZXJ2YWwodGhpcy5fbG9vcCwgdGhpcy5fdGljayk7XHJcbiAgICByZXR1cm4gdGhpcy5fc291cmNlJC5hc09ic2VydmFibGUoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlY3Vyc2l2ZWx5IGxvb3Agb3ZlciB0aGUgU2Nyb2xsIEFuaW1hdGlvbi5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zICAgICAgICAgICBWb2lkXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfbG9vcCA9ICgpOiB2b2lkID0+IHtcclxuXHJcbiAgICB0aGlzLl90aW1lTGFwc2VkICs9IHRoaXMuX3RpY2s7XHJcbiAgICB0aGlzLl9wZXJjZW50YWdlID0gKHRoaXMuX3RpbWVMYXBzZWQgLyB0aGlzLl9vcHRpb25zLmR1cmF0aW9uKTtcclxuICAgIHRoaXMuX3BlcmNlbnRhZ2UgPSAodGhpcy5fcGVyY2VudGFnZSA+IDEpID8gMSA6IHRoaXMuX3BlcmNlbnRhZ2U7XHJcblxyXG4gICAgLy8gUG9zaXRpb24gVXBkYXRlXHJcbiAgICB0aGlzLl9wb3NpdGlvbiA9IHRoaXMuX3N0YXJ0UG9zaXRpb24gK1xyXG4gICAgICAoKHRoaXMuX3N0YXJ0UG9zaXRpb24gLSB0aGlzLl90byA8PSAwID8gMSA6IC0xKSAqXHJcbiAgICAgICAgdGhpcy5fZGlzdGFuY2UgKlxyXG4gICAgICAgIEVBU0lOR1t0aGlzLl9vcHRpb25zLmVhc2luZ10odGhpcy5fcGVyY2VudGFnZSkpO1xyXG5cclxuICAgIGlmICh0aGlzLl9sYXN0UG9zaXRpb24gIT09IG51bGwgJiYgdGhpcy5fcG9zaXRpb24gPT09IHRoaXMuX2xhc3RQb3NpdGlvbikge1xyXG4gICAgICB0aGlzLnN0b3AoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX3NvdXJjZSQubmV4dCh0aGlzLl9wb3NpdGlvbik7XHJcbiAgICAgIHRoaXMuX2lzV2luZG93XHJcbiAgICAgICAgPyB0aGlzLl9saXN0ZW5lclRhcmdldC5zY3JvbGxUbygwLCBNYXRoLmZsb29yKHRoaXMuX3Bvc2l0aW9uKSlcclxuICAgICAgICA6IHRoaXMuX2NvbnRhaW5lci5zY3JvbGxUb3AgPSBNYXRoLmZsb29yKHRoaXMuX3Bvc2l0aW9uKTtcclxuICAgICAgdGhpcy5fbGFzdFBvc2l0aW9uID0gdGhpcy5fcG9zaXRpb247XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdG9wIHRoZSBjdXJyZW50IFNjcm9sbCBBbmltYXRpb24gTG9vcC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBmb3JjZSBcdFx0XHQgICAgRm9yY2UgdG8gc3RvcCB0aGUgQW5pbWF0aW9uIExvb3BcclxuICAgKiBAcmV0dXJucyAgICAgICAgICAgICAgIFZvaWRcclxuICAgKi9cclxuICBwdWJsaWMgc3RvcCgpOiB2b2lkIHtcclxuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpO1xyXG4gICAgdGhpcy5faW50ZXJ2YWwgPSBudWxsO1xyXG4gICAgdGhpcy5fc291cmNlJC5jb21wbGV0ZSgpO1xyXG4gIH1cclxufVxyXG4iXX0=