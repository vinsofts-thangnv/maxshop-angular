(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('rxjs/index'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('@nicky-lenaers/ngx-scroll-to', ['exports', '@angular/core', 'rxjs/index', '@angular/common'], factory) :
    (factory((global['nicky-lenaers'] = global['nicky-lenaers'] || {}, global['nicky-lenaers']['ngx-scroll-to'] = {}),global.ng.core,global.rxjs.index,global.ng.common));
}(this, (function (exports,core,index,common) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Default values for Component Input.
     */
    var /** @type {?} */ DEFAULTS = {
        target: null,
        action: 'click',
        duration: 650,
        easing: 'easeInOutQuad',
        offset: 0,
        offsetMap: new Map()
    };
    /**
     * Easing Colleciton.
     */
    var /** @type {?} */ EASING = {
        easeInQuad: function (time) {
            return time * time;
        },
        easeOutQuad: function (time) {
            return time * (2 - time);
        },
        easeInOutQuad: function (time) {
            return time < 0.5 ? 2 * time * time : -1 + (4 - 2 * time) * time;
        },
        easeInCubic: function (time) {
            return time * time * time;
        },
        easeOutCubic: function (time) {
            return (--time) * time * time + 1;
        },
        easeInOutCubic: function (time) {
            return time < 0.5 ? 4 * time * time * time : (time - 1) * (2 * time - 2) * (2 * time - 2) + 1;
        },
        easeInQuart: function (time) {
            return time * time * time * time;
        },
        easeOutQuart: function (time) {
            return 1 - (--time) * time * time * time;
        },
        easeInOutQuart: function (time) {
            return time < 0.5 ? 8 * time * time * time * time : 1 - 8 * (--time) * time * time * time;
        },
        easeInQuint: function (time) {
            return time * time * time * time * time;
        },
        easeOutQuint: function (time) {
            return 1 + (--time) * time * time * time * time;
        },
        easeInOutQuint: function (time) {
            return time < 0.5 ? 16 * time * time * time * time * time : 1 + 16 * (--time) * time * time * time * time;
        },
        easeOutElastic: function (time) {
            return Math.pow(2, -10 * time) * Math.sin((time - 1 / 4) * (2 * Math.PI) / 1) + 1;
        }
    };
    /**
     * Set of allowed events as triggers
     * for the Animation to start.
     */
    var /** @type {?} */ EVENTS = [
        'click',
        'mouseenter',
        'mouseover',
        'mousedown',
        'mouseup',
        'dblclick',
        'contextmenu',
        'wheel',
        'mouseleave',
        'mouseout'
    ];
    /**
     * Strip hash (#) from value.
     *
     * @param {?} value 				The given string value
     * @return {?} 					The stripped string value
     */
    function stripHash(value) {
        return value.substring(0, 1) === '#' ? value.substring(1) : value;
    }
    /**
     * Test if a given value is a string.
     *
     * @param {?} value 					The given value
     * @return {?} 						Whether the given value is a string
     */
    function isString(value) {
        return typeof value === 'string' || value instanceof String;
    }
    /**
     * Test if a given Element is the Window.
     *
     * @param {?} container 				The given Element
     * @return {?} 						Whether the given Element is Window
     */
    function isWindow(container) {
        return container === window;
    }
    /**
     * Test if a given value is of type ElementRef.
     *
     * @param {?} value 					The given value
     * @return {?} Whether the given value is a number
     */
    function isElementRef(value) {
        return value instanceof core.ElementRef;
    }
    /**
     * Whether or not the given value is a Native Element.
     *
     * @param {?} value           The given value
     * @return {?} Whether or not the value is a Native Element
     */
    function isNativeElement(value) {
        return value instanceof HTMLElement;
    }
    /**
     * Test if a given value is type number.
     *
     * @param {?} value 					The given value
     * @return {?} 						Whether the given value is a number
     */
    function isNumber(value) {
        return !isNaN(parseFloat(value)) && isFinite(value);
    }

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    var __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s)
                if (Object.prototype.hasOwnProperty.call(s, p))
                    t[p] = s[p];
        }
        return t;
    };

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * Scroll To Animation.
     */
    var /**
     * Scroll To Animation.
     */ ScrollToAnimation = (function () {
        /**
         * Class Constructor.
         *
         * @param _container            The Container
         * @param _listenerTarget       The Element that listens for DOM Events
         * @param _isWindow             Whether or not the listener is the Window
         * @param _to                   Position to scroll to
         * @param _options              Additional options for scrolling
         * @param _isBrowser            Whether or not execution runs in the browser
         *                              (as opposed to the server)
         */
        function ScrollToAnimation(_container, _listenerTarget, _isWindow, _to, _options, _isBrowser) {
            var _this = this;
            this._container = _container;
            this._listenerTarget = _listenerTarget;
            this._isWindow = _isWindow;
            this._to = _to;
            this._options = _options;
            this._isBrowser = _isBrowser;
            /**
             * Recursively loop over the Scroll Animation.
             *
             * @return Void
             */
            this._loop = function () {
                _this._timeLapsed += _this._tick;
                _this._percentage = (_this._timeLapsed / _this._options.duration);
                _this._percentage = (_this._percentage > 1) ? 1 : _this._percentage;
                // Position Update
                // Position Update
                _this._position = _this._startPosition +
                    ((_this._startPosition - _this._to <= 0 ? 1 : -1) *
                        _this._distance *
                        EASING[_this._options.easing](_this._percentage));
                if (_this._lastPosition !== null && _this._position === _this._lastPosition) {
                    _this.stop();
                }
                else {
                    _this._source$.next(_this._position);
                    _this._isWindow
                        ? _this._listenerTarget.scrollTo(0, Math.floor(_this._position))
                        : _this._container.scrollTop = Math.floor(_this._position);
                    _this._lastPosition = _this._position;
                }
            };
            this._tick = 16;
            this._interval = null;
            this._lastPosition = null;
            this._timeLapsed = 0;
            this._windowScrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
            if (!this._container) {
                this._startPosition = this._windowScrollTop;
            }
            else {
                this._startPosition = this._isWindow ? this._windowScrollTop : this._container.scrollTop;
            }
            // Correction for Starting Position of nested HTML Elements
            if (this._container && !this._isWindow) {
                this._to = this._to - this._container.getBoundingClientRect().top + this._startPosition;
            }
            // Set Distance
            var /** @type {?} */ directionalDistance = this._startPosition - this._to;
            this._distance = this._container ? Math.abs(this._startPosition - this._to) : this._to;
            this._mappedOffset = this._options.offset;
            // Set offset from Offset Map
            if (this._isBrowser) {
                this._options
                    .offsetMap
                    .forEach(function (value, key) { return _this._mappedOffset = window.innerWidth > key ? value : _this._mappedOffset; });
            }
            this._distance += this._mappedOffset * (directionalDistance <= 0 ? 1 : -1);
            this._source$ = new index.ReplaySubject();
        }
        /**
         * Start the new Scroll Animation.
         *
         * @return {?} Observable containing a number
         */
        ScrollToAnimation.prototype.start = /**
         * Start the new Scroll Animation.
         *
         * @return {?} Observable containing a number
         */
            function () {
                clearInterval(this._interval);
                this._interval = setInterval(this._loop, this._tick);
                return this._source$.asObservable();
            };
        /**
         * Stop the current Scroll Animation Loop.
         *
         * @return {?} Void
         */
        ScrollToAnimation.prototype.stop = /**
         * Stop the current Scroll Animation Loop.
         *
         * @return {?} Void
         */
            function () {
                clearInterval(this._interval);
                this._interval = null;
                this._source$.complete();
            };
        return ScrollToAnimation;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    /**
     * The ScrollToService handles starting, interrupting
     * and ending the actual Scroll Animation. It provides
     * some utilities to find the proper HTML Element on a
     * given page to setup Event Listeners and calculate
     * distances for the Animation.
     */
    var ScrollToService = (function () {
        /**
         * Construct and setup required paratemeters.
         *
         * @param _document         A Reference to the Document
         * @param _platformId       Angular Platform ID
         */
        function ScrollToService(_document, _platformId) {
            this._document = _document;
            this._platformId = _platformId;
            this._interruptiveEvents = ['mousewheel', 'DOMMouseScroll', 'touchstart'];
        }
        /**
         * Target an Element to scroll to. Notice that the `TimeOut` decorator
         * ensures the executing to take place in the next Angular lifecycle.
         * This allows for scrolling to elements that are e.g. initially hidden
         * by means of `*ngIf`, but ought to be scrolled to eventually.
         *
         * \@todo type 'any' in Observable should become custom type like 'ScrollToEvent' (base class), see issue comment:
         * 	- https://github.com/nicky-lenaers/ngx-scroll-to/issues/10#issuecomment-317198481
         *
         * @param {?} options         Configuration Object
         * @return {?} Observable
         */
        ScrollToService.prototype.scrollTo = /**
         * Target an Element to scroll to. Notice that the `TimeOut` decorator
         * ensures the executing to take place in the next Angular lifecycle.
         * This allows for scrolling to elements that are e.g. initially hidden
         * by means of `*ngIf`, but ought to be scrolled to eventually.
         *
         * \@todo type 'any' in Observable should become custom type like 'ScrollToEvent' (base class), see issue comment:
         * 	- https://github.com/nicky-lenaers/ngx-scroll-to/issues/10#issuecomment-317198481
         *
         * @param {?} options         Configuration Object
         * @return {?} Observable
         */
            function (options) {
                if (!common.isPlatformBrowser(this._platformId))
                    return new index.ReplaySubject().asObservable();
                return this._start(options);
            };
        /**
         * Start a new Animation.
         *
         * \@todo Emit proper events from subscription
         *
         * @param {?} options         Configuration Object
         * @return {?} Observable
         */
        ScrollToService.prototype._start = /**
         * Start a new Animation.
         *
         * \@todo Emit proper events from subscription
         *
         * @param {?} options         Configuration Object
         * @return {?} Observable
         */
            function (options) {
                var _this = this;
                // Merge config with default values
                var /** @type {?} */ mergedConfigOptions = (__assign({}, /** @type {?} */ (DEFAULTS), options));
                if (this._animation)
                    this._animation.stop();
                var /** @type {?} */ targetNode = this._getNode(mergedConfigOptions.target);
                if (mergedConfigOptions.target && !targetNode)
                    return index.throwError('Unable to find Target Element');
                var /** @type {?} */ container = this._getContainer(mergedConfigOptions, targetNode);
                if (mergedConfigOptions.container && !container)
                    return index.throwError('Unable to find Container Element');
                var /** @type {?} */ listenerTarget = this._getListenerTarget(container) || window;
                var /** @type {?} */ to = container ? container.getBoundingClientRect().top : 0;
                if (targetNode) {
                    to = isWindow(listenerTarget) ? targetNode.offsetTop : targetNode.getBoundingClientRect().top;
                }
                // Create Animation
                this._animation = new ScrollToAnimation(container, listenerTarget, isWindow(listenerTarget), to, mergedConfigOptions, common.isPlatformBrowser(this._platformId));
                var /** @type {?} */ onInterrupt = function () { return _this._animation.stop(); };
                this._addInterruptiveEventListeners(listenerTarget, onInterrupt);
                // Start Animation
                var /** @type {?} */ animation$ = this._animation.start();
                this._subscribeToAnimation(animation$, listenerTarget, onInterrupt);
                return animation$;
            };
        /**
         * Subscribe to the events emitted from the Scrolling
         * Animation. Events might be used for e.g. unsubscribing
         * once finished.
         *
         * @param {?} animation$              The Animation Observable
         * @param {?} listenerTarget          The Listener Target for events
         * @param {?} onInterrupt             The handler for Interruptive Events
         * @return {?} Void
         */
        ScrollToService.prototype._subscribeToAnimation = /**
         * Subscribe to the events emitted from the Scrolling
         * Animation. Events might be used for e.g. unsubscribing
         * once finished.
         *
         * @param {?} animation$              The Animation Observable
         * @param {?} listenerTarget          The Listener Target for events
         * @param {?} onInterrupt             The handler for Interruptive Events
         * @return {?} Void
         */
            function (animation$, listenerTarget, onInterrupt) {
                var _this = this;
                var /** @type {?} */ subscription = animation$
                    .subscribe(function () { }, function () { }, function () {
                    _this._removeInterruptiveEventListeners(_this._interruptiveEvents, listenerTarget, onInterrupt);
                    subscription.unsubscribe();
                });
            };
        /**
         * Get the container HTML Element in which
         * the scrolling should happen.
         *
         * @param {?} options         The Merged Configuration Object
         * @param {?} targetNode    the targeted HTMLElement
         * @return {?}
         */
        ScrollToService.prototype._getContainer = /**
         * Get the container HTML Element in which
         * the scrolling should happen.
         *
         * @param {?} options         The Merged Configuration Object
         * @param {?} targetNode    the targeted HTMLElement
         * @return {?}
         */
            function (options, targetNode) {
                var /** @type {?} */ container = null;
                if (options.container) {
                    container = this._getNode(options.container, true);
                }
                else if (targetNode) {
                    container = this._getFirstScrollableParent(targetNode);
                }
                return container;
            };
        /**
         * Add listeners for the Animation Interruptive Events
         * to the Listener Target.
         *
         * @param {?} listenerTarget    Target to attach the listener on
         * @param {?} handler           Handler for when the listener fires
         * @return {?} Void
         */
        ScrollToService.prototype._addInterruptiveEventListeners = /**
         * Add listeners for the Animation Interruptive Events
         * to the Listener Target.
         *
         * @param {?} listenerTarget    Target to attach the listener on
         * @param {?} handler           Handler for when the listener fires
         * @return {?} Void
         */
            function (listenerTarget, handler) {
                if (!listenerTarget)
                    listenerTarget = window;
                this._interruptiveEvents.forEach(function (event) { return listenerTarget.addEventListener(event, handler); });
            };
        /**
         * Remove listeners for the Animation Interrupt Event from
         * the Listener Target. Specifying the correct handler prevents
         * memory leaks and makes the allocated memory available for
         * Garbage Collection.
         *
         * @param {?} events            List of Interruptive Events to remove
         * @param {?} listenerTarget    Target to attach the listener on
         * @param {?} handler           Handler for when the listener fires
         * @return {?} Void
         */
        ScrollToService.prototype._removeInterruptiveEventListeners = /**
         * Remove listeners for the Animation Interrupt Event from
         * the Listener Target. Specifying the correct handler prevents
         * memory leaks and makes the allocated memory available for
         * Garbage Collection.
         *
         * @param {?} events            List of Interruptive Events to remove
         * @param {?} listenerTarget    Target to attach the listener on
         * @param {?} handler           Handler for when the listener fires
         * @return {?} Void
         */
            function (events, listenerTarget, handler) {
                if (!listenerTarget)
                    listenerTarget = window;
                events.forEach(function (event) { return listenerTarget.removeEventListener(event, handler); });
            };
        /**
         * Find the first scrollable parent Node of a given
         * Element. The DOM Tree gets searched upwards
         * to find this first scrollable parent. Parents might
         * be ignored by CSS styles applied to the HTML Element.
         *
         * @param {?} nativeElement     The Element to search the DOM Tree upwards from
         * @return {?} The first scrollable parent HTML Element
         */
        ScrollToService.prototype._getFirstScrollableParent = /**
         * Find the first scrollable parent Node of a given
         * Element. The DOM Tree gets searched upwards
         * to find this first scrollable parent. Parents might
         * be ignored by CSS styles applied to the HTML Element.
         *
         * @param {?} nativeElement     The Element to search the DOM Tree upwards from
         * @return {?} The first scrollable parent HTML Element
         */
            function (nativeElement) {
                var /** @type {?} */ style = window.getComputedStyle(nativeElement);
                var /** @type {?} */ overflowRegex = /(auto|scroll)/;
                if (style.position === 'fixed')
                    return null;
                for (var /** @type {?} */ parent_1 = nativeElement; parent_1 = parent_1.parentElement; null) {
                    style = window.getComputedStyle(parent_1);
                    if (style.position === 'absolute'
                        || style.overflow === 'hidden'
                        || style.overflowY === 'hidden')
                        continue;
                    if (overflowRegex.test(style.overflow + style.overflowY + style.overflowX)
                        || parent_1.tagName === 'BODY')
                        return parent_1;
                }
                return null;
            };
        /**
         * Get the Target Node to scroll to.
         *
         * @param {?} id              The given ID of the node, either a string or
         *                        an element reference
         * @param {?=} allowBodyTag    Indicate whether or not the Document Body is
         *                        considered a valid Target Node
         * @return {?} The Target Node to scroll to
         */
        ScrollToService.prototype._getNode = /**
         * Get the Target Node to scroll to.
         *
         * @param {?} id              The given ID of the node, either a string or
         *                        an element reference
         * @param {?=} allowBodyTag    Indicate whether or not the Document Body is
         *                        considered a valid Target Node
         * @return {?} The Target Node to scroll to
         */
            function (id, allowBodyTag) {
                if (allowBodyTag === void 0) {
                    allowBodyTag = false;
                }
                var /** @type {?} */ targetNode;
                if (isString(id)) {
                    if (allowBodyTag && (id === 'body' || id === 'BODY')) {
                        targetNode = this._document.body;
                    }
                    else {
                        targetNode = this._document.getElementById(stripHash(id));
                    }
                }
                else if (isNumber(id)) {
                    targetNode = this._document.getElementById(String(id));
                }
                else if (isElementRef(id)) {
                    targetNode = id.nativeElement;
                }
                else if (isNativeElement(id)) {
                    targetNode = id;
                }
                return targetNode;
            };
        /**
         * Retrieve the Listener target. This Listener Target is used
         * to attach Event Listeners on. In case of the target being
         * the Document Body, we need the actual `window` to listen
         * for events.
         *
         * @param {?} container           The HTML Container element
         * @return {?} The Listener Target to attach events on
         */
        ScrollToService.prototype._getListenerTarget = /**
         * Retrieve the Listener target. This Listener Target is used
         * to attach Event Listeners on. In case of the target being
         * the Document Body, we need the actual `window` to listen
         * for events.
         *
         * @param {?} container           The HTML Container element
         * @return {?} The Listener Target to attach events on
         */
            function (container) {
                if (!container)
                    return null;
                return this._isDocumentBody(container) ? window : container;
            };
        /**
         * Test if a given HTML Element is the Document Body.
         *
         * @param {?} element             The given HTML Element
         * @return {?} Whether or not the Element is the
         *                            Document Body Element
         */
        ScrollToService.prototype._isDocumentBody = /**
         * Test if a given HTML Element is the Document Body.
         *
         * @param {?} element             The given HTML Element
         * @return {?} Whether or not the Element is the
         *                            Document Body Element
         */
            function (element) {
                return element.tagName.toUpperCase() === 'BODY';
            };
        ScrollToService.decorators = [
            { type: core.Injectable },
        ];
        /** @nocollapse */
        ScrollToService.ctorParameters = function () {
            return [
                { type: undefined, decorators: [{ type: core.Inject, args: [common.DOCUMENT,] }] },
                { type: undefined, decorators: [{ type: core.Inject, args: [core.PLATFORM_ID,] }] }
            ];
        };
        return ScrollToService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ScrollToDirective = (function () {
        function ScrollToDirective(_elementRef, _scrollToService, _renderer2) {
            this._elementRef = _elementRef;
            this._scrollToService = _scrollToService;
            this._renderer2 = _renderer2;
            this.ngxScrollTo = DEFAULTS.target;
            this.ngxScrollToEvent = DEFAULTS.action;
            this.ngxScrollToDuration = DEFAULTS.duration;
            this.ngxScrollToEasing = DEFAULTS.easing;
            this.ngxScrollToOffset = DEFAULTS.offset;
            this.ngxScrollToOffsetMap = DEFAULTS.offsetMap;
        }
        /**
         * Angular Lifecycle Hook - After View Init
         *
         * \@todo Implement Subscription for Events
         *
         * @return {?} void
         */
        ScrollToDirective.prototype.ngAfterViewInit = /**
         * Angular Lifecycle Hook - After View Init
         *
         * \@todo Implement Subscription for Events
         *
         * @return {?} void
         */
            function () {
                var _this = this;
                // Test Event Support
                if (EVENTS.indexOf(this.ngxScrollToEvent) === -1)
                    throw new Error("Unsupported Event '" + this.ngxScrollToEvent + "'");
                // Listen for the trigger...
                this._renderer2.listen(this._elementRef.nativeElement, this.ngxScrollToEvent, function (event) {
                    _this._options = {
                        target: _this.ngxScrollTo,
                        duration: _this.ngxScrollToDuration,
                        easing: _this.ngxScrollToEasing,
                        offset: _this.ngxScrollToOffset,
                        offsetMap: _this.ngxScrollToOffsetMap
                    };
                    _this._scrollToService.scrollTo(_this._options);
                });
            };
        ScrollToDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[ngx-scroll-to]'
                    },] },
        ];
        /** @nocollapse */
        ScrollToDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef },
                { type: ScrollToService },
                { type: core.Renderer2 }
            ];
        };
        ScrollToDirective.propDecorators = {
            ngxScrollTo: [{ type: core.Input, args: ['ngx-scroll-to',] }],
            ngxScrollToEvent: [{ type: core.Input, args: ['ngx-scroll-to-event',] }],
            ngxScrollToDuration: [{ type: core.Input, args: ['ngx-scroll-to-duration',] }],
            ngxScrollToEasing: [{ type: core.Input, args: ['ngx-scroll-to-easing',] }],
            ngxScrollToOffset: [{ type: core.Input, args: ['ngx-scroll-to-offset',] }],
            ngxScrollToOffsetMap: [{ type: core.Input, args: ['ngx-scroll-to-offset-map',] }]
        };
        return ScrollToDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */
    var ScrollToModule = (function () {
        function ScrollToModule() {
        }
        /**
         * Guaranteed singletons for provided Services across App.
         *
         * @return          An Angular Module with Providers
         */
        /**
         * Guaranteed singletons for provided Services across App.
         *
         * @return {?} An Angular Module with Providers
         */
        ScrollToModule.forRoot = /**
         * Guaranteed singletons for provided Services across App.
         *
         * @return {?} An Angular Module with Providers
         */
            function () {
                return {
                    ngModule: ScrollToModule,
                    providers: [
                        ScrollToService
                    ]
                };
            };
        ScrollToModule.decorators = [
            { type: core.NgModule, args: [{
                        declarations: [
                            ScrollToDirective
                        ],
                        exports: [
                            ScrollToDirective
                        ]
                    },] },
        ];
        return ScrollToModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes} checked by tsc
     */

    exports.ScrollToModule = ScrollToModule;
    exports.ScrollToService = ScrollToService;
    exports.ɵa = ScrollToDirective;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmlja3ktbGVuYWVycy1uZ3gtc2Nyb2xsLXRvLnVtZC5qcy5tYXAiLCJzb3VyY2VzIjpbIm5nOi8vQG5pY2t5LWxlbmFlcnMvbmd4LXNjcm9sbC10by9zcmMvYXBwL21vZHVsZXMvc2Nyb2xsLXRvL3N0YXRpY3Mvc2Nyb2xsLXRvLWhlbHBlcnMudHMiLG51bGwsIm5nOi8vQG5pY2t5LWxlbmFlcnMvbmd4LXNjcm9sbC10by9zcmMvYXBwL21vZHVsZXMvc2Nyb2xsLXRvL3N0YXRpY3Mvc2Nyb2xsLXRvLWFuaW1hdGlvbi50cyIsIm5nOi8vQG5pY2t5LWxlbmFlcnMvbmd4LXNjcm9sbC10by9zcmMvYXBwL21vZHVsZXMvc2Nyb2xsLXRvL3Njcm9sbC10by5zZXJ2aWNlLnRzIiwibmc6Ly9Abmlja3ktbGVuYWVycy9uZ3gtc2Nyb2xsLXRvL3NyYy9hcHAvbW9kdWxlcy9zY3JvbGwtdG8vc2Nyb2xsLXRvLmRpcmVjdGl2ZS50cyIsIm5nOi8vQG5pY2t5LWxlbmFlcnMvbmd4LXNjcm9sbC10by9zcmMvYXBwL21vZHVsZXMvc2Nyb2xsLXRvL3Njcm9sbC10by5tb2R1bGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRWxlbWVudFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuaW1wb3J0IHtcclxuICBTY3JvbGxUb0FuaW1hdGlvbkVhc2luZyxcclxuICBTY3JvbGxUb0FuaW1hdGlvbkVhc2luZ0NvbGxlY3Rpb25cclxufSBmcm9tICcuLi9tb2RlbHMvc2Nyb2xsLXRvLWVhc2luZy5tb2RlbCc7XHJcbmltcG9ydCB7IFNjcm9sbFRvRXZlbnQgfSBmcm9tICcuLi9tb2RlbHMvc2Nyb2xsLXRvLWV2ZW50Lm1vZGVsJztcclxuaW1wb3J0IHtcclxuICBTY3JvbGxUb0NvbmZpZ09wdGlvbnMsXHJcbiAgU2Nyb2xsVG9EZWZhdWx0Q29uZmlnT3B0aW9uc1xyXG59IGZyb20gJy4uL21vZGVscy9zY3JvbGwtdG8tY29uZmlnLm1vZGVsJztcclxuXHJcbi8qKlxyXG4gKiBEZWZhdWx0IHZhbHVlcyBmb3IgQ29tcG9uZW50IElucHV0LlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IERFRkFVTFRTOiBTY3JvbGxUb0RlZmF1bHRDb25maWdPcHRpb25zID0ge1xyXG4gIHRhcmdldDogbnVsbCxcclxuICBhY3Rpb246ICdjbGljaycsXHJcbiAgZHVyYXRpb246IDY1MCxcclxuICBlYXNpbmc6ICdlYXNlSW5PdXRRdWFkJyxcclxuICBvZmZzZXQ6IDAsXHJcbiAgb2Zmc2V0TWFwOiBuZXcgTWFwKClcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFYXNpbmcgQ29sbGVjaXRvbi5cclxuICovXHJcbmV4cG9ydCBjb25zdCBFQVNJTkc6IFNjcm9sbFRvQW5pbWF0aW9uRWFzaW5nQ29sbGVjdGlvbiA9IHtcclxuICBlYXNlSW5RdWFkOiAodGltZTogbnVtYmVyKSA9PiB7XHJcbiAgICByZXR1cm4gdGltZSAqIHRpbWU7XHJcbiAgfSxcclxuICBlYXNlT3V0UXVhZDogKHRpbWU6IG51bWJlcikgPT4ge1xyXG4gICAgcmV0dXJuIHRpbWUgKiAoMiAtIHRpbWUpO1xyXG4gIH0sXHJcbiAgZWFzZUluT3V0UXVhZDogKHRpbWU6IG51bWJlcikgPT4ge1xyXG4gICAgcmV0dXJuIHRpbWUgPCAwLjUgPyAyICogdGltZSAqIHRpbWUgOiAtMSArICg0IC0gMiAqIHRpbWUpICogdGltZTtcclxuICB9LFxyXG4gIGVhc2VJbkN1YmljOiAodGltZTogbnVtYmVyKSA9PiB7XHJcbiAgICByZXR1cm4gdGltZSAqIHRpbWUgKiB0aW1lO1xyXG4gIH0sXHJcbiAgZWFzZU91dEN1YmljOiAodGltZTogbnVtYmVyKSA9PiB7XHJcbiAgICByZXR1cm4gKC0tdGltZSkgKiB0aW1lICogdGltZSArIDE7XHJcbiAgfSxcclxuICBlYXNlSW5PdXRDdWJpYzogKHRpbWU6IG51bWJlcikgPT4ge1xyXG4gICAgcmV0dXJuIHRpbWUgPCAwLjUgPyA0ICogdGltZSAqIHRpbWUgKiB0aW1lIDogKHRpbWUgLSAxKSAqICgyICogdGltZSAtIDIpICogKDIgKiB0aW1lIC0gMikgKyAxO1xyXG4gIH0sXHJcbiAgZWFzZUluUXVhcnQ6ICh0aW1lOiBudW1iZXIpID0+IHtcclxuICAgIHJldHVybiB0aW1lICogdGltZSAqIHRpbWUgKiB0aW1lO1xyXG4gIH0sXHJcbiAgZWFzZU91dFF1YXJ0OiAodGltZTogbnVtYmVyKSA9PiB7XHJcbiAgICByZXR1cm4gMSAtICgtLXRpbWUpICogdGltZSAqIHRpbWUgKiB0aW1lO1xyXG4gIH0sXHJcbiAgZWFzZUluT3V0UXVhcnQ6ICh0aW1lOiBudW1iZXIpID0+IHtcclxuICAgIHJldHVybiB0aW1lIDwgMC41ID8gOCAqIHRpbWUgKiB0aW1lICogdGltZSAqIHRpbWUgOiAxIC0gOCAqICgtLXRpbWUpICogdGltZSAqIHRpbWUgKiB0aW1lO1xyXG4gIH0sXHJcbiAgZWFzZUluUXVpbnQ6ICh0aW1lOiBudW1iZXIpID0+IHtcclxuICAgIHJldHVybiB0aW1lICogdGltZSAqIHRpbWUgKiB0aW1lICogdGltZTtcclxuICB9LFxyXG4gIGVhc2VPdXRRdWludDogKHRpbWU6IG51bWJlcikgPT4ge1xyXG4gICAgcmV0dXJuIDEgKyAoLS10aW1lKSAqIHRpbWUgKiB0aW1lICogdGltZSAqIHRpbWU7XHJcbiAgfSxcclxuICBlYXNlSW5PdXRRdWludDogKHRpbWU6IG51bWJlcikgPT4ge1xyXG4gICAgcmV0dXJuIHRpbWUgPCAwLjUgPyAxNiAqIHRpbWUgKiB0aW1lICogdGltZSAqIHRpbWUgKiB0aW1lIDogMSArIDE2ICogKC0tdGltZSkgKiB0aW1lICogdGltZSAqIHRpbWUgKiB0aW1lO1xyXG4gIH0sXHJcbiAgZWFzZU91dEVsYXN0aWM6ICh0aW1lOiBudW1iZXIpID0+IHtcclxuICAgIHJldHVybiBNYXRoLnBvdygyLCAtMTAgKiB0aW1lKSAqIE1hdGguc2luKCh0aW1lIC0gMSAvIDQpICogKDIgKiBNYXRoLlBJKSAvIDEpICsgMTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogU2V0IG9mIGFsbG93ZWQgZXZlbnRzIGFzIHRyaWdnZXJzXHJcbiAqIGZvciB0aGUgQW5pbWF0aW9uIHRvIHN0YXJ0LlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IEVWRU5UUzogc3RyaW5nW10gPSBbXHJcbiAgJ2NsaWNrJyxcclxuICAnbW91c2VlbnRlcicsXHJcbiAgJ21vdXNlb3ZlcicsXHJcbiAgJ21vdXNlZG93bicsXHJcbiAgJ21vdXNldXAnLFxyXG4gICdkYmxjbGljaycsXHJcbiAgJ2NvbnRleHRtZW51JyxcclxuICAnd2hlZWwnLFxyXG4gICdtb3VzZWxlYXZlJyxcclxuICAnbW91c2VvdXQnXHJcbl07XHJcblxyXG4vKipcclxuICogU3RyaXAgaGFzaCAoIykgZnJvbSB2YWx1ZS5cclxuICpcclxuICogQHBhcmFtIHZhbHVlIFx0XHRcdFx0VGhlIGdpdmVuIHN0cmluZyB2YWx1ZVxyXG4gKiBAcmV0dXJucyBcdFx0XHRcdFx0VGhlIHN0cmlwcGVkIHN0cmluZyB2YWx1ZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHN0cmlwSGFzaCh2YWx1ZTogc3RyaW5nKTogc3RyaW5nIHtcclxuICByZXR1cm4gdmFsdWUuc3Vic3RyaW5nKDAsIDEpID09PSAnIycgPyB2YWx1ZS5zdWJzdHJpbmcoMSkgOiB2YWx1ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRlc3QgaWYgYSBnaXZlbiB2YWx1ZSBpcyBhIHN0cmluZy5cclxuICpcclxuICogQHBhcmFtIHZhbHVlIFx0XHRcdFx0XHRUaGUgZ2l2ZW4gdmFsdWVcclxuICogQHJldHVybnMgXHRcdFx0XHRcdFx0V2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBzdHJpbmdcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZTogYW55KTogdmFsdWUgaXMgc3RyaW5nIHtcclxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZztcclxufVxyXG5cclxuLyoqXHJcbiAqIFRlc3QgaWYgYSBnaXZlbiBFbGVtZW50IGlzIHRoZSBXaW5kb3cuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb250YWluZXIgXHRcdFx0XHRUaGUgZ2l2ZW4gRWxlbWVudFxyXG4gKiBAcmV0dXJucyBcdFx0XHRcdFx0XHRXaGV0aGVyIHRoZSBnaXZlbiBFbGVtZW50IGlzIFdpbmRvd1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzV2luZG93KGNvbnRhaW5lcjogYW55KTogY29udGFpbmVyIGlzIFdpbmRvdyB7XHJcbiAgcmV0dXJuIGNvbnRhaW5lciA9PT0gd2luZG93O1xyXG59XHJcblxyXG4vKipcclxuICogVGVzdCBpZiBhIGdpdmVuIHZhbHVlIGlzIG9mIHR5cGUgRWxlbWVudFJlZi5cclxuICpcclxuICogQHBhcmFtIHZhbHVlIFx0XHRcdFx0XHRUaGUgZ2l2ZW4gdmFsdWVcclxuICogQHJldHVybnMgICAgICAgICAgICAgICBXaGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIG51bWJlclxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRWxlbWVudFJlZih2YWx1ZTogYW55KTogdmFsdWUgaXMgRWxlbWVudFJlZiB7XHJcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRWxlbWVudFJlZjtcclxufVxyXG5cclxuLyoqXHJcbiAqIFdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIE5hdGl2ZSBFbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWUgICAgICAgICAgIFRoZSBnaXZlbiB2YWx1ZVxyXG4gKiBAcmV0dXJucyAgICAgICAgICAgICAgIFdoZXRoZXIgb3Igbm90IHRoZSB2YWx1ZSBpcyBhIE5hdGl2ZSBFbGVtZW50XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNOYXRpdmVFbGVtZW50KHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBIVE1MRWxlbWVudCB7XHJcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUZXN0IGlmIGEgZ2l2ZW4gdmFsdWUgaXMgdHlwZSBudW1iZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSBcdFx0XHRcdFx0VGhlIGdpdmVuIHZhbHVlXHJcbiAqIEByZXR1cm5zIFx0XHRcdFx0XHRcdFdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgbnVtYmVyXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXIodmFsdWU6IGFueSk6IHZhbHVlIGlzIG51bWJlciB7XHJcbiAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KHZhbHVlKSkgJiYgaXNGaW5pdGUodmFsdWUpO1xyXG59XHJcbiIsIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlICovXHJcblxyXG52YXIgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoYi5oYXNPd25Qcm9wZXJ0eShwKSkgZFtwXSA9IGJbcF07IH07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxuZXhwb3J0IHZhciBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgcyA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIGlmIChlLmluZGV4T2YocFtpXSkgPCAwKVxyXG4gICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHJlc3VsdC52YWx1ZSk7IH0pLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0geVtvcFswXSAmIDIgPyBcInJldHVyblwiIDogb3BbMF0gPyBcInRocm93XCIgOiBcIm5leHRcIl0pICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gWzAsIHQudmFsdWVdO1xyXG4gICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IGNhc2UgMTogdCA9IG9wOyBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDc6IG9wID0gXy5vcHMucG9wKCk7IF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gMyAmJiAoIXQgfHwgKG9wWzFdID4gdFswXSAmJiBvcFsxXSA8IHRbM10pKSkgeyBfLmxhYmVsID0gb3BbMV07IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0WzJdKSBfLm9wcy5wb3AoKTtcclxuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIG9wID0gYm9keS5jYWxsKHRoaXNBcmcsIF8pO1xyXG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cclxuICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBleHBvcnRzKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmICghZXhwb3J0cy5oYXNPd25Qcm9wZXJ0eShwKSkgZXhwb3J0c1twXSA9IG1bcF07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcclxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3JlYWQobywgbikge1xyXG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xyXG4gICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxyXG4gICAgZmluYWxseSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0KHYpIHtcclxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2YgX19hd2FpdCA/ICh0aGlzLnYgPSB2LCB0aGlzKSA6IG5ldyBfX2F3YWl0KHYpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7ICB9XHJcbiAgICBmdW5jdGlvbiBmdWxmaWxsKHZhbHVlKSB7IHJlc3VtZShcIm5leHRcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUoZiwgdikgeyBpZiAoZih2KSwgcS5zaGlmdCgpLCBxLmxlbmd0aCkgcmVzdW1lKHFbMF1bMF0sIHFbMF1bMV0pOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jRGVsZWdhdG9yKG8pIHtcclxuICAgIHZhciBpLCBwO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiLCBmdW5jdGlvbiAoZSkgeyB0aHJvdyBlOyB9KSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpZiAob1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY1ZhbHVlcyhvKSB7XHJcbiAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgdmFyIG0gPSBvW1N5bWJvbC5hc3luY0l0ZXJhdG9yXTtcclxuICAgIHJldHVybiBtID8gbS5jYWxsKG8pIDogdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9faW1wb3J0U3Rhcihtb2QpIHtcclxuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XHJcbiAgICB2YXIgcmVzdWx0ID0ge307XHJcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgcmVzdWx0W2tdID0gbW9kW2tdO1xyXG4gICAgcmVzdWx0LmRlZmF1bHQgPSBtb2Q7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19pbXBvcnREZWZhdWx0KG1vZCkge1xyXG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBkZWZhdWx0OiBtb2QgfTtcclxufVxyXG4iLCJpbXBvcnQgeyBPYnNlcnZhYmxlLCBSZXBsYXlTdWJqZWN0IH0gZnJvbSAncnhqcy9pbmRleCc7XHJcblxyXG5pbXBvcnQgeyBFQVNJTkcgfSBmcm9tICcuLi9zdGF0aWNzL3Njcm9sbC10by1oZWxwZXJzJztcclxuaW1wb3J0IHtcclxuICBTY3JvbGxUb0NvbmZpZ09wdGlvbnMsXHJcbiAgU2Nyb2xsVG9MaXN0ZW5lclRhcmdldFxyXG59IGZyb20gJy4uL21vZGVscy9zY3JvbGwtdG8tY29uZmlnLm1vZGVsJztcclxuXHJcbi8qKlxyXG4gKiBTY3JvbGwgVG8gQW5pbWF0aW9uLlxyXG4gKi9cclxuZXhwb3J0IGNsYXNzIFNjcm9sbFRvQW5pbWF0aW9uIHtcclxuXHJcbiAgLyoqXHJcbiAgICogTnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBmb3IgZWFjaCBUaWNrLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgX3RpY2s6IG51bWJlcjtcclxuXHJcbiAgLyoqXHJcbiAgICogSmF2YVNjcmlwdCBJbnRlcnZhbC5cclxuICAgKi9cclxuICBwcml2YXRlIF9pbnRlcnZhbDogYW55O1xyXG5cclxuICAvKipcclxuICAgKiBUaW1lIExhcHNlZCBpbiBtaWxsaXNlY29uZHMuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfdGltZUxhcHNlZDogbnVtYmVyO1xyXG5cclxuICAvKipcclxuICAgKiBQZXJjZW50YWdlIG9mIHRpbWUgbGFwc2VkLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgX3BlcmNlbnRhZ2U6IG51bWJlcjtcclxuXHJcbiAgLyoqXHJcbiAgICogUG9zaXRpb24gb2YgdGhlIEVsZW1lbnQuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfcG9zaXRpb246IG51bWJlcjtcclxuXHJcbiAgLyoqXHJcbiAgICogTGFzdCBQb3NpdGlvbi5cclxuICAgKi9cclxuICBwcml2YXRlIF9sYXN0UG9zaXRpb246IG51bWJlcjtcclxuXHJcbiAgLyoqXHJcbiAgICogU3RhcnQgUG9zaXRpb24gb2YgdGhlIEVsZW1lbnQuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfc3RhcnRQb3NpdGlvbjogbnVtYmVyO1xyXG5cclxuICAvKipcclxuICAgKiBUaGUgRGlzdGFuY2UgdG8gc2Nyb2xsLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgX2Rpc3RhbmNlOiBudW1iZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIE9ic2VydmFibGUgU291cmNlLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgX3NvdXJjZSQ6IFJlcGxheVN1YmplY3Q8bnVtYmVyPjtcclxuXHJcbiAgLyoqXHJcbiAgICogU2Nyb2xsIFRvcCBvZiB0aGUgV2luZG93LlxyXG4gICAqL1xyXG4gIHByaXZhdGUgX3dpbmRvd1Njcm9sbFRvcDogbnVtYmVyO1xyXG5cclxuICAvKipcclxuICAgKiBNYXBwZWQgT2Zmc2V0IHRha2VuIGZyb20gdGhlIGFjdGl2ZSBPZmZzZXQgTWFwLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgX21hcHBlZE9mZnNldDogbnVtYmVyO1xyXG5cclxuICAvKipcclxuICAgKiBDbGFzcyBDb25zdHJ1Y3Rvci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBfY29udGFpbmVyICAgICAgICAgICAgVGhlIENvbnRhaW5lclxyXG4gICAqIEBwYXJhbSBfbGlzdGVuZXJUYXJnZXQgICAgICAgVGhlIEVsZW1lbnQgdGhhdCBsaXN0ZW5zIGZvciBET00gRXZlbnRzXHJcbiAgICogQHBhcmFtIF9pc1dpbmRvdyAgICAgICAgICAgICBXaGV0aGVyIG9yIG5vdCB0aGUgbGlzdGVuZXIgaXMgdGhlIFdpbmRvd1xyXG4gICAqIEBwYXJhbSBfdG8gICAgICAgICAgICAgICAgICAgUG9zaXRpb24gdG8gc2Nyb2xsIHRvXHJcbiAgICogQHBhcmFtIF9vcHRpb25zICAgICAgICAgICAgICBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHNjcm9sbGluZ1xyXG4gICAqIEBwYXJhbSBfaXNCcm93c2VyICAgICAgICAgICAgV2hldGhlciBvciBub3QgZXhlY3V0aW9uIHJ1bnMgaW4gdGhlIGJyb3dzZXJcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChhcyBvcHBvc2VkIHRvIHRoZSBzZXJ2ZXIpXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBwcml2YXRlIF9jb250YWluZXI6IEhUTUxFbGVtZW50LFxyXG4gICAgcHJpdmF0ZSBfbGlzdGVuZXJUYXJnZXQ6IFNjcm9sbFRvTGlzdGVuZXJUYXJnZXQsXHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9pc1dpbmRvdzogYm9vbGVhbixcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgX3RvOiBudW1iZXIsXHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9vcHRpb25zOiBTY3JvbGxUb0NvbmZpZ09wdGlvbnMsXHJcbiAgICBwcml2YXRlIF9pc0Jyb3dzZXI6IGJvb2xlYW5cclxuICApIHtcclxuICAgIHRoaXMuX3RpY2sgPSAxNjtcclxuICAgIHRoaXMuX2ludGVydmFsID0gbnVsbDtcclxuICAgIHRoaXMuX2xhc3RQb3NpdGlvbiA9IG51bGw7XHJcbiAgICB0aGlzLl90aW1lTGFwc2VkID0gMDtcclxuXHJcbiAgICB0aGlzLl93aW5kb3dTY3JvbGxUb3AgPSB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCB8fCAwO1xyXG5cclxuICAgIGlmICghdGhpcy5fY29udGFpbmVyKSB7XHJcbiAgICAgIHRoaXMuX3N0YXJ0UG9zaXRpb24gPSB0aGlzLl93aW5kb3dTY3JvbGxUb3A7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl9zdGFydFBvc2l0aW9uID0gdGhpcy5faXNXaW5kb3cgPyB0aGlzLl93aW5kb3dTY3JvbGxUb3AgOiB0aGlzLl9jb250YWluZXIuc2Nyb2xsVG9wO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENvcnJlY3Rpb24gZm9yIFN0YXJ0aW5nIFBvc2l0aW9uIG9mIG5lc3RlZCBIVE1MIEVsZW1lbnRzXHJcbiAgICBpZiAodGhpcy5fY29udGFpbmVyICYmICF0aGlzLl9pc1dpbmRvdykge1xyXG4gICAgICB0aGlzLl90byA9IHRoaXMuX3RvIC0gdGhpcy5fY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCArIHRoaXMuX3N0YXJ0UG9zaXRpb247XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU2V0IERpc3RhbmNlXHJcbiAgICBjb25zdCBkaXJlY3Rpb25hbERpc3RhbmNlID0gdGhpcy5fc3RhcnRQb3NpdGlvbiAtIHRoaXMuX3RvO1xyXG4gICAgdGhpcy5fZGlzdGFuY2UgPSB0aGlzLl9jb250YWluZXIgPyBNYXRoLmFicyh0aGlzLl9zdGFydFBvc2l0aW9uIC0gdGhpcy5fdG8pIDogdGhpcy5fdG87XHJcblxyXG4gICAgdGhpcy5fbWFwcGVkT2Zmc2V0ID0gdGhpcy5fb3B0aW9ucy5vZmZzZXQ7XHJcblxyXG4gICAgLy8gU2V0IG9mZnNldCBmcm9tIE9mZnNldCBNYXBcclxuICAgIGlmICh0aGlzLl9pc0Jyb3dzZXIpIHtcclxuICAgICAgdGhpcy5fb3B0aW9uc1xyXG4gICAgICAgIC5vZmZzZXRNYXBcclxuICAgICAgICAuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4gdGhpcy5fbWFwcGVkT2Zmc2V0ID0gd2luZG93LmlubmVyV2lkdGggPiBrZXkgPyB2YWx1ZSA6IHRoaXMuX21hcHBlZE9mZnNldCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fZGlzdGFuY2UgKz0gdGhpcy5fbWFwcGVkT2Zmc2V0ICogKGRpcmVjdGlvbmFsRGlzdGFuY2UgPD0gMCA/IDEgOiAtMSk7XHJcbiAgICB0aGlzLl9zb3VyY2UkID0gbmV3IFJlcGxheVN1YmplY3QoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXJ0IHRoZSBuZXcgU2Nyb2xsIEFuaW1hdGlvbi5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zICAgICAgICAgT2JzZXJ2YWJsZSBjb250YWluaW5nIGEgbnVtYmVyXHJcbiAgICovXHJcbiAgcHVibGljIHN0YXJ0KCk6IE9ic2VydmFibGU8bnVtYmVyPiB7XHJcbiAgICBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKTtcclxuICAgIHRoaXMuX2ludGVydmFsID0gc2V0SW50ZXJ2YWwodGhpcy5fbG9vcCwgdGhpcy5fdGljayk7XHJcbiAgICByZXR1cm4gdGhpcy5fc291cmNlJC5hc09ic2VydmFibGUoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlY3Vyc2l2ZWx5IGxvb3Agb3ZlciB0aGUgU2Nyb2xsIEFuaW1hdGlvbi5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zICAgICAgICAgICBWb2lkXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfbG9vcCA9ICgpOiB2b2lkID0+IHtcclxuXHJcbiAgICB0aGlzLl90aW1lTGFwc2VkICs9IHRoaXMuX3RpY2s7XHJcbiAgICB0aGlzLl9wZXJjZW50YWdlID0gKHRoaXMuX3RpbWVMYXBzZWQgLyB0aGlzLl9vcHRpb25zLmR1cmF0aW9uKTtcclxuICAgIHRoaXMuX3BlcmNlbnRhZ2UgPSAodGhpcy5fcGVyY2VudGFnZSA+IDEpID8gMSA6IHRoaXMuX3BlcmNlbnRhZ2U7XHJcblxyXG4gICAgLy8gUG9zaXRpb24gVXBkYXRlXHJcbiAgICB0aGlzLl9wb3NpdGlvbiA9IHRoaXMuX3N0YXJ0UG9zaXRpb24gK1xyXG4gICAgICAoKHRoaXMuX3N0YXJ0UG9zaXRpb24gLSB0aGlzLl90byA8PSAwID8gMSA6IC0xKSAqXHJcbiAgICAgICAgdGhpcy5fZGlzdGFuY2UgKlxyXG4gICAgICAgIEVBU0lOR1t0aGlzLl9vcHRpb25zLmVhc2luZ10odGhpcy5fcGVyY2VudGFnZSkpO1xyXG5cclxuICAgIGlmICh0aGlzLl9sYXN0UG9zaXRpb24gIT09IG51bGwgJiYgdGhpcy5fcG9zaXRpb24gPT09IHRoaXMuX2xhc3RQb3NpdGlvbikge1xyXG4gICAgICB0aGlzLnN0b3AoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX3NvdXJjZSQubmV4dCh0aGlzLl9wb3NpdGlvbik7XHJcbiAgICAgIHRoaXMuX2lzV2luZG93XHJcbiAgICAgICAgPyB0aGlzLl9saXN0ZW5lclRhcmdldC5zY3JvbGxUbygwLCBNYXRoLmZsb29yKHRoaXMuX3Bvc2l0aW9uKSlcclxuICAgICAgICA6IHRoaXMuX2NvbnRhaW5lci5zY3JvbGxUb3AgPSBNYXRoLmZsb29yKHRoaXMuX3Bvc2l0aW9uKTtcclxuICAgICAgdGhpcy5fbGFzdFBvc2l0aW9uID0gdGhpcy5fcG9zaXRpb247XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdG9wIHRoZSBjdXJyZW50IFNjcm9sbCBBbmltYXRpb24gTG9vcC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBmb3JjZSBcdFx0XHQgICAgRm9yY2UgdG8gc3RvcCB0aGUgQW5pbWF0aW9uIExvb3BcclxuICAgKiBAcmV0dXJucyAgICAgICAgICAgICAgIFZvaWRcclxuICAgKi9cclxuICBwdWJsaWMgc3RvcCgpOiB2b2lkIHtcclxuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpO1xyXG4gICAgdGhpcy5faW50ZXJ2YWwgPSBudWxsO1xyXG4gICAgdGhpcy5fc291cmNlJC5jb21wbGV0ZSgpO1xyXG4gIH1cclxufVxyXG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBQTEFURk9STV9JRCwgSW5qZWN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IERPQ1VNRU5UIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcclxuaW1wb3J0IHsgaXNQbGF0Zm9ybUJyb3dzZXIgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5cclxuaW1wb3J0IHtcclxuICBTY3JvbGxUb0NvbmZpZ09wdGlvbnMsXHJcbiAgU2Nyb2xsVG9UYXJnZXQsXHJcbiAgU2Nyb2xsVG9MaXN0ZW5lclRhcmdldCxcclxuICBTY3JvbGxUb0NvbmZpZ09wdGlvbnNUYXJnZXRcclxufSBmcm9tICcuL21vZGVscy9zY3JvbGwtdG8tY29uZmlnLm1vZGVsJztcclxuaW1wb3J0IHsgU2Nyb2xsVG9BbmltYXRpb24gfSBmcm9tICcuL3N0YXRpY3Mvc2Nyb2xsLXRvLWFuaW1hdGlvbic7XHJcbmltcG9ydCB7XHJcbiAgc3RyaXBIYXNoLFxyXG4gIGlzU3RyaW5nLFxyXG4gIGlzTnVtYmVyLFxyXG4gIGlzRWxlbWVudFJlZixcclxuICBpc1dpbmRvdyxcclxuICBERUZBVUxUUyxcclxuICBpc05hdGl2ZUVsZW1lbnRcclxufSBmcm9tICcuL3N0YXRpY3Mvc2Nyb2xsLXRvLWhlbHBlcnMnO1xyXG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBSZXBsYXlTdWJqZWN0LCB0aHJvd0Vycm9yIH0gZnJvbSAncnhqcy9pbmRleCc7XHJcblxyXG4vKipcclxuICogVGhlIFNjcm9sbFRvU2VydmljZSBoYW5kbGVzIHN0YXJ0aW5nLCBpbnRlcnJ1cHRpbmdcclxuICogYW5kIGVuZGluZyB0aGUgYWN0dWFsIFNjcm9sbCBBbmltYXRpb24uIEl0IHByb3ZpZGVzXHJcbiAqIHNvbWUgdXRpbGl0aWVzIHRvIGZpbmQgdGhlIHByb3BlciBIVE1MIEVsZW1lbnQgb24gYVxyXG4gKiBnaXZlbiBwYWdlIHRvIHNldHVwIEV2ZW50IExpc3RlbmVycyBhbmQgY2FsY3VsYXRlXHJcbiAqIGRpc3RhbmNlcyBmb3IgdGhlIEFuaW1hdGlvbi5cclxuICovXHJcbkBJbmplY3RhYmxlKClcclxuZXhwb3J0IGNsYXNzIFNjcm9sbFRvU2VydmljZSB7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBhbmltYXRpb24gdGhhdCBwcm92aWRlcyB0aGUgc2Nyb2xsaW5nXHJcbiAgICogdG8gaGFwcGVuIHNtb290aGx5IG92ZXIgdGltZS4gRGVmaW5pbmcgaXQgaGVyZVxyXG4gICAqIGFsbG93cyBmb3IgdXNhZ2Ugb2YgZS5nLiBgc3RhcnRgIGFuZCBgc3RvcGBcclxuICAgKiBtZXRob2RzIHdpdGhpbiB0aGlzIEFuZ3VsYXIgU2VydmljZS5cclxuICAgKi9cclxuICBwcml2YXRlIF9hbmltYXRpb246IFNjcm9sbFRvQW5pbWF0aW9uO1xyXG5cclxuICAvKipcclxuICAgKiBJbnRlcnJ1cHRpdmUgRXZlbnRzIGFsbG93IHRvIHNjcm9sbGluZyBhbmltYXRpb25cclxuICAgKiB0byBiZSBpbnRlcnJ1cHRlZCBiZWZvcmUgaXQgaXMgZmluaXNoZWQuIFRoZSBsaXN0XHJcbiAgICogb2YgSW50ZXJydXB0aXZlIEV2ZW50cyByZXByZXNlbnRzIHRob3NlLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgX2ludGVycnVwdGl2ZUV2ZW50czogc3RyaW5nW107XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnN0cnVjdCBhbmQgc2V0dXAgcmVxdWlyZWQgcGFyYXRlbWV0ZXJzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIF9kb2N1bWVudCAgICAgICAgIEEgUmVmZXJlbmNlIHRvIHRoZSBEb2N1bWVudFxyXG4gICAqIEBwYXJhbSBfcGxhdGZvcm1JZCAgICAgICBBbmd1bGFyIFBsYXRmb3JtIElEXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBASW5qZWN0KERPQ1VNRU5UKSBwcml2YXRlIF9kb2N1bWVudDogYW55LFxyXG4gICAgQEluamVjdChQTEFURk9STV9JRCkgcHJpdmF0ZSBfcGxhdGZvcm1JZDogYW55XHJcbiAgKSB7XHJcbiAgICB0aGlzLl9pbnRlcnJ1cHRpdmVFdmVudHMgPSBbJ21vdXNld2hlZWwnLCAnRE9NTW91c2VTY3JvbGwnLCAndG91Y2hzdGFydCddO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGFyZ2V0IGFuIEVsZW1lbnQgdG8gc2Nyb2xsIHRvLiBOb3RpY2UgdGhhdCB0aGUgYFRpbWVPdXRgIGRlY29yYXRvclxyXG4gICAqIGVuc3VyZXMgdGhlIGV4ZWN1dGluZyB0byB0YWtlIHBsYWNlIGluIHRoZSBuZXh0IEFuZ3VsYXIgbGlmZWN5Y2xlLlxyXG4gICAqIFRoaXMgYWxsb3dzIGZvciBzY3JvbGxpbmcgdG8gZWxlbWVudHMgdGhhdCBhcmUgZS5nLiBpbml0aWFsbHkgaGlkZGVuXHJcbiAgICogYnkgbWVhbnMgb2YgYCpuZ0lmYCwgYnV0IG91Z2h0IHRvIGJlIHNjcm9sbGVkIHRvIGV2ZW50dWFsbHkuXHJcbiAgICpcclxuICAgKiBAdG9kbyB0eXBlICdhbnknIGluIE9ic2VydmFibGUgc2hvdWxkIGJlY29tZSBjdXN0b20gdHlwZSBsaWtlICdTY3JvbGxUb0V2ZW50JyAoYmFzZSBjbGFzcyksIHNlZSBpc3N1ZSBjb21tZW50OlxyXG4gICAqIFx0LSBodHRwczovL2dpdGh1Yi5jb20vbmlja3ktbGVuYWVycy9uZ3gtc2Nyb2xsLXRvL2lzc3Vlcy8xMCNpc3N1ZWNvbW1lbnQtMzE3MTk4NDgxXHJcbiAgICpcclxuICAgKiBAcGFyYW0gb3B0aW9ucyAgICAgICAgIENvbmZpZ3VyYXRpb24gT2JqZWN0XHJcbiAgICogQHJldHVybnMgICAgICAgICAgICAgICBPYnNlcnZhYmxlXHJcbiAgICovXHJcbiAgcHVibGljIHNjcm9sbFRvKG9wdGlvbnM6IFNjcm9sbFRvQ29uZmlnT3B0aW9ucyk6IE9ic2VydmFibGU8YW55PiB7XHJcblxyXG4gICAgaWYgKCFpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLl9wbGF0Zm9ybUlkKSkgcmV0dXJuIG5ldyBSZXBsYXlTdWJqZWN0KCkuYXNPYnNlcnZhYmxlKCk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0KG9wdGlvbnMpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RhcnQgYSBuZXcgQW5pbWF0aW9uLlxyXG4gICAqXHJcbiAgICogQHRvZG8gRW1pdCBwcm9wZXIgZXZlbnRzIGZyb20gc3Vic2NyaXB0aW9uXHJcbiAgICpcclxuICAgKiBAcGFyYW0gb3B0aW9ucyAgICAgICAgIENvbmZpZ3VyYXRpb24gT2JqZWN0XHJcbiAgICogQHJldHVybnMgICAgICAgICAgICAgICBPYnNlcnZhYmxlXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfc3RhcnQob3B0aW9uczogU2Nyb2xsVG9Db25maWdPcHRpb25zKTogT2JzZXJ2YWJsZTxudW1iZXI+IHtcclxuXHJcbiAgICAvLyBNZXJnZSBjb25maWcgd2l0aCBkZWZhdWx0IHZhbHVlc1xyXG4gICAgY29uc3QgbWVyZ2VkQ29uZmlnT3B0aW9ucyA9IHtcclxuICAgICAgLi4uREVGQVVMVFMgYXMgU2Nyb2xsVG9Db25maWdPcHRpb25zLFxyXG4gICAgICAuLi5vcHRpb25zXHJcbiAgICB9IGFzIFNjcm9sbFRvQ29uZmlnT3B0aW9uc1RhcmdldDtcclxuXHJcbiAgICBpZiAodGhpcy5fYW5pbWF0aW9uKSB0aGlzLl9hbmltYXRpb24uc3RvcCgpO1xyXG5cclxuICAgIGNvbnN0IHRhcmdldE5vZGUgPSB0aGlzLl9nZXROb2RlKG1lcmdlZENvbmZpZ09wdGlvbnMudGFyZ2V0KTtcclxuICAgIGlmIChtZXJnZWRDb25maWdPcHRpb25zLnRhcmdldCAmJiAhdGFyZ2V0Tm9kZSkgcmV0dXJuIHRocm93RXJyb3IoJ1VuYWJsZSB0byBmaW5kIFRhcmdldCBFbGVtZW50Jyk7XHJcblxyXG4gICAgY29uc3QgY29udGFpbmVyOiBIVE1MRWxlbWVudCA9IHRoaXMuX2dldENvbnRhaW5lcihtZXJnZWRDb25maWdPcHRpb25zLCB0YXJnZXROb2RlKTtcclxuICAgIGlmIChtZXJnZWRDb25maWdPcHRpb25zLmNvbnRhaW5lciAmJiAhY29udGFpbmVyKSByZXR1cm4gdGhyb3dFcnJvcignVW5hYmxlIHRvIGZpbmQgQ29udGFpbmVyIEVsZW1lbnQnKTtcclxuXHJcbiAgICBjb25zdCBsaXN0ZW5lclRhcmdldCA9IHRoaXMuX2dldExpc3RlbmVyVGFyZ2V0KGNvbnRhaW5lcikgfHwgd2luZG93O1xyXG5cclxuICAgIGxldCB0byA9IGNvbnRhaW5lciA/IGNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgOiAwO1xyXG5cclxuICAgIGlmICh0YXJnZXROb2RlKSB7XHJcbiAgICAgIHRvID0gaXNXaW5kb3cobGlzdGVuZXJUYXJnZXQpID8gdGFyZ2V0Tm9kZS5vZmZzZXRUb3AgOiB0YXJnZXROb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDcmVhdGUgQW5pbWF0aW9uXHJcbiAgICB0aGlzLl9hbmltYXRpb24gPSBuZXcgU2Nyb2xsVG9BbmltYXRpb24oXHJcbiAgICAgIGNvbnRhaW5lcixcclxuICAgICAgbGlzdGVuZXJUYXJnZXQsXHJcbiAgICAgIGlzV2luZG93KGxpc3RlbmVyVGFyZ2V0KSxcclxuICAgICAgdG8sXHJcbiAgICAgIG1lcmdlZENvbmZpZ09wdGlvbnMsXHJcbiAgICAgIGlzUGxhdGZvcm1Ccm93c2VyKHRoaXMuX3BsYXRmb3JtSWQpXHJcbiAgICApO1xyXG4gICAgY29uc3Qgb25JbnRlcnJ1cHQgPSAoKSA9PiB0aGlzLl9hbmltYXRpb24uc3RvcCgpO1xyXG4gICAgdGhpcy5fYWRkSW50ZXJydXB0aXZlRXZlbnRMaXN0ZW5lcnMobGlzdGVuZXJUYXJnZXQsIG9uSW50ZXJydXB0KTtcclxuXHJcbiAgICAvLyBTdGFydCBBbmltYXRpb25cclxuICAgIGNvbnN0IGFuaW1hdGlvbiQgPSB0aGlzLl9hbmltYXRpb24uc3RhcnQoKTtcclxuICAgIHRoaXMuX3N1YnNjcmliZVRvQW5pbWF0aW9uKGFuaW1hdGlvbiQsIGxpc3RlbmVyVGFyZ2V0LCBvbkludGVycnVwdCk7XHJcblxyXG4gICAgcmV0dXJuIGFuaW1hdGlvbiQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdWJzY3JpYmUgdG8gdGhlIGV2ZW50cyBlbWl0dGVkIGZyb20gdGhlIFNjcm9sbGluZ1xyXG4gICAqIEFuaW1hdGlvbi4gRXZlbnRzIG1pZ2h0IGJlIHVzZWQgZm9yIGUuZy4gdW5zdWJzY3JpYmluZ1xyXG4gICAqIG9uY2UgZmluaXNoZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gYW5pbWF0aW9uJCAgICAgICAgICAgICAgVGhlIEFuaW1hdGlvbiBPYnNlcnZhYmxlXHJcbiAgICogQHBhcmFtIGxpc3RlbmVyVGFyZ2V0ICAgICAgICAgIFRoZSBMaXN0ZW5lciBUYXJnZXQgZm9yIGV2ZW50c1xyXG4gICAqIEBwYXJhbSBvbkludGVycnVwdCAgICAgICAgICAgICBUaGUgaGFuZGxlciBmb3IgSW50ZXJydXB0aXZlIEV2ZW50c1xyXG4gICAqIEByZXR1cm5zICAgICAgICAgICAgICAgICAgICAgICBWb2lkXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfc3Vic2NyaWJlVG9BbmltYXRpb24oXHJcbiAgICAgIGFuaW1hdGlvbiQ6IE9ic2VydmFibGU8YW55PixcclxuICAgICAgbGlzdGVuZXJUYXJnZXQ6IFNjcm9sbFRvTGlzdGVuZXJUYXJnZXQsXHJcbiAgICAgIG9uSW50ZXJydXB0OiBFdmVudExpc3RlbmVyT3JFdmVudExpc3RlbmVyT2JqZWN0KSB7XHJcbiAgICBjb25zdCBzdWJzY3JpcHRpb24gPSBhbmltYXRpb24kXHJcbiAgICAgIC5zdWJzY3JpYmUoXHJcbiAgICAgICAgKCkgPT4geyB9LFxyXG4gICAgICAgICgpID0+IHsgfSxcclxuICAgICAgICAoKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLl9yZW1vdmVJbnRlcnJ1cHRpdmVFdmVudExpc3RlbmVycyh0aGlzLl9pbnRlcnJ1cHRpdmVFdmVudHMsIGxpc3RlbmVyVGFyZ2V0LCBvbkludGVycnVwdCk7XHJcbiAgICAgICAgICBzdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIGNvbnRhaW5lciBIVE1MIEVsZW1lbnQgaW4gd2hpY2hcclxuICAgKiB0aGUgc2Nyb2xsaW5nIHNob3VsZCBoYXBwZW4uXHJcbiAgICpcclxuICAgKiBAcGFyYW0gb3B0aW9ucyAgICAgICAgIFRoZSBNZXJnZWQgQ29uZmlndXJhdGlvbiBPYmplY3RcclxuICAgKiBAcGFyYW0gdGFyZ2V0Tm9kZSAgICB0aGUgdGFyZ2V0ZWQgSFRNTEVsZW1lbnRcclxuICAgKiBAcmV0dXJuc1xyXG4gICAqL1xyXG4gIHByaXZhdGUgX2dldENvbnRhaW5lcihvcHRpb25zOiBTY3JvbGxUb0NvbmZpZ09wdGlvbnMsIHRhcmdldE5vZGU6IEhUTUxFbGVtZW50KTogSFRNTEVsZW1lbnQgfCBudWxsIHtcclxuXHJcbiAgICBsZXQgY29udGFpbmVyOiBIVE1MRWxlbWVudCB8IG51bGwgPSBudWxsO1xyXG5cclxuICAgIGlmIChvcHRpb25zLmNvbnRhaW5lcikge1xyXG4gICAgICBjb250YWluZXIgPSB0aGlzLl9nZXROb2RlKG9wdGlvbnMuY29udGFpbmVyLCB0cnVlKTtcclxuICAgIH0gZWxzZSBpZiAodGFyZ2V0Tm9kZSkge1xyXG4gICAgICBjb250YWluZXIgPSB0aGlzLl9nZXRGaXJzdFNjcm9sbGFibGVQYXJlbnQodGFyZ2V0Tm9kZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZCBsaXN0ZW5lcnMgZm9yIHRoZSBBbmltYXRpb24gSW50ZXJydXB0aXZlIEV2ZW50c1xyXG4gICAqIHRvIHRoZSBMaXN0ZW5lciBUYXJnZXQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gZXZlbnRzICAgICAgICAgICAgTGlzdCBvZiBldmVudHMgdG8gbGlzdGVuIHRvXHJcbiAgICogQHBhcmFtIGxpc3RlbmVyVGFyZ2V0ICAgIFRhcmdldCB0byBhdHRhY2ggdGhlIGxpc3RlbmVyIG9uXHJcbiAgICogQHBhcmFtIGhhbmRsZXIgICAgICAgICAgIEhhbmRsZXIgZm9yIHdoZW4gdGhlIGxpc3RlbmVyIGZpcmVzXHJcbiAgICogQHJldHVybnMgICAgICAgICAgICAgICAgIFZvaWRcclxuICAgKi9cclxuICBwcml2YXRlIF9hZGRJbnRlcnJ1cHRpdmVFdmVudExpc3RlbmVycyhcclxuICAgIGxpc3RlbmVyVGFyZ2V0OiBTY3JvbGxUb0xpc3RlbmVyVGFyZ2V0LFxyXG4gICAgaGFuZGxlcjogRXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdCk6IHZvaWQge1xyXG5cclxuICAgICAgaWYgKCFsaXN0ZW5lclRhcmdldCkgbGlzdGVuZXJUYXJnZXQgPSB3aW5kb3c7XHJcblxyXG4gICAgdGhpcy5faW50ZXJydXB0aXZlRXZlbnRzLmZvckVhY2goZXZlbnQgPT4gbGlzdGVuZXJUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlcikpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlIGxpc3RlbmVycyBmb3IgdGhlIEFuaW1hdGlvbiBJbnRlcnJ1cHQgRXZlbnQgZnJvbVxyXG4gICAqIHRoZSBMaXN0ZW5lciBUYXJnZXQuIFNwZWNpZnlpbmcgdGhlIGNvcnJlY3QgaGFuZGxlciBwcmV2ZW50c1xyXG4gICAqIG1lbW9yeSBsZWFrcyBhbmQgbWFrZXMgdGhlIGFsbG9jYXRlZCBtZW1vcnkgYXZhaWxhYmxlIGZvclxyXG4gICAqIEdhcmJhZ2UgQ29sbGVjdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBldmVudHMgICAgICAgICAgICBMaXN0IG9mIEludGVycnVwdGl2ZSBFdmVudHMgdG8gcmVtb3ZlXHJcbiAgICogQHBhcmFtIGxpc3RlbmVyVGFyZ2V0ICAgIFRhcmdldCB0byBhdHRhY2ggdGhlIGxpc3RlbmVyIG9uXHJcbiAgICogQHBhcmFtIGhhbmRsZXIgICAgICAgICAgIEhhbmRsZXIgZm9yIHdoZW4gdGhlIGxpc3RlbmVyIGZpcmVzXHJcbiAgICogQHJldHVybnMgICAgICAgICAgICAgICAgIFZvaWRcclxuICAgKi9cclxuICBwcml2YXRlIF9yZW1vdmVJbnRlcnJ1cHRpdmVFdmVudExpc3RlbmVycyhcclxuICAgIGV2ZW50czogc3RyaW5nW10sXHJcbiAgICBsaXN0ZW5lclRhcmdldDogU2Nyb2xsVG9MaXN0ZW5lclRhcmdldCxcclxuICAgIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3QpOiB2b2lkIHtcclxuXHJcbiAgICBpZiAoIWxpc3RlbmVyVGFyZ2V0KSBsaXN0ZW5lclRhcmdldCA9IHdpbmRvdztcclxuICAgIGV2ZW50cy5mb3JFYWNoKGV2ZW50ID0+IGxpc3RlbmVyVGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGhhbmRsZXIpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZpbmQgdGhlIGZpcnN0IHNjcm9sbGFibGUgcGFyZW50IE5vZGUgb2YgYSBnaXZlblxyXG4gICAqIEVsZW1lbnQuIFRoZSBET00gVHJlZSBnZXRzIHNlYXJjaGVkIHVwd2FyZHNcclxuICAgKiB0byBmaW5kIHRoaXMgZmlyc3Qgc2Nyb2xsYWJsZSBwYXJlbnQuIFBhcmVudHMgbWlnaHRcclxuICAgKiBiZSBpZ25vcmVkIGJ5IENTUyBzdHlsZXMgYXBwbGllZCB0byB0aGUgSFRNTCBFbGVtZW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIG5hdGl2ZUVsZW1lbnQgICAgIFRoZSBFbGVtZW50IHRvIHNlYXJjaCB0aGUgRE9NIFRyZWUgdXB3YXJkcyBmcm9tXHJcbiAgICogQHJldHVybnMgICAgICAgICAgICAgICAgIFRoZSBmaXJzdCBzY3JvbGxhYmxlIHBhcmVudCBIVE1MIEVsZW1lbnRcclxuICAgKi9cclxuICBwcml2YXRlIF9nZXRGaXJzdFNjcm9sbGFibGVQYXJlbnQobmF0aXZlRWxlbWVudDogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudCB7XHJcblxyXG4gICAgbGV0IHN0eWxlOiBDU1NTdHlsZURlY2xhcmF0aW9uID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUobmF0aXZlRWxlbWVudCk7XHJcblxyXG4gICAgY29uc3Qgb3ZlcmZsb3dSZWdleDogUmVnRXhwID0gLyhhdXRvfHNjcm9sbCkvO1xyXG5cclxuICAgIGlmIChzdHlsZS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykgcmV0dXJuIG51bGw7XHJcblxyXG4gICAgZm9yIChsZXQgcGFyZW50ID0gbmF0aXZlRWxlbWVudDsgcGFyZW50ID0gcGFyZW50LnBhcmVudEVsZW1lbnQ7IG51bGwpIHtcclxuXHJcbiAgICAgIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUocGFyZW50KTtcclxuXHJcbiAgICAgIGlmIChzdHlsZS5wb3NpdGlvbiA9PT0gJ2Fic29sdXRlJ1xyXG4gICAgICAgIHx8IHN0eWxlLm92ZXJmbG93ID09PSAnaGlkZGVuJ1xyXG4gICAgICAgIHx8IHN0eWxlLm92ZXJmbG93WSA9PT0gJ2hpZGRlbicpIGNvbnRpbnVlO1xyXG5cclxuICAgICAgaWYgKG92ZXJmbG93UmVnZXgudGVzdChzdHlsZS5vdmVyZmxvdyArIHN0eWxlLm92ZXJmbG93WSArIHN0eWxlLm92ZXJmbG93WClcclxuICAgICAgICB8fCBwYXJlbnQudGFnTmFtZSA9PT0gJ0JPRFknKSByZXR1cm4gcGFyZW50O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBUYXJnZXQgTm9kZSB0byBzY3JvbGwgdG8uXHJcbiAgICpcclxuICAgKiBAcGFyYW0gaWQgICAgICAgICAgICAgIFRoZSBnaXZlbiBJRCBvZiB0aGUgbm9kZSwgZWl0aGVyIGEgc3RyaW5nIG9yXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICBhbiBlbGVtZW50IHJlZmVyZW5jZVxyXG4gICAqIEBwYXJhbSBhbGxvd0JvZHlUYWcgICAgSW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhlIERvY3VtZW50IEJvZHkgaXNcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNpZGVyZWQgYSB2YWxpZCBUYXJnZXQgTm9kZVxyXG4gICAqIEByZXR1cm5zICAgICAgICAgICAgICAgVGhlIFRhcmdldCBOb2RlIHRvIHNjcm9sbCB0b1xyXG4gICAqL1xyXG4gIHByaXZhdGUgX2dldE5vZGUoaWQ6IFNjcm9sbFRvVGFyZ2V0LCBhbGxvd0JvZHlUYWc6IGJvb2xlYW4gPSBmYWxzZSk6IEhUTUxFbGVtZW50IHtcclxuXHJcbiAgICBsZXQgdGFyZ2V0Tm9kZTogSFRNTEVsZW1lbnQ7XHJcblxyXG4gICAgaWYgKGlzU3RyaW5nKGlkKSkge1xyXG5cclxuICAgICAgaWYgKGFsbG93Qm9keVRhZyAmJiAoaWQgPT09ICdib2R5JyB8fCBpZCA9PT0gJ0JPRFknKSkge1xyXG5cclxuICAgICAgICB0YXJnZXROb2RlID0gdGhpcy5fZG9jdW1lbnQuYm9keTtcclxuXHJcbiAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgIHRhcmdldE5vZGUgPSB0aGlzLl9kb2N1bWVudC5nZXRFbGVtZW50QnlJZChzdHJpcEhhc2goaWQpKTtcclxuXHJcbiAgICAgIH1cclxuXHJcbiAgICB9IGVsc2UgaWYgKGlzTnVtYmVyKGlkKSkge1xyXG5cclxuICAgICAgdGFyZ2V0Tm9kZSA9IHRoaXMuX2RvY3VtZW50LmdldEVsZW1lbnRCeUlkKFN0cmluZyhpZCkpO1xyXG5cclxuICAgIH0gZWxzZSBpZiAoaXNFbGVtZW50UmVmKGlkKSkge1xyXG5cclxuICAgICAgdGFyZ2V0Tm9kZSA9IGlkLm5hdGl2ZUVsZW1lbnQ7XHJcblxyXG4gICAgfSBlbHNlIGlmIChpc05hdGl2ZUVsZW1lbnQoaWQpKSB7XHJcblxyXG4gICAgICB0YXJnZXROb2RlID0gaWQ7XHJcblxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0YXJnZXROb2RlO1xyXG5cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHJpZXZlIHRoZSBMaXN0ZW5lciB0YXJnZXQuIFRoaXMgTGlzdGVuZXIgVGFyZ2V0IGlzIHVzZWRcclxuICAgKiB0byBhdHRhY2ggRXZlbnQgTGlzdGVuZXJzIG9uLiBJbiBjYXNlIG9mIHRoZSB0YXJnZXQgYmVpbmdcclxuICAgKiB0aGUgRG9jdW1lbnQgQm9keSwgd2UgbmVlZCB0aGUgYWN0dWFsIGB3aW5kb3dgIHRvIGxpc3RlblxyXG4gICAqIGZvciBldmVudHMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gY29udGFpbmVyICAgICAgICAgICBUaGUgSFRNTCBDb250YWluZXIgZWxlbWVudFxyXG4gICAqIEByZXR1cm5zICAgICAgICAgICAgICAgICAgIFRoZSBMaXN0ZW5lciBUYXJnZXQgdG8gYXR0YWNoIGV2ZW50cyBvblxyXG4gICAqL1xyXG4gIHByaXZhdGUgX2dldExpc3RlbmVyVGFyZ2V0KGNvbnRhaW5lcjogSFRNTEVsZW1lbnQpOiBTY3JvbGxUb0xpc3RlbmVyVGFyZ2V0IHtcclxuICAgIGlmICghY29udGFpbmVyKSByZXR1cm4gbnVsbDtcclxuICAgIHJldHVybiB0aGlzLl9pc0RvY3VtZW50Qm9keShjb250YWluZXIpID8gd2luZG93IDogY29udGFpbmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVGVzdCBpZiBhIGdpdmVuIEhUTUwgRWxlbWVudCBpcyB0aGUgRG9jdW1lbnQgQm9keS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBlbGVtZW50ICAgICAgICAgICAgIFRoZSBnaXZlbiBIVE1MIEVsZW1lbnRcclxuICAgKiBAcmV0dXJucyAgICAgICAgICAgICAgICAgICBXaGV0aGVyIG9yIG5vdCB0aGUgRWxlbWVudCBpcyB0aGVcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBEb2N1bWVudCBCb2R5IEVsZW1lbnRcclxuICAgKi9cclxuICBwcml2YXRlIF9pc0RvY3VtZW50Qm9keShlbGVtZW50OiBIVE1MRWxlbWVudCk6IGVsZW1lbnQgaXMgSFRNTEJvZHlFbGVtZW50IHtcclxuICAgIHJldHVybiBlbGVtZW50LnRhZ05hbWUudG9VcHBlckNhc2UoKSA9PT0gJ0JPRFknO1xyXG4gIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHtcclxuICBEaXJlY3RpdmUsXHJcbiAgSW5wdXQsXHJcbiAgRWxlbWVudFJlZixcclxuICBSZW5kZXJlcjIsXHJcbiAgQWZ0ZXJWaWV3SW5pdFxyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuaW1wb3J0IHtcclxuICBERUZBVUxUUyxcclxuICBFVkVOVFNcclxufSBmcm9tICcuL3N0YXRpY3Mvc2Nyb2xsLXRvLWhlbHBlcnMnO1xyXG5pbXBvcnQge1xyXG4gIFNjcm9sbFRvQ29uZmlnT3B0aW9ucyxcclxuICBTY3JvbGxUb09mZnNldE1hcCxcclxuICBTY3JvbGxUb1RhcmdldFxyXG59IGZyb20gJy4vbW9kZWxzL3Njcm9sbC10by1jb25maWcubW9kZWwnO1xyXG5pbXBvcnQge1xyXG4gIFNjcm9sbFRvQW5pbWF0aW9uRWFzaW5nXHJcbn0gZnJvbSAnLi9tb2RlbHMvc2Nyb2xsLXRvLWVhc2luZy5tb2RlbCc7XHJcbmltcG9ydCB7IFNjcm9sbFRvRXZlbnQgfSBmcm9tICcuL21vZGVscy9zY3JvbGwtdG8tZXZlbnQubW9kZWwnO1xyXG5pbXBvcnQgeyBTY3JvbGxUb1NlcnZpY2UgfSBmcm9tICcuL3Njcm9sbC10by5zZXJ2aWNlJztcclxuXHJcbkBEaXJlY3RpdmUoe1xyXG4gIHNlbGVjdG9yOiAnW25neC1zY3JvbGwtdG9dJ1xyXG59KVxyXG5leHBvcnQgY2xhc3MgU2Nyb2xsVG9EaXJlY3RpdmUgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0IHtcclxuXHJcbiAgQElucHV0KCduZ3gtc2Nyb2xsLXRvJylcclxuICBwdWJsaWMgbmd4U2Nyb2xsVG86IFNjcm9sbFRvVGFyZ2V0ID0gREVGQVVMVFMudGFyZ2V0O1xyXG5cclxuICBASW5wdXQoJ25neC1zY3JvbGwtdG8tZXZlbnQnKVxyXG4gIHB1YmxpYyBuZ3hTY3JvbGxUb0V2ZW50OiBTY3JvbGxUb0V2ZW50ID0gREVGQVVMVFMuYWN0aW9uO1xyXG5cclxuICBASW5wdXQoJ25neC1zY3JvbGwtdG8tZHVyYXRpb24nKVxyXG4gIHB1YmxpYyBuZ3hTY3JvbGxUb0R1cmF0aW9uOiBudW1iZXIgPSBERUZBVUxUUy5kdXJhdGlvbjtcclxuXHJcbiAgQElucHV0KCduZ3gtc2Nyb2xsLXRvLWVhc2luZycpXHJcbiAgcHVibGljIG5neFNjcm9sbFRvRWFzaW5nOiBTY3JvbGxUb0FuaW1hdGlvbkVhc2luZyA9IERFRkFVTFRTLmVhc2luZztcclxuXHJcbiAgQElucHV0KCduZ3gtc2Nyb2xsLXRvLW9mZnNldCcpXHJcbiAgcHVibGljIG5neFNjcm9sbFRvT2Zmc2V0OiBudW1iZXIgPSBERUZBVUxUUy5vZmZzZXQ7XHJcblxyXG4gIEBJbnB1dCgnbmd4LXNjcm9sbC10by1vZmZzZXQtbWFwJylcclxuICBwdWJsaWMgbmd4U2Nyb2xsVG9PZmZzZXRNYXA6IFNjcm9sbFRvT2Zmc2V0TWFwID0gREVGQVVMVFMub2Zmc2V0TWFwO1xyXG5cclxuICBwcml2YXRlIF9vcHRpb25zOiBTY3JvbGxUb0NvbmZpZ09wdGlvbnM7XHJcblxyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgcHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZixcclxuICAgIHByaXZhdGUgX3Njcm9sbFRvU2VydmljZTogU2Nyb2xsVG9TZXJ2aWNlLFxyXG4gICAgcHJpdmF0ZSBfcmVuZGVyZXIyOiBSZW5kZXJlcjIpIHtcclxuXHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBbmd1bGFyIExpZmVjeWNsZSBIb29rIC0gQWZ0ZXIgVmlldyBJbml0XHJcbiAgICpcclxuICAgKiBAdG9kbyBJbXBsZW1lbnQgU3Vic2NyaXB0aW9uIGZvciBFdmVudHNcclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHZvaWRcclxuICAgKi9cclxuICBwdWJsaWMgbmdBZnRlclZpZXdJbml0KCk6IHZvaWQge1xyXG5cclxuICAgIC8vIFRlc3QgRXZlbnQgU3VwcG9ydFxyXG4gICAgaWYgKEVWRU5UUy5pbmRleE9mKHRoaXMubmd4U2Nyb2xsVG9FdmVudCkgPT09IC0xKSB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIEV2ZW50ICcke3RoaXMubmd4U2Nyb2xsVG9FdmVudH0nYCk7XHJcblxyXG4gICAgLy8gTGlzdGVuIGZvciB0aGUgdHJpZ2dlci4uLlxyXG4gICAgdGhpcy5fcmVuZGVyZXIyLmxpc3Rlbih0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsIHRoaXMubmd4U2Nyb2xsVG9FdmVudCxcclxuICAgICAgKGV2ZW50OiBFdmVudCkgPT4ge1xyXG5cclxuICAgICAgICB0aGlzLl9vcHRpb25zID0ge1xyXG4gICAgICAgICAgdGFyZ2V0OiB0aGlzLm5neFNjcm9sbFRvLFxyXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMubmd4U2Nyb2xsVG9EdXJhdGlvbixcclxuICAgICAgICAgIGVhc2luZzogdGhpcy5uZ3hTY3JvbGxUb0Vhc2luZyxcclxuICAgICAgICAgIG9mZnNldDogdGhpcy5uZ3hTY3JvbGxUb09mZnNldCxcclxuICAgICAgICAgIG9mZnNldE1hcDogdGhpcy5uZ3hTY3JvbGxUb09mZnNldE1hcFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHRoaXMuX3Njcm9sbFRvU2VydmljZS5zY3JvbGxUbyh0aGlzLl9vcHRpb25zKTtcclxuICAgICAgfSk7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7IE5nTW9kdWxlLCBNb2R1bGVXaXRoUHJvdmlkZXJzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IFNjcm9sbFRvRGlyZWN0aXZlIH0gZnJvbSAnLi9zY3JvbGwtdG8uZGlyZWN0aXZlJztcclxuaW1wb3J0IHsgU2Nyb2xsVG9TZXJ2aWNlIH0gZnJvbSAnLi9zY3JvbGwtdG8uc2VydmljZSc7XHJcblxyXG5ATmdNb2R1bGUoe1xyXG4gIGRlY2xhcmF0aW9uczogW1xyXG4gICAgU2Nyb2xsVG9EaXJlY3RpdmVcclxuICBdLFxyXG4gIGV4cG9ydHM6IFtcclxuICAgIFNjcm9sbFRvRGlyZWN0aXZlXHJcbiAgXVxyXG59KVxyXG5leHBvcnQgY2xhc3MgU2Nyb2xsVG9Nb2R1bGUge1xyXG4gIC8qKlxyXG4gICAqIEd1YXJhbnRlZWQgc2luZ2xldG9ucyBmb3IgcHJvdmlkZWQgU2VydmljZXMgYWNyb3NzIEFwcC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4gICAgICAgICAgQW4gQW5ndWxhciBNb2R1bGUgd2l0aCBQcm92aWRlcnNcclxuICAgKi9cclxuICBzdGF0aWMgZm9yUm9vdCgpOiBNb2R1bGVXaXRoUHJvdmlkZXJzIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIG5nTW9kdWxlOiBTY3JvbGxUb01vZHVsZSxcclxuICAgICAgcHJvdmlkZXJzOiBbXHJcbiAgICAgICAgU2Nyb2xsVG9TZXJ2aWNlXHJcbiAgICAgIF1cclxuICAgIH07XHJcbiAgfVxyXG59XHJcbiJdLCJuYW1lcyI6WyJFbGVtZW50UmVmIiwiUmVwbGF5U3ViamVjdCIsImlzUGxhdGZvcm1Ccm93c2VyIiwidHNsaWJfMS5fX2Fzc2lnbiIsInRocm93RXJyb3IiLCJJbmplY3RhYmxlIiwiSW5qZWN0IiwiRE9DVU1FTlQiLCJQTEFURk9STV9JRCIsIkRpcmVjdGl2ZSIsIlJlbmRlcmVyMiIsIklucHV0IiwiTmdNb2R1bGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTs7O0FBZUEsSUFBTyxxQkFBTSxRQUFRLEdBQWlDO1FBQ3BELE1BQU0sRUFBRSxJQUFJO1FBQ1osTUFBTSxFQUFFLE9BQU87UUFDZixRQUFRLEVBQUUsR0FBRztRQUNiLE1BQU0sRUFBRSxlQUFlO1FBQ3ZCLE1BQU0sRUFBRSxDQUFDO1FBQ1QsU0FBUyxFQUFFLElBQUksR0FBRyxFQUFFO0tBQ3JCLENBQUM7Ozs7QUFLRixJQUFPLHFCQUFNLE1BQU0sR0FBc0M7UUFDdkQsVUFBVSxFQUFFLFVBQUMsSUFBWTtZQUN2QixPQUFPLElBQUksR0FBRyxJQUFJLENBQUM7U0FDcEI7UUFDRCxXQUFXLEVBQUUsVUFBQyxJQUFZO1lBQ3hCLE9BQU8sSUFBSSxJQUFJLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQztTQUMxQjtRQUNELGFBQWEsRUFBRSxVQUFDLElBQVk7WUFDMUIsT0FBTyxJQUFJLEdBQUcsR0FBRyxHQUFHLENBQUMsR0FBRyxJQUFJLEdBQUcsSUFBSSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsR0FBRyxJQUFJLElBQUksSUFBSSxD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