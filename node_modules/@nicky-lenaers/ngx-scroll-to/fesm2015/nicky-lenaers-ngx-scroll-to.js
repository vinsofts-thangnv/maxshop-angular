import { ElementRef, Injectable, PLATFORM_ID, Inject, Directive, Input, Renderer2, NgModule } from '@angular/core';
import { ReplaySubject, throwError } from 'rxjs/index';
import { DOCUMENT, isPlatformBrowser } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Default values for Component Input.
 */
const /** @type {?} */ DEFAULTS = {
    target: null,
    action: 'click',
    duration: 650,
    easing: 'easeInOutQuad',
    offset: 0,
    offsetMap: new Map()
};
/**
 * Easing Colleciton.
 */
const /** @type {?} */ EASING = {
    easeInQuad: (time) => {
        return time * time;
    },
    easeOutQuad: (time) => {
        return time * (2 - time);
    },
    easeInOutQuad: (time) => {
        return time < 0.5 ? 2 * time * time : -1 + (4 - 2 * time) * time;
    },
    easeInCubic: (time) => {
        return time * time * time;
    },
    easeOutCubic: (time) => {
        return (--time) * time * time + 1;
    },
    easeInOutCubic: (time) => {
        return time < 0.5 ? 4 * time * time * time : (time - 1) * (2 * time - 2) * (2 * time - 2) + 1;
    },
    easeInQuart: (time) => {
        return time * time * time * time;
    },
    easeOutQuart: (time) => {
        return 1 - (--time) * time * time * time;
    },
    easeInOutQuart: (time) => {
        return time < 0.5 ? 8 * time * time * time * time : 1 - 8 * (--time) * time * time * time;
    },
    easeInQuint: (time) => {
        return time * time * time * time * time;
    },
    easeOutQuint: (time) => {
        return 1 + (--time) * time * time * time * time;
    },
    easeInOutQuint: (time) => {
        return time < 0.5 ? 16 * time * time * time * time * time : 1 + 16 * (--time) * time * time * time * time;
    },
    easeOutElastic: (time) => {
        return Math.pow(2, -10 * time) * Math.sin((time - 1 / 4) * (2 * Math.PI) / 1) + 1;
    }
};
/**
 * Set of allowed events as triggers
 * for the Animation to start.
 */
const /** @type {?} */ EVENTS = [
    'click',
    'mouseenter',
    'mouseover',
    'mousedown',
    'mouseup',
    'dblclick',
    'contextmenu',
    'wheel',
    'mouseleave',
    'mouseout'
];
/**
 * Strip hash (#) from value.
 *
 * @param {?} value 				The given string value
 * @return {?} 					The stripped string value
 */
function stripHash(value) {
    return value.substring(0, 1) === '#' ? value.substring(1) : value;
}
/**
 * Test if a given value is a string.
 *
 * @param {?} value 					The given value
 * @return {?} 						Whether the given value is a string
 */
function isString(value) {
    return typeof value === 'string' || value instanceof String;
}
/**
 * Test if a given Element is the Window.
 *
 * @param {?} container 				The given Element
 * @return {?} 						Whether the given Element is Window
 */
function isWindow(container) {
    return container === window;
}
/**
 * Test if a given value is of type ElementRef.
 *
 * @param {?} value 					The given value
 * @return {?} Whether the given value is a number
 */
function isElementRef(value) {
    return value instanceof ElementRef;
}
/**
 * Whether or not the given value is a Native Element.
 *
 * @param {?} value           The given value
 * @return {?} Whether or not the value is a Native Element
 */
function isNativeElement(value) {
    return value instanceof HTMLElement;
}
/**
 * Test if a given value is type number.
 *
 * @param {?} value 					The given value
 * @return {?} 						Whether the given value is a number
 */
function isNumber(value) {
    return !isNaN(parseFloat(value)) && isFinite(value);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Scroll To Animation.
 */
class ScrollToAnimation {
    /**
     * Class Constructor.
     *
     * @param {?} _container            The Container
     * @param {?} _listenerTarget       The Element that listens for DOM Events
     * @param {?} _isWindow             Whether or not the listener is the Window
     * @param {?} _to                   Position to scroll to
     * @param {?} _options              Additional options for scrolling
     * @param {?} _isBrowser            Whether or not execution runs in the browser
     *                              (as opposed to the server)
     */
    constructor(_container, _listenerTarget, _isWindow, _to, _options, _isBrowser) {
        this._container = _container;
        this._listenerTarget = _listenerTarget;
        this._isWindow = _isWindow;
        this._to = _to;
        this._options = _options;
        this._isBrowser = _isBrowser;
        /**
         * Recursively loop over the Scroll Animation.
         *
         * @return Void
         */
        this._loop = () => {
            this._timeLapsed += this._tick;
            this._percentage = (this._timeLapsed / this._options.duration);
            this._percentage = (this._percentage > 1) ? 1 : this._percentage;
            // Position Update
            this._position = this._startPosition +
                ((this._startPosition - this._to <= 0 ? 1 : -1) *
                    this._distance *
                    EASING[this._options.easing](this._percentage));
            if (this._lastPosition !== null && this._position === this._lastPosition) {
                this.stop();
            }
            else {
                this._source$.next(this._position);
                this._isWindow
                    ? this._listenerTarget.scrollTo(0, Math.floor(this._position))
                    : this._container.scrollTop = Math.floor(this._position);
                this._lastPosition = this._position;
            }
        };
        this._tick = 16;
        this._interval = null;
        this._lastPosition = null;
        this._timeLapsed = 0;
        this._windowScrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
        if (!this._container) {
            this._startPosition = this._windowScrollTop;
        }
        else {
            this._startPosition = this._isWindow ? this._windowScrollTop : this._container.scrollTop;
        }
        // Correction for Starting Position of nested HTML Elements
        if (this._container && !this._isWindow) {
            this._to = this._to - this._container.getBoundingClientRect().top + this._startPosition;
        }
        // Set Distance
        const /** @type {?} */ directionalDistance = this._startPosition - this._to;
        this._distance = this._container ? Math.abs(this._startPosition - this._to) : this._to;
        this._mappedOffset = this._options.offset;
        // Set offset from Offset Map
        if (this._isBrowser) {
            this._options
                .offsetMap
                .forEach((value, key) => this._mappedOffset = window.innerWidth > key ? value : this._mappedOffset);
        }
        this._distance += this._mappedOffset * (directionalDistance <= 0 ? 1 : -1);
        this._source$ = new ReplaySubject();
    }
    /**
     * Start the new Scroll Animation.
     *
     * @return {?} Observable containing a number
     */
    start() {
        clearInterval(this._interval);
        this._interval = setInterval(this._loop, this._tick);
        return this._source$.asObservable();
    }
    /**
     * Stop the current Scroll Animation Loop.
     *
     * @return {?} Void
     */
    stop() {
        clearInterval(this._interval);
        this._interval = null;
        this._source$.complete();
    }
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * The ScrollToService handles starting, interrupting
 * and ending the actual Scroll Animation. It provides
 * some utilities to find the proper HTML Element on a
 * given page to setup Event Listeners and calculate
 * distances for the Animation.
 */
class ScrollToService {
    /**
     * Construct and setup required paratemeters.
     *
     * @param {?} _document         A Reference to the Document
     * @param {?} _platformId       Angular Platform ID
     */
    constructor(_document, _platformId) {
        this._document = _document;
        this._platformId = _platformId;
        this._interruptiveEvents = ['mousewheel', 'DOMMouseScroll', 'touchstart'];
    }
    /**
     * Target an Element to scroll to. Notice that the `TimeOut` decorator
     * ensures the executing to take place in the next Angular lifecycle.
     * This allows for scrolling to elements that are e.g. initially hidden
     * by means of `*ngIf`, but ought to be scrolled to eventually.
     *
     * \@todo type 'any' in Observable should become custom type like 'ScrollToEvent' (base class), see issue comment:
     * 	- https://github.com/nicky-lenaers/ngx-scroll-to/issues/10#issuecomment-317198481
     *
     * @param {?} options         Configuration Object
     * @return {?} Observable
     */
    scrollTo(options) {
        if (!isPlatformBrowser(this._platformId))
            return new ReplaySubject().asObservable();
        return this._start(options);
    }
    /**
     * Start a new Animation.
     *
     * \@todo Emit proper events from subscription
     *
     * @param {?} options         Configuration Object
     * @return {?} Observable
     */
    _start(options) {
        // Merge config with default values
        const /** @type {?} */ mergedConfigOptions = /** @type {?} */ (Object.assign({}, /** @type {?} */ (DEFAULTS), options));
        if (this._animation)
            this._animation.stop();
        const /** @type {?} */ targetNode = this._getNode(mergedConfigOptions.target);
        if (mergedConfigOptions.target && !targetNode)
            return throwError('Unable to find Target Element');
        const /** @type {?} */ container = this._getContainer(mergedConfigOptions, targetNode);
        if (mergedConfigOptions.container && !container)
            return throwError('Unable to find Container Element');
        const /** @type {?} */ listenerTarget = this._getListenerTarget(container) || window;
        let /** @type {?} */ to = container ? container.getBoundingClientRect().top : 0;
        if (targetNode) {
            to = isWindow(listenerTarget) ? targetNode.offsetTop : targetNode.getBoundingClientRect().top;
        }
        // Create Animation
        this._animation = new ScrollToAnimation(container, listenerTarget, isWindow(listenerTarget), to, mergedConfigOptions, isPlatformBrowser(this._platformId));
        const /** @type {?} */ onInterrupt = () => this._animation.stop();
        this._addInterruptiveEventListeners(listenerTarget, onInterrupt);
        // Start Animation
        const /** @type {?} */ animation$ = this._animation.start();
        this._subscribeToAnimation(animation$, listenerTarget, onInterrupt);
        return animation$;
    }
    /**
     * Subscribe to the events emitted from the Scrolling
     * Animation. Events might be used for e.g. unsubscribing
     * once finished.
     *
     * @param {?} animation$              The Animation Observable
     * @param {?} listenerTarget          The Listener Target for events
     * @param {?} onInterrupt             The handler for Interruptive Events
     * @return {?} Void
     */
    _subscribeToAnimation(animation$, listenerTarget, onInterrupt) {
        const /** @type {?} */ subscription = animation$
            .subscribe(() => { }, () => { }, () => {
            this._removeInterruptiveEventListeners(this._interruptiveEvents, listenerTarget, onInterrupt);
            subscription.unsubscribe();
        });
    }
    /**
     * Get the container HTML Element in which
     * the scrolling should happen.
     *
     * @param {?} options         The Merged Configuration Object
     * @param {?} targetNode    the targeted HTMLElement
     * @return {?}
     */
    _getContainer(options, targetNode) {
        let /** @type {?} */ container = null;
        if (options.container) {
            container = this._getNode(options.container, true);
        }
        else if (targetNode) {
            container = this._getFirstScrollableParent(targetNode);
        }
        return container;
    }
    /**
     * Add listeners for the Animation Interruptive Events
     * to the Listener Target.
     *
     * @param {?} listenerTarget    Target to attach the listener on
     * @param {?} handler           Handler for when the listener fires
     * @return {?} Void
     */
    _addInterruptiveEventListeners(listenerTarget, handler) {
        if (!listenerTarget)
            listenerTarget = window;
        this._interruptiveEvents.forEach(event => listenerTarget.addEventListener(event, handler));
    }
    /**
     * Remove listeners for the Animation Interrupt Event from
     * the Listener Target. Specifying the correct handler prevents
     * memory leaks and makes the allocated memory available for
     * Garbage Collection.
     *
     * @param {?} events            List of Interruptive Events to remove
     * @param {?} listenerTarget    Target to attach the listener on
     * @param {?} handler           Handler for when the listener fires
     * @return {?} Void
     */
    _removeInterruptiveEventListeners(events, listenerTarget, handler) {
        if (!listenerTarget)
            listenerTarget = window;
        events.forEach(event => listenerTarget.removeEventListener(event, handler));
    }
    /**
     * Find the first scrollable parent Node of a given
     * Element. The DOM Tree gets searched upwards
     * to find this first scrollable parent. Parents might
     * be ignored by CSS styles applied to the HTML Element.
     *
     * @param {?} nativeElement     The Element to search the DOM Tree upwards from
     * @return {?} The first scrollable parent HTML Element
     */
    _getFirstScrollableParent(nativeElement) {
        let /** @type {?} */ style = window.getComputedStyle(nativeElement);
        const /** @type {?} */ overflowRegex = /(auto|scroll)/;
        if (style.position === 'fixed')
            return null;
        for (let /** @type {?} */ parent = nativeElement; parent = parent.parentElement; null) {
            style = window.getComputedStyle(parent);
            if (style.position === 'absolute'
                || style.overflow === 'hidden'
                || style.overflowY === 'hidden')
                continue;
            if (overflowRegex.test(style.overflow + style.overflowY + style.overflowX)
                || parent.tagName === 'BODY')
                return parent;
        }
        return null;
    }
    /**
     * Get the Target Node to scroll to.
     *
     * @param {?} id              The given ID of the node, either a string or
     *                        an element reference
     * @param {?=} allowBodyTag    Indicate whether or not the Document Body is
     *                        considered a valid Target Node
     * @return {?} The Target Node to scroll to
     */
    _getNode(id, allowBodyTag = false) {
        let /** @type {?} */ targetNode;
        if (isString(id)) {
            if (allowBodyTag && (id === 'body' || id === 'BODY')) {
                targetNode = this._document.body;
            }
            else {
                targetNode = this._document.getElementById(stripHash(id));
            }
        }
        else if (isNumber(id)) {
            targetNode = this._document.getElementById(String(id));
        }
        else if (isElementRef(id)) {
            targetNode = id.nativeElement;
        }
        else if (isNativeElement(id)) {
            targetNode = id;
        }
        return targetNode;
    }
    /**
     * Retrieve the Listener target. This Listener Target is used
     * to attach Event Listeners on. In case of the target being
     * the Document Body, we need the actual `window` to listen
     * for events.
     *
     * @param {?} container           The HTML Container element
     * @return {?} The Listener Target to attach events on
     */
    _getListenerTarget(container) {
        if (!container)
            return null;
        return this._isDocumentBody(container) ? window : container;
    }
    /**
     * Test if a given HTML Element is the Document Body.
     *
     * @param {?} element             The given HTML Element
     * @return {?} Whether or not the Element is the
     *                            Document Body Element
     */
    _isDocumentBody(element) {
        return element.tagName.toUpperCase() === 'BODY';
    }
}
ScrollToService.decorators = [
    { type: Injectable },
];
/** @nocollapse */
ScrollToService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class ScrollToDirective {
    /**
     * @param {?} _elementRef
     * @param {?} _scrollToService
     * @param {?} _renderer2
     */
    constructor(_elementRef, _scrollToService, _renderer2) {
        this._elementRef = _elementRef;
        this._scrollToService = _scrollToService;
        this._renderer2 = _renderer2;
        this.ngxScrollTo = DEFAULTS.target;
        this.ngxScrollToEvent = DEFAULTS.action;
        this.ngxScrollToDuration = DEFAULTS.duration;
        this.ngxScrollToEasing = DEFAULTS.easing;
        this.ngxScrollToOffset = DEFAULTS.offset;
        this.ngxScrollToOffsetMap = DEFAULTS.offsetMap;
    }
    /**
     * Angular Lifecycle Hook - After View Init
     *
     * \@todo Implement Subscription for Events
     *
     * @return {?} void
     */
    ngAfterViewInit() {
        // Test Event Support
        if (EVENTS.indexOf(this.ngxScrollToEvent) === -1)
            throw new Error(`Unsupported Event '${this.ngxScrollToEvent}'`);
        // Listen for the trigger...
        this._renderer2.listen(this._elementRef.nativeElement, this.ngxScrollToEvent, (event) => {
            this._options = {
                target: this.ngxScrollTo,
                duration: this.ngxScrollToDuration,
                easing: this.ngxScrollToEasing,
                offset: this.ngxScrollToOffset,
                offsetMap: this.ngxScrollToOffsetMap
            };
            this._scrollToService.scrollTo(this._options);
        });
    }
}
ScrollToDirective.decorators = [
    { type: Directive, args: [{
                selector: '[ngx-scroll-to]'
            },] },
];
/** @nocollapse */
ScrollToDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ScrollToService },
    { type: Renderer2 }
];
ScrollToDirective.propDecorators = {
    ngxScrollTo: [{ type: Input, args: ['ngx-scroll-to',] }],
    ngxScrollToEvent: [{ type: Input, args: ['ngx-scroll-to-event',] }],
    ngxScrollToDuration: [{ type: Input, args: ['ngx-scroll-to-duration',] }],
    ngxScrollToEasing: [{ type: Input, args: ['ngx-scroll-to-easing',] }],
    ngxScrollToOffset: [{ type: Input, args: ['ngx-scroll-to-offset',] }],
    ngxScrollToOffsetMap: [{ type: Input, args: ['ngx-scroll-to-offset-map',] }]
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class ScrollToModule {
    /**
     * Guaranteed singletons for provided Services across App.
     *
     * @return {?} An Angular Module with Providers
     */
    static forRoot() {
        return {
            ngModule: ScrollToModule,
            providers: [
                ScrollToService
            ]
        };
    }
}
ScrollToModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    ScrollToDirective
                ],
                exports: [
                    ScrollToDirective
                ]
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

export { ScrollToModule, ScrollToService, ScrollToDirective as ɵa };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmlja3ktbGVuYWVycy1uZ3gtc2Nyb2xsLXRvLmpzLm1hcCIsInNvdXJjZXMiOlsibmc6Ly9Abmlja3ktbGVuYWVycy9uZ3gtc2Nyb2xsLXRvL3NyYy9hcHAvbW9kdWxlcy9zY3JvbGwtdG8vc3RhdGljcy9zY3JvbGwtdG8taGVscGVycy50cyIsIm5nOi8vQG5pY2t5LWxlbmFlcnMvbmd4LXNjcm9sbC10by9zcmMvYXBwL21vZHVsZXMvc2Nyb2xsLXRvL3N0YXRpY3Mvc2Nyb2xsLXRvLWFuaW1hdGlvbi50cyIsIm5nOi8vQG5pY2t5LWxlbmFlcnMvbmd4LXNjcm9sbC10by9zcmMvYXBwL21vZHVsZXMvc2Nyb2xsLXRvL3Njcm9sbC10by5zZXJ2aWNlLnRzIiwibmc6Ly9Abmlja3ktbGVuYWVycy9uZ3gtc2Nyb2xsLXRvL3NyYy9hcHAvbW9kdWxlcy9zY3JvbGwtdG8vc2Nyb2xsLXRvLmRpcmVjdGl2ZS50cyIsIm5nOi8vQG5pY2t5LWxlbmFlcnMvbmd4LXNjcm9sbC10by9zcmMvYXBwL21vZHVsZXMvc2Nyb2xsLXRvL3Njcm9sbC10by5tb2R1bGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRWxlbWVudFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuaW1wb3J0IHtcclxuICBTY3JvbGxUb0FuaW1hdGlvbkVhc2luZyxcclxuICBTY3JvbGxUb0FuaW1hdGlvbkVhc2luZ0NvbGxlY3Rpb25cclxufSBmcm9tICcuLi9tb2RlbHMvc2Nyb2xsLXRvLWVhc2luZy5tb2RlbCc7XHJcbmltcG9ydCB7IFNjcm9sbFRvRXZlbnQgfSBmcm9tICcuLi9tb2RlbHMvc2Nyb2xsLXRvLWV2ZW50Lm1vZGVsJztcclxuaW1wb3J0IHtcclxuICBTY3JvbGxUb0NvbmZpZ09wdGlvbnMsXHJcbiAgU2Nyb2xsVG9EZWZhdWx0Q29uZmlnT3B0aW9uc1xyXG59IGZyb20gJy4uL21vZGVscy9zY3JvbGwtdG8tY29uZmlnLm1vZGVsJztcclxuXHJcbi8qKlxyXG4gKiBEZWZhdWx0IHZhbHVlcyBmb3IgQ29tcG9uZW50IElucHV0LlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IERFRkFVTFRTOiBTY3JvbGxUb0RlZmF1bHRDb25maWdPcHRpb25zID0ge1xyXG4gIHRhcmdldDogbnVsbCxcclxuICBhY3Rpb246ICdjbGljaycsXHJcbiAgZHVyYXRpb246IDY1MCxcclxuICBlYXNpbmc6ICdlYXNlSW5PdXRRdWFkJyxcclxuICBvZmZzZXQ6IDAsXHJcbiAgb2Zmc2V0TWFwOiBuZXcgTWFwKClcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFYXNpbmcgQ29sbGVjaXRvbi5cclxuICovXHJcbmV4cG9ydCBjb25zdCBFQVNJTkc6IFNjcm9sbFRvQW5pbWF0aW9uRWFzaW5nQ29sbGVjdGlvbiA9IHtcclxuICBlYXNlSW5RdWFkOiAodGltZTogbnVtYmVyKSA9PiB7XHJcbiAgICByZXR1cm4gdGltZSAqIHRpbWU7XHJcbiAgfSxcclxuICBlYXNlT3V0UXVhZDogKHRpbWU6IG51bWJlcikgPT4ge1xyXG4gICAgcmV0dXJuIHRpbWUgKiAoMiAtIHRpbWUpO1xyXG4gIH0sXHJcbiAgZWFzZUluT3V0UXVhZDogKHRpbWU6IG51bWJlcikgPT4ge1xyXG4gICAgcmV0dXJuIHRpbWUgPCAwLjUgPyAyICogdGltZSAqIHRpbWUgOiAtMSArICg0IC0gMiAqIHRpbWUpICogdGltZTtcclxuICB9LFxyXG4gIGVhc2VJbkN1YmljOiAodGltZTogbnVtYmVyKSA9PiB7XHJcbiAgICByZXR1cm4gdGltZSAqIHRpbWUgKiB0aW1lO1xyXG4gIH0sXHJcbiAgZWFzZU91dEN1YmljOiAodGltZTogbnVtYmVyKSA9PiB7XHJcbiAgICByZXR1cm4gKC0tdGltZSkgKiB0aW1lICogdGltZSArIDE7XHJcbiAgfSxcclxuICBlYXNlSW5PdXRDdWJpYzogKHRpbWU6IG51bWJlcikgPT4ge1xyXG4gICAgcmV0dXJuIHRpbWUgPCAwLjUgPyA0ICogdGltZSAqIHRpbWUgKiB0aW1lIDogKHRpbWUgLSAxKSAqICgyICogdGltZSAtIDIpICogKDIgKiB0aW1lIC0gMikgKyAxO1xyXG4gIH0sXHJcbiAgZWFzZUluUXVhcnQ6ICh0aW1lOiBudW1iZXIpID0+IHtcclxuICAgIHJldHVybiB0aW1lICogdGltZSAqIHRpbWUgKiB0aW1lO1xyXG4gIH0sXHJcbiAgZWFzZU91dFF1YXJ0OiAodGltZTogbnVtYmVyKSA9PiB7XHJcbiAgICByZXR1cm4gMSAtICgtLXRpbWUpICogdGltZSAqIHRpbWUgKiB0aW1lO1xyXG4gIH0sXHJcbiAgZWFzZUluT3V0UXVhcnQ6ICh0aW1lOiBudW1iZXIpID0+IHtcclxuICAgIHJldHVybiB0aW1lIDwgMC41ID8gOCAqIHRpbWUgKiB0aW1lICogdGltZSAqIHRpbWUgOiAxIC0gOCAqICgtLXRpbWUpICogdGltZSAqIHRpbWUgKiB0aW1lO1xyXG4gIH0sXHJcbiAgZWFzZUluUXVpbnQ6ICh0aW1lOiBudW1iZXIpID0+IHtcclxuICAgIHJldHVybiB0aW1lICogdGltZSAqIHRpbWUgKiB0aW1lICogdGltZTtcclxuICB9LFxyXG4gIGVhc2VPdXRRdWludDogKHRpbWU6IG51bWJlcikgPT4ge1xyXG4gICAgcmV0dXJuIDEgKyAoLS10aW1lKSAqIHRpbWUgKiB0aW1lICogdGltZSAqIHRpbWU7XHJcbiAgfSxcclxuICBlYXNlSW5PdXRRdWludDogKHRpbWU6IG51bWJlcikgPT4ge1xyXG4gICAgcmV0dXJuIHRpbWUgPCAwLjUgPyAxNiAqIHRpbWUgKiB0aW1lICogdGltZSAqIHRpbWUgKiB0aW1lIDogMSArIDE2ICogKC0tdGltZSkgKiB0aW1lICogdGltZSAqIHRpbWUgKiB0aW1lO1xyXG4gIH0sXHJcbiAgZWFzZU91dEVsYXN0aWM6ICh0aW1lOiBudW1iZXIpID0+IHtcclxuICAgIHJldHVybiBNYXRoLnBvdygyLCAtMTAgKiB0aW1lKSAqIE1hdGguc2luKCh0aW1lIC0gMSAvIDQpICogKDIgKiBNYXRoLlBJKSAvIDEpICsgMTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogU2V0IG9mIGFsbG93ZWQgZXZlbnRzIGFzIHRyaWdnZXJzXHJcbiAqIGZvciB0aGUgQW5pbWF0aW9uIHRvIHN0YXJ0LlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IEVWRU5UUzogc3RyaW5nW10gPSBbXHJcbiAgJ2NsaWNrJyxcclxuICAnbW91c2VlbnRlcicsXHJcbiAgJ21vdXNlb3ZlcicsXHJcbiAgJ21vdXNlZG93bicsXHJcbiAgJ21vdXNldXAnLFxyXG4gICdkYmxjbGljaycsXHJcbiAgJ2NvbnRleHRtZW51JyxcclxuICAnd2hlZWwnLFxyXG4gICdtb3VzZWxlYXZlJyxcclxuICAnbW91c2VvdXQnXHJcbl07XHJcblxyXG4vKipcclxuICogU3RyaXAgaGFzaCAoIykgZnJvbSB2YWx1ZS5cclxuICpcclxuICogQHBhcmFtIHZhbHVlIFx0XHRcdFx0VGhlIGdpdmVuIHN0cmluZyB2YWx1ZVxyXG4gKiBAcmV0dXJucyBcdFx0XHRcdFx0VGhlIHN0cmlwcGVkIHN0cmluZyB2YWx1ZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHN0cmlwSGFzaCh2YWx1ZTogc3RyaW5nKTogc3RyaW5nIHtcclxuICByZXR1cm4gdmFsdWUuc3Vic3RyaW5nKDAsIDEpID09PSAnIycgPyB2YWx1ZS5zdWJzdHJpbmcoMSkgOiB2YWx1ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRlc3QgaWYgYSBnaXZlbiB2YWx1ZSBpcyBhIHN0cmluZy5cclxuICpcclxuICogQHBhcmFtIHZhbHVlIFx0XHRcdFx0XHRUaGUgZ2l2ZW4gdmFsdWVcclxuICogQHJldHVybnMgXHRcdFx0XHRcdFx0V2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBzdHJpbmdcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZTogYW55KTogdmFsdWUgaXMgc3RyaW5nIHtcclxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZztcclxufVxyXG5cclxuLyoqXHJcbiAqIFRlc3QgaWYgYSBnaXZlbiBFbGVtZW50IGlzIHRoZSBXaW5kb3cuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb250YWluZXIgXHRcdFx0XHRUaGUgZ2l2ZW4gRWxlbWVudFxyXG4gKiBAcmV0dXJucyBcdFx0XHRcdFx0XHRXaGV0aGVyIHRoZSBnaXZlbiBFbGVtZW50IGlzIFdpbmRvd1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzV2luZG93KGNvbnRhaW5lcjogYW55KTogY29udGFpbmVyIGlzIFdpbmRvdyB7XHJcbiAgcmV0dXJuIGNvbnRhaW5lciA9PT0gd2luZG93O1xyXG59XHJcblxyXG4vKipcclxuICogVGVzdCBpZiBhIGdpdmVuIHZhbHVlIGlzIG9mIHR5cGUgRWxlbWVudFJlZi5cclxuICpcclxuICogQHBhcmFtIHZhbHVlIFx0XHRcdFx0XHRUaGUgZ2l2ZW4gdmFsdWVcclxuICogQHJldHVybnMgICAgICAgICAgICAgICBXaGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIG51bWJlclxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRWxlbWVudFJlZih2YWx1ZTogYW55KTogdmFsdWUgaXMgRWxlbWVudFJlZiB7XHJcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRWxlbWVudFJlZjtcclxufVxyXG5cclxuLyoqXHJcbiAqIFdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIE5hdGl2ZSBFbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWUgICAgICAgICAgIFRoZSBnaXZlbiB2YWx1ZVxyXG4gKiBAcmV0dXJucyAgICAgICAgICAgICAgIFdoZXRoZXIgb3Igbm90IHRoZSB2YWx1ZSBpcyBhIE5hdGl2ZSBFbGVtZW50XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNOYXRpdmVFbGVtZW50KHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBIVE1MRWxlbWVudCB7XHJcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUZXN0IGlmIGEgZ2l2ZW4gdmFsdWUgaXMgdHlwZSBudW1iZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSBcdFx0XHRcdFx0VGhlIGdpdmVuIHZhbHVlXHJcbiAqIEByZXR1cm5zIFx0XHRcdFx0XHRcdFdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgbnVtYmVyXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXIodmFsdWU6IGFueSk6IHZhbHVlIGlzIG51bWJlciB7XHJcbiAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KHZhbHVlKSkgJiYgaXNGaW5pdGUodmFsdWUpO1xyXG59XHJcbiIsImltcG9ydCB7IE9ic2VydmFibGUsIFJlcGxheVN1YmplY3QgfSBmcm9tICdyeGpzL2luZGV4JztcclxuXHJcbmltcG9ydCB7IEVBU0lORyB9IGZyb20gJy4uL3N0YXRpY3Mvc2Nyb2xsLXRvLWhlbHBlcnMnO1xyXG5pbXBvcnQge1xyXG4gIFNjcm9sbFRvQ29uZmlnT3B0aW9ucyxcclxuICBTY3JvbGxUb0xpc3RlbmVyVGFyZ2V0XHJcbn0gZnJvbSAnLi4vbW9kZWxzL3Njcm9sbC10by1jb25maWcubW9kZWwnO1xyXG5cclxuLyoqXHJcbiAqIFNjcm9sbCBUbyBBbmltYXRpb24uXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgU2Nyb2xsVG9BbmltYXRpb24ge1xyXG5cclxuICAvKipcclxuICAgKiBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIGZvciBlYWNoIFRpY2suXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfdGljazogbnVtYmVyO1xyXG5cclxuICAvKipcclxuICAgKiBKYXZhU2NyaXB0IEludGVydmFsLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgX2ludGVydmFsOiBhbnk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRpbWUgTGFwc2VkIGluIG1pbGxpc2Vjb25kcy5cclxuICAgKi9cclxuICBwcml2YXRlIF90aW1lTGFwc2VkOiBudW1iZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIFBlcmNlbnRhZ2Ugb2YgdGltZSBsYXBzZWQuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfcGVyY2VudGFnZTogbnVtYmVyO1xyXG5cclxuICAvKipcclxuICAgKiBQb3NpdGlvbiBvZiB0aGUgRWxlbWVudC5cclxuICAgKi9cclxuICBwcml2YXRlIF9wb3NpdGlvbjogbnVtYmVyO1xyXG5cclxuICAvKipcclxuICAgKiBMYXN0IFBvc2l0aW9uLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgX2xhc3RQb3NpdGlvbjogbnVtYmVyO1xyXG5cclxuICAvKipcclxuICAgKiBTdGFydCBQb3NpdGlvbiBvZiB0aGUgRWxlbWVudC5cclxuICAgKi9cclxuICBwcml2YXRlIF9zdGFydFBvc2l0aW9uOiBudW1iZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBEaXN0YW5jZSB0byBzY3JvbGwuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfZGlzdGFuY2U6IG51bWJlcjtcclxuXHJcbiAgLyoqXHJcbiAgICogT2JzZXJ2YWJsZSBTb3VyY2UuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfc291cmNlJDogUmVwbGF5U3ViamVjdDxudW1iZXI+O1xyXG5cclxuICAvKipcclxuICAgKiBTY3JvbGwgVG9wIG9mIHRoZSBXaW5kb3cuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfd2luZG93U2Nyb2xsVG9wOiBudW1iZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIE1hcHBlZCBPZmZzZXQgdGFrZW4gZnJvbSB0aGUgYWN0aXZlIE9mZnNldCBNYXAuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfbWFwcGVkT2Zmc2V0OiBudW1iZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIENsYXNzIENvbnN0cnVjdG9yLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIF9jb250YWluZXIgICAgICAgICAgICBUaGUgQ29udGFpbmVyXHJcbiAgICogQHBhcmFtIF9saXN0ZW5lclRhcmdldCAgICAgICBUaGUgRWxlbWVudCB0aGF0IGxpc3RlbnMgZm9yIERPTSBFdmVudHNcclxuICAgKiBAcGFyYW0gX2lzV2luZG93ICAgICAgICAgICAgIFdoZXRoZXIgb3Igbm90IHRoZSBsaXN0ZW5lciBpcyB0aGUgV2luZG93XHJcbiAgICogQHBhcmFtIF90byAgICAgICAgICAgICAgICAgICBQb3NpdGlvbiB0byBzY3JvbGwgdG9cclxuICAgKiBAcGFyYW0gX29wdGlvbnMgICAgICAgICAgICAgIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3Igc2Nyb2xsaW5nXHJcbiAgICogQHBhcmFtIF9pc0Jyb3dzZXIgICAgICAgICAgICBXaGV0aGVyIG9yIG5vdCBleGVjdXRpb24gcnVucyBpbiB0aGUgYnJvd3NlclxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGFzIG9wcG9zZWQgdG8gdGhlIHNlcnZlcilcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHByaXZhdGUgX2NvbnRhaW5lcjogSFRNTEVsZW1lbnQsXHJcbiAgICBwcml2YXRlIF9saXN0ZW5lclRhcmdldDogU2Nyb2xsVG9MaXN0ZW5lclRhcmdldCxcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgX2lzV2luZG93OiBib29sZWFuLFxyXG4gICAgcHJpdmF0ZSByZWFkb25seSBfdG86IG51bWJlcixcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgX29wdGlvbnM6IFNjcm9sbFRvQ29uZmlnT3B0aW9ucyxcclxuICAgIHByaXZhdGUgX2lzQnJvd3NlcjogYm9vbGVhblxyXG4gICkge1xyXG4gICAgdGhpcy5fdGljayA9IDE2O1xyXG4gICAgdGhpcy5faW50ZXJ2YWwgPSBudWxsO1xyXG4gICAgdGhpcy5fbGFzdFBvc2l0aW9uID0gbnVsbDtcclxuICAgIHRoaXMuX3RpbWVMYXBzZWQgPSAwO1xyXG5cclxuICAgIHRoaXMuX3dpbmRvd1Njcm9sbFRvcCA9IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wIHx8IDA7XHJcblxyXG4gICAgaWYgKCF0aGlzLl9jb250YWluZXIpIHtcclxuICAgICAgdGhpcy5fc3RhcnRQb3NpdGlvbiA9IHRoaXMuX3dpbmRvd1Njcm9sbFRvcDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX3N0YXJ0UG9zaXRpb24gPSB0aGlzLl9pc1dpbmRvdyA/IHRoaXMuX3dpbmRvd1Njcm9sbFRvcCA6IHRoaXMuX2NvbnRhaW5lci5zY3JvbGxUb3A7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29ycmVjdGlvbiBmb3IgU3RhcnRpbmcgUG9zaXRpb24gb2YgbmVzdGVkIEhUTUwgRWxlbWVudHNcclxuICAgIGlmICh0aGlzLl9jb250YWluZXIgJiYgIXRoaXMuX2lzV2luZG93KSB7XHJcbiAgICAgIHRoaXMuX3RvID0gdGhpcy5fdG8gLSB0aGlzLl9jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgdGhpcy5fc3RhcnRQb3NpdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTZXQgRGlzdGFuY2VcclxuICAgIGNvbnN0IGRpcmVjdGlvbmFsRGlzdGFuY2UgPSB0aGlzLl9zdGFydFBvc2l0aW9uIC0gdGhpcy5fdG87XHJcbiAgICB0aGlzLl9kaXN0YW5jZSA9IHRoaXMuX2NvbnRhaW5lciA/IE1hdGguYWJzKHRoaXMuX3N0YXJ0UG9zaXRpb24gLSB0aGlzLl90bykgOiB0aGlzLl90bztcclxuXHJcbiAgICB0aGlzLl9tYXBwZWRPZmZzZXQgPSB0aGlzLl9vcHRpb25zLm9mZnNldDtcclxuXHJcbiAgICAvLyBTZXQgb2Zmc2V0IGZyb20gT2Zmc2V0IE1hcFxyXG4gICAgaWYgKHRoaXMuX2lzQnJvd3Nlcikge1xyXG4gICAgICB0aGlzLl9vcHRpb25zXHJcbiAgICAgICAgLm9mZnNldE1hcFxyXG4gICAgICAgIC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB0aGlzLl9tYXBwZWRPZmZzZXQgPSB3aW5kb3cuaW5uZXJXaWR0aCA+IGtleSA/IHZhbHVlIDogdGhpcy5fbWFwcGVkT2Zmc2V0KTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9kaXN0YW5jZSArPSB0aGlzLl9tYXBwZWRPZmZzZXQgKiAoZGlyZWN0aW9uYWxEaXN0YW5jZSA8PSAwID8gMSA6IC0xKTtcclxuICAgIHRoaXMuX3NvdXJjZSQgPSBuZXcgUmVwbGF5U3ViamVjdCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RhcnQgdGhlIG5ldyBTY3JvbGwgQW5pbWF0aW9uLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMgICAgICAgICBPYnNlcnZhYmxlIGNvbnRhaW5pbmcgYSBudW1iZXJcclxuICAgKi9cclxuICBwdWJsaWMgc3RhcnQoKTogT2JzZXJ2YWJsZTxudW1iZXI+IHtcclxuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpO1xyXG4gICAgdGhpcy5faW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCh0aGlzLl9sb29wLCB0aGlzLl90aWNrKTtcclxuICAgIHJldHVybiB0aGlzLl9zb3VyY2UkLmFzT2JzZXJ2YWJsZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVjdXJzaXZlbHkgbG9vcCBvdmVyIHRoZSBTY3JvbGwgQW5pbWF0aW9uLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMgICAgICAgICAgIFZvaWRcclxuICAgKi9cclxuICBwcml2YXRlIF9sb29wID0gKCk6IHZvaWQgPT4ge1xyXG5cclxuICAgIHRoaXMuX3RpbWVMYXBzZWQgKz0gdGhpcy5fdGljaztcclxuICAgIHRoaXMuX3BlcmNlbnRhZ2UgPSAodGhpcy5fdGltZUxhcHNlZCAvIHRoaXMuX29wdGlvbnMuZHVyYXRpb24pO1xyXG4gICAgdGhpcy5fcGVyY2VudGFnZSA9ICh0aGlzLl9wZXJjZW50YWdlID4gMSkgPyAxIDogdGhpcy5fcGVyY2VudGFnZTtcclxuXHJcbiAgICAvLyBQb3NpdGlvbiBVcGRhdGVcclxuICAgIHRoaXMuX3Bvc2l0aW9uID0gdGhpcy5fc3RhcnRQb3NpdGlvbiArXHJcbiAgICAgICgodGhpcy5fc3RhcnRQb3NpdGlvbiAtIHRoaXMuX3RvIDw9IDAgPyAxIDogLTEpICpcclxuICAgICAgICB0aGlzLl9kaXN0YW5jZSAqXHJcbiAgICAgICAgRUFTSU5HW3RoaXMuX29wdGlvbnMuZWFzaW5nXSh0aGlzLl9wZXJjZW50YWdlKSk7XHJcblxyXG4gICAgaWYgKHRoaXMuX2xhc3RQb3NpdGlvbiAhPT0gbnVsbCAmJiB0aGlzLl9wb3NpdGlvbiA9PT0gdGhpcy5fbGFzdFBvc2l0aW9uKSB7XHJcbiAgICAgIHRoaXMuc3RvcCgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5fc291cmNlJC5uZXh0KHRoaXMuX3Bvc2l0aW9uKTtcclxuICAgICAgdGhpcy5faXNXaW5kb3dcclxuICAgICAgICA/IHRoaXMuX2xpc3RlbmVyVGFyZ2V0LnNjcm9sbFRvKDAsIE1hdGguZmxvb3IodGhpcy5fcG9zaXRpb24pKVxyXG4gICAgICAgIDogdGhpcy5fY29udGFpbmVyLnNjcm9sbFRvcCA9IE1hdGguZmxvb3IodGhpcy5fcG9zaXRpb24pO1xyXG4gICAgICB0aGlzLl9sYXN0UG9zaXRpb24gPSB0aGlzLl9wb3NpdGlvbjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0b3AgdGhlIGN1cnJlbnQgU2Nyb2xsIEFuaW1hdGlvbiBMb29wLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGZvcmNlIFx0XHRcdCAgICBGb3JjZSB0byBzdG9wIHRoZSBBbmltYXRpb24gTG9vcFxyXG4gICAqIEByZXR1cm5zICAgICAgICAgICAgICAgVm9pZFxyXG4gICAqL1xyXG4gIHB1YmxpYyBzdG9wKCk6IHZvaWQge1xyXG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbCk7XHJcbiAgICB0aGlzLl9pbnRlcnZhbCA9IG51bGw7XHJcbiAgICB0aGlzLl9zb3VyY2UkLmNvbXBsZXRlKCk7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7IEluamVjdGFibGUsIFBMQVRGT1JNX0lELCBJbmplY3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgRE9DVU1FTlQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5pbXBvcnQgeyBpc1BsYXRmb3JtQnJvd3NlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcblxyXG5pbXBvcnQge1xyXG4gIFNjcm9sbFRvQ29uZmlnT3B0aW9ucyxcclxuICBTY3JvbGxUb1RhcmdldCxcclxuICBTY3JvbGxUb0xpc3RlbmVyVGFyZ2V0LFxyXG4gIFNjcm9sbFRvQ29uZmlnT3B0aW9uc1RhcmdldFxyXG59IGZyb20gJy4vbW9kZWxzL3Njcm9sbC10by1jb25maWcubW9kZWwnO1xyXG5pbXBvcnQgeyBTY3JvbGxUb0FuaW1hdGlvbiB9IGZyb20gJy4vc3RhdGljcy9zY3JvbGwtdG8tYW5pbWF0aW9uJztcclxuaW1wb3J0IHtcclxuICBzdHJpcEhhc2gsXHJcbiAgaXNTdHJpbmcsXHJcbiAgaXNOdW1iZXIsXHJcbiAgaXNFbGVtZW50UmVmLFxyXG4gIGlzV2luZG93LFxyXG4gIERFRkFVTFRTLFxyXG4gIGlzTmF0aXZlRWxlbWVudFxyXG59IGZyb20gJy4vc3RhdGljcy9zY3JvbGwtdG8taGVscGVycyc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUsIFJlcGxheVN1YmplY3QsIHRocm93RXJyb3IgfSBmcm9tICdyeGpzL2luZGV4JztcclxuXHJcbi8qKlxyXG4gKiBUaGUgU2Nyb2xsVG9TZXJ2aWNlIGhhbmRsZXMgc3RhcnRpbmcsIGludGVycnVwdGluZ1xyXG4gKiBhbmQgZW5kaW5nIHRoZSBhY3R1YWwgU2Nyb2xsIEFuaW1hdGlvbi4gSXQgcHJvdmlkZXNcclxuICogc29tZSB1dGlsaXRpZXMgdG8gZmluZCB0aGUgcHJvcGVyIEhUTUwgRWxlbWVudCBvbiBhXHJcbiAqIGdpdmVuIHBhZ2UgdG8gc2V0dXAgRXZlbnQgTGlzdGVuZXJzIGFuZCBjYWxjdWxhdGVcclxuICogZGlzdGFuY2VzIGZvciB0aGUgQW5pbWF0aW9uLlxyXG4gKi9cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgU2Nyb2xsVG9TZXJ2aWNlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGFuaW1hdGlvbiB0aGF0IHByb3ZpZGVzIHRoZSBzY3JvbGxpbmdcclxuICAgKiB0byBoYXBwZW4gc21vb3RobHkgb3ZlciB0aW1lLiBEZWZpbmluZyBpdCBoZXJlXHJcbiAgICogYWxsb3dzIGZvciB1c2FnZSBvZiBlLmcuIGBzdGFydGAgYW5kIGBzdG9wYFxyXG4gICAqIG1ldGhvZHMgd2l0aGluIHRoaXMgQW5ndWxhciBTZXJ2aWNlLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgX2FuaW1hdGlvbjogU2Nyb2xsVG9BbmltYXRpb247XHJcblxyXG4gIC8qKlxyXG4gICAqIEludGVycnVwdGl2ZSBFdmVudHMgYWxsb3cgdG8gc2Nyb2xsaW5nIGFuaW1hdGlvblxyXG4gICAqIHRvIGJlIGludGVycnVwdGVkIGJlZm9yZSBpdCBpcyBmaW5pc2hlZC4gVGhlIGxpc3RcclxuICAgKiBvZiBJbnRlcnJ1cHRpdmUgRXZlbnRzIHJlcHJlc2VudHMgdGhvc2UuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfaW50ZXJydXB0aXZlRXZlbnRzOiBzdHJpbmdbXTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3RydWN0IGFuZCBzZXR1cCByZXF1aXJlZCBwYXJhdGVtZXRlcnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gX2RvY3VtZW50ICAgICAgICAgQSBSZWZlcmVuY2UgdG8gdGhlIERvY3VtZW50XHJcbiAgICogQHBhcmFtIF9wbGF0Zm9ybUlkICAgICAgIEFuZ3VsYXIgUGxhdGZvcm0gSURcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIEBJbmplY3QoRE9DVU1FTlQpIHByaXZhdGUgX2RvY3VtZW50OiBhbnksXHJcbiAgICBASW5qZWN0KFBMQVRGT1JNX0lEKSBwcml2YXRlIF9wbGF0Zm9ybUlkOiBhbnlcclxuICApIHtcclxuICAgIHRoaXMuX2ludGVycnVwdGl2ZUV2ZW50cyA9IFsnbW91c2V3aGVlbCcsICdET01Nb3VzZVNjcm9sbCcsICd0b3VjaHN0YXJ0J107XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUYXJnZXQgYW4gRWxlbWVudCB0byBzY3JvbGwgdG8uIE5vdGljZSB0aGF0IHRoZSBgVGltZU91dGAgZGVjb3JhdG9yXHJcbiAgICogZW5zdXJlcyB0aGUgZXhlY3V0aW5nIHRvIHRha2UgcGxhY2UgaW4gdGhlIG5leHQgQW5ndWxhciBsaWZlY3ljbGUuXHJcbiAgICogVGhpcyBhbGxvd3MgZm9yIHNjcm9sbGluZyB0byBlbGVtZW50cyB0aGF0IGFyZSBlLmcuIGluaXRpYWxseSBoaWRkZW5cclxuICAgKiBieSBtZWFucyBvZiBgKm5nSWZgLCBidXQgb3VnaHQgdG8gYmUgc2Nyb2xsZWQgdG8gZXZlbnR1YWxseS5cclxuICAgKlxyXG4gICAqIEB0b2RvIHR5cGUgJ2FueScgaW4gT2JzZXJ2YWJsZSBzaG91bGQgYmVjb21lIGN1c3RvbSB0eXBlIGxpa2UgJ1Njcm9sbFRvRXZlbnQnIChiYXNlIGNsYXNzKSwgc2VlIGlzc3VlIGNvbW1lbnQ6XHJcbiAgICogXHQtIGh0dHBzOi8vZ2l0aHViLmNvbS9uaWNreS1sZW5hZXJzL25neC1zY3JvbGwtdG8vaXNzdWVzLzEwI2lzc3VlY29tbWVudC0zMTcxOTg0ODFcclxuICAgKlxyXG4gICAqIEBwYXJhbSBvcHRpb25zICAgICAgICAgQ29uZmlndXJhdGlvbiBPYmplY3RcclxuICAgKiBAcmV0dXJucyAgICAgICAgICAgICAgIE9ic2VydmFibGVcclxuICAgKi9cclxuICBwdWJsaWMgc2Nyb2xsVG8ob3B0aW9uczogU2Nyb2xsVG9Db25maWdPcHRpb25zKTogT2JzZXJ2YWJsZTxhbnk+IHtcclxuXHJcbiAgICBpZiAoIWlzUGxhdGZvcm1Ccm93c2VyKHRoaXMuX3BsYXRmb3JtSWQpKSByZXR1cm4gbmV3IFJlcGxheVN1YmplY3QoKS5hc09ic2VydmFibGUoKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5fc3RhcnQob3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdGFydCBhIG5ldyBBbmltYXRpb24uXHJcbiAgICpcclxuICAgKiBAdG9kbyBFbWl0IHByb3BlciBldmVudHMgZnJvbSBzdWJzY3JpcHRpb25cclxuICAgKlxyXG4gICAqIEBwYXJhbSBvcHRpb25zICAgICAgICAgQ29uZmlndXJhdGlvbiBPYmplY3RcclxuICAgKiBAcmV0dXJucyAgICAgICAgICAgICAgIE9ic2VydmFibGVcclxuICAgKi9cclxuICBwcml2YXRlIF9zdGFydChvcHRpb25zOiBTY3JvbGxUb0NvbmZpZ09wdGlvbnMpOiBPYnNlcnZhYmxlPG51bWJlcj4ge1xyXG5cclxuICAgIC8vIE1lcmdlIGNvbmZpZyB3aXRoIGRlZmF1bHQgdmFsdWVzXHJcbiAgICBjb25zdCBtZXJnZWRDb25maWdPcHRpb25zID0ge1xyXG4gICAgICAuLi5ERUZBVUxUUyBhcyBTY3JvbGxUb0NvbmZpZ09wdGlvbnMsXHJcbiAgICAgIC4uLm9wdGlvbnNcclxuICAgIH0gYXMgU2Nyb2xsVG9Db25maWdPcHRpb25zVGFyZ2V0O1xyXG5cclxuICAgIGlmICh0aGlzLl9hbmltYXRpb24pIHRoaXMuX2FuaW1hdGlvbi5zdG9wKCk7XHJcblxyXG4gICAgY29uc3QgdGFyZ2V0Tm9kZSA9IHRoaXMuX2dldE5vZGUobWVyZ2VkQ29uZmlnT3B0aW9ucy50YXJnZXQpO1xyXG4gICAgaWYgKG1lcmdlZENvbmZpZ09wdGlvbnMudGFyZ2V0ICYmICF0YXJnZXROb2RlKSByZXR1cm4gdGhyb3dFcnJvcignVW5hYmxlIHRvIGZpbmQgVGFyZ2V0IEVsZW1lbnQnKTtcclxuXHJcbiAgICBjb25zdCBjb250YWluZXI6IEhUTUxFbGVtZW50ID0gdGhpcy5fZ2V0Q29udGFpbmVyKG1lcmdlZENvbmZpZ09wdGlvbnMsIHRhcmdldE5vZGUpO1xyXG4gICAgaWYgKG1lcmdlZENvbmZpZ09wdGlvbnMuY29udGFpbmVyICYmICFjb250YWluZXIpIHJldHVybiB0aHJvd0Vycm9yKCdVbmFibGUgdG8gZmluZCBDb250YWluZXIgRWxlbWVudCcpO1xyXG5cclxuICAgIGNvbnN0IGxpc3RlbmVyVGFyZ2V0ID0gdGhpcy5fZ2V0TGlzdGVuZXJUYXJnZXQoY29udGFpbmVyKSB8fCB3aW5kb3c7XHJcblxyXG4gICAgbGV0IHRvID0gY29udGFpbmVyID8gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCA6IDA7XHJcblxyXG4gICAgaWYgKHRhcmdldE5vZGUpIHtcclxuICAgICAgdG8gPSBpc1dpbmRvdyhsaXN0ZW5lclRhcmdldCkgPyB0YXJnZXROb2RlLm9mZnNldFRvcCA6IHRhcmdldE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENyZWF0ZSBBbmltYXRpb25cclxuICAgIHRoaXMuX2FuaW1hdGlvbiA9IG5ldyBTY3JvbGxUb0FuaW1hdGlvbihcclxuICAgICAgY29udGFpbmVyLFxyXG4gICAgICBsaXN0ZW5lclRhcmdldCxcclxuICAgICAgaXNXaW5kb3cobGlzdGVuZXJUYXJnZXQpLFxyXG4gICAgICB0byxcclxuICAgICAgbWVyZ2VkQ29uZmlnT3B0aW9ucyxcclxuICAgICAgaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5fcGxhdGZvcm1JZClcclxuICAgICk7XHJcbiAgICBjb25zdCBvbkludGVycnVwdCA9ICgpID0+IHRoaXMuX2FuaW1hdGlvbi5zdG9wKCk7XHJcbiAgICB0aGlzLl9hZGRJbnRlcnJ1cHRpdmVFdmVudExpc3RlbmVycyhsaXN0ZW5lclRhcmdldCwgb25JbnRlcnJ1cHQpO1xyXG5cclxuICAgIC8vIFN0YXJ0IEFuaW1hdGlvblxyXG4gICAgY29uc3QgYW5pbWF0aW9uJCA9IHRoaXMuX2FuaW1hdGlvbi5zdGFydCgpO1xyXG4gICAgdGhpcy5fc3Vic2NyaWJlVG9BbmltYXRpb24oYW5pbWF0aW9uJCwgbGlzdGVuZXJUYXJnZXQsIG9uSW50ZXJydXB0KTtcclxuXHJcbiAgICByZXR1cm4gYW5pbWF0aW9uJDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN1YnNjcmliZSB0byB0aGUgZXZlbnRzIGVtaXR0ZWQgZnJvbSB0aGUgU2Nyb2xsaW5nXHJcbiAgICogQW5pbWF0aW9uLiBFdmVudHMgbWlnaHQgYmUgdXNlZCBmb3IgZS5nLiB1bnN1YnNjcmliaW5nXHJcbiAgICogb25jZSBmaW5pc2hlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBhbmltYXRpb24kICAgICAgICAgICAgICBUaGUgQW5pbWF0aW9uIE9ic2VydmFibGVcclxuICAgKiBAcGFyYW0gbGlzdGVuZXJUYXJnZXQgICAgICAgICAgVGhlIExpc3RlbmVyIFRhcmdldCBmb3IgZXZlbnRzXHJcbiAgICogQHBhcmFtIG9uSW50ZXJydXB0ICAgICAgICAgICAgIFRoZSBoYW5kbGVyIGZvciBJbnRlcnJ1cHRpdmUgRXZlbnRzXHJcbiAgICogQHJldHVybnMgICAgICAgICAgICAgICAgICAgICAgIFZvaWRcclxuICAgKi9cclxuICBwcml2YXRlIF9zdWJzY3JpYmVUb0FuaW1hdGlvbihcclxuICAgICAgYW5pbWF0aW9uJDogT2JzZXJ2YWJsZTxhbnk+LFxyXG4gICAgICBsaXN0ZW5lclRhcmdldDogU2Nyb2xsVG9MaXN0ZW5lclRhcmdldCxcclxuICAgICAgb25JbnRlcnJ1cHQ6IEV2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3QpIHtcclxuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGFuaW1hdGlvbiRcclxuICAgICAgLnN1YnNjcmliZShcclxuICAgICAgICAoKSA9PiB7IH0sXHJcbiAgICAgICAgKCkgPT4geyB9LFxyXG4gICAgICAgICgpID0+IHtcclxuICAgICAgICAgIHRoaXMuX3JlbW92ZUludGVycnVwdGl2ZUV2ZW50TGlzdGVuZXJzKHRoaXMuX2ludGVycnVwdGl2ZUV2ZW50cywgbGlzdGVuZXJUYXJnZXQsIG9uSW50ZXJydXB0KTtcclxuICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgY29udGFpbmVyIEhUTUwgRWxlbWVudCBpbiB3aGljaFxyXG4gICAqIHRoZSBzY3JvbGxpbmcgc2hvdWxkIGhhcHBlbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBvcHRpb25zICAgICAgICAgVGhlIE1lcmdlZCBDb25maWd1cmF0aW9uIE9iamVjdFxyXG4gICAqIEBwYXJhbSB0YXJnZXROb2RlICAgIHRoZSB0YXJnZXRlZCBIVE1MRWxlbWVudFxyXG4gICAqIEByZXR1cm5zXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfZ2V0Q29udGFpbmVyKG9wdGlvbnM6IFNjcm9sbFRvQ29uZmlnT3B0aW9ucywgdGFyZ2V0Tm9kZTogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudCB8IG51bGwge1xyXG5cclxuICAgIGxldCBjb250YWluZXI6IEhUTUxFbGVtZW50IHwgbnVsbCA9IG51bGw7XHJcblxyXG4gICAgaWYgKG9wdGlvbnMuY29udGFpbmVyKSB7XHJcbiAgICAgIGNvbnRhaW5lciA9IHRoaXMuX2dldE5vZGUob3B0aW9ucy5jb250YWluZXIsIHRydWUpO1xyXG4gICAgfSBlbHNlIGlmICh0YXJnZXROb2RlKSB7XHJcbiAgICAgIGNvbnRhaW5lciA9IHRoaXMuX2dldEZpcnN0U2Nyb2xsYWJsZVBhcmVudCh0YXJnZXROb2RlKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY29udGFpbmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIGxpc3RlbmVycyBmb3IgdGhlIEFuaW1hdGlvbiBJbnRlcnJ1cHRpdmUgRXZlbnRzXHJcbiAgICogdG8gdGhlIExpc3RlbmVyIFRhcmdldC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBldmVudHMgICAgICAgICAgICBMaXN0IG9mIGV2ZW50cyB0byBsaXN0ZW4gdG9cclxuICAgKiBAcGFyYW0gbGlzdGVuZXJUYXJnZXQgICAgVGFyZ2V0IHRvIGF0dGFjaCB0aGUgbGlzdGVuZXIgb25cclxuICAgKiBAcGFyYW0gaGFuZGxlciAgICAgICAgICAgSGFuZGxlciBmb3Igd2hlbiB0aGUgbGlzdGVuZXIgZmlyZXNcclxuICAgKiBAcmV0dXJucyAgICAgICAgICAgICAgICAgVm9pZFxyXG4gICAqL1xyXG4gIHByaXZhdGUgX2FkZEludGVycnVwdGl2ZUV2ZW50TGlzdGVuZXJzKFxyXG4gICAgbGlzdGVuZXJUYXJnZXQ6IFNjcm9sbFRvTGlzdGVuZXJUYXJnZXQsXHJcbiAgICBoYW5kbGVyOiBFdmVudExpc3RlbmVyT3JFdmVudExpc3RlbmVyT2JqZWN0KTogdm9pZCB7XHJcblxyXG4gICAgICBpZiAoIWxpc3RlbmVyVGFyZ2V0KSBsaXN0ZW5lclRhcmdldCA9IHdpbmRvdztcclxuXHJcbiAgICB0aGlzLl9pbnRlcnJ1cHRpdmVFdmVudHMuZm9yRWFjaChldmVudCA9PiBsaXN0ZW5lclRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmUgbGlzdGVuZXJzIGZvciB0aGUgQW5pbWF0aW9uIEludGVycnVwdCBFdmVudCBmcm9tXHJcbiAgICogdGhlIExpc3RlbmVyIFRhcmdldC4gU3BlY2lmeWluZyB0aGUgY29ycmVjdCBoYW5kbGVyIHByZXZlbnRzXHJcbiAgICogbWVtb3J5IGxlYWtzIGFuZCBtYWtlcyB0aGUgYWxsb2NhdGVkIG1lbW9yeSBhdmFpbGFibGUgZm9yXHJcbiAgICogR2FyYmFnZSBDb2xsZWN0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGV2ZW50cyAgICAgICAgICAgIExpc3Qgb2YgSW50ZXJydXB0aXZlIEV2ZW50cyB0byByZW1vdmVcclxuICAgKiBAcGFyYW0gbGlzdGVuZXJUYXJnZXQgICAgVGFyZ2V0IHRvIGF0dGFjaCB0aGUgbGlzdGVuZXIgb25cclxuICAgKiBAcGFyYW0gaGFuZGxlciAgICAgICAgICAgSGFuZGxlciBmb3Igd2hlbiB0aGUgbGlzdGVuZXIgZmlyZXNcclxuICAgKiBAcmV0dXJucyAgICAgICAgICAgICAgICAgVm9pZFxyXG4gICAqL1xyXG4gIHByaXZhdGUgX3JlbW92ZUludGVycnVwdGl2ZUV2ZW50TGlzdGVuZXJzKFxyXG4gICAgZXZlbnRzOiBzdHJpbmdbXSxcclxuICAgIGxpc3RlbmVyVGFyZ2V0OiBTY3JvbGxUb0xpc3RlbmVyVGFyZ2V0LFxyXG4gICAgaGFuZGxlcjogRXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdCk6IHZvaWQge1xyXG5cclxuICAgIGlmICghbGlzdGVuZXJUYXJnZXQpIGxpc3RlbmVyVGFyZ2V0ID0gd2luZG93O1xyXG4gICAgZXZlbnRzLmZvckVhY2goZXZlbnQgPT4gbGlzdGVuZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlcikpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRmluZCB0aGUgZmlyc3Qgc2Nyb2xsYWJsZSBwYXJlbnQgTm9kZSBvZiBhIGdpdmVuXHJcbiAgICogRWxlbWVudC4gVGhlIERPTSBUcmVlIGdldHMgc2VhcmNoZWQgdXB3YXJkc1xyXG4gICAqIHRvIGZpbmQgdGhpcyBmaXJzdCBzY3JvbGxhYmxlIHBhcmVudC4gUGFyZW50cyBtaWdodFxyXG4gICAqIGJlIGlnbm9yZWQgYnkgQ1NTIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBIVE1MIEVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gbmF0aXZlRWxlbWVudCAgICAgVGhlIEVsZW1lbnQgdG8gc2VhcmNoIHRoZSBET00gVHJlZSB1cHdhcmRzIGZyb21cclxuICAgKiBAcmV0dXJucyAgICAgICAgICAgICAgICAgVGhlIGZpcnN0IHNjcm9sbGFibGUgcGFyZW50IEhUTUwgRWxlbWVudFxyXG4gICAqL1xyXG4gIHByaXZhdGUgX2dldEZpcnN0U2Nyb2xsYWJsZVBhcmVudChuYXRpdmVFbGVtZW50OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50IHtcclxuXHJcbiAgICBsZXQgc3R5bGU6IENTU1N0eWxlRGVjbGFyYXRpb24gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShuYXRpdmVFbGVtZW50KTtcclxuXHJcbiAgICBjb25zdCBvdmVyZmxvd1JlZ2V4OiBSZWdFeHAgPSAvKGF1dG98c2Nyb2xsKS87XHJcblxyXG4gICAgaWYgKHN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICBmb3IgKGxldCBwYXJlbnQgPSBuYXRpdmVFbGVtZW50OyBwYXJlbnQgPSBwYXJlbnQucGFyZW50RWxlbWVudDsgbnVsbCkge1xyXG5cclxuICAgICAgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnQpO1xyXG5cclxuICAgICAgaWYgKHN0eWxlLnBvc2l0aW9uID09PSAnYWJzb2x1dGUnXHJcbiAgICAgICAgfHwgc3R5bGUub3ZlcmZsb3cgPT09ICdoaWRkZW4nXHJcbiAgICAgICAgfHwgc3R5bGUub3ZlcmZsb3dZID09PSAnaGlkZGVuJykgY29udGludWU7XHJcblxyXG4gICAgICBpZiAob3ZlcmZsb3dSZWdleC50ZXN0KHN0eWxlLm92ZXJmbG93ICsgc3R5bGUub3ZlcmZsb3dZICsgc3R5bGUub3ZlcmZsb3dYKVxyXG4gICAgICAgIHx8IHBhcmVudC50YWdOYW1lID09PSAnQk9EWScpIHJldHVybiBwYXJlbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIFRhcmdldCBOb2RlIHRvIHNjcm9sbCB0by5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBpZCAgICAgICAgICAgICAgVGhlIGdpdmVuIElEIG9mIHRoZSBub2RlLCBlaXRoZXIgYSBzdHJpbmcgb3JcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIGFuIGVsZW1lbnQgcmVmZXJlbmNlXHJcbiAgICogQHBhcmFtIGFsbG93Qm9keVRhZyAgICBJbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGUgRG9jdW1lbnQgQm9keSBpc1xyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgY29uc2lkZXJlZCBhIHZhbGlkIFRhcmdldCBOb2RlXHJcbiAgICogQHJldHVybnMgICAgICAgICAgICAgICBUaGUgVGFyZ2V0IE5vZGUgdG8gc2Nyb2xsIHRvXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfZ2V0Tm9kZShpZDogU2Nyb2xsVG9UYXJnZXQsIGFsbG93Qm9keVRhZzogYm9vbGVhbiA9IGZhbHNlKTogSFRNTEVsZW1lbnQge1xyXG5cclxuICAgIGxldCB0YXJnZXROb2RlOiBIVE1MRWxlbWVudDtcclxuXHJcbiAgICBpZiAoaXNTdHJpbmcoaWQpKSB7XHJcblxyXG4gICAgICBpZiAoYWxsb3dCb2R5VGFnICYmIChpZCA9PT0gJ2JvZHknIHx8IGlkID09PSAnQk9EWScpKSB7XHJcblxyXG4gICAgICAgIHRhcmdldE5vZGUgPSB0aGlzLl9kb2N1bWVudC5ib2R5O1xyXG5cclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgdGFyZ2V0Tm9kZSA9IHRoaXMuX2RvY3VtZW50LmdldEVsZW1lbnRCeUlkKHN0cmlwSGFzaChpZCkpO1xyXG5cclxuICAgICAgfVxyXG5cclxuICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoaWQpKSB7XHJcblxyXG4gICAgICB0YXJnZXROb2RlID0gdGhpcy5fZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoU3RyaW5nKGlkKSk7XHJcblxyXG4gICAgfSBlbHNlIGlmIChpc0VsZW1lbnRSZWYoaWQpKSB7XHJcblxyXG4gICAgICB0YXJnZXROb2RlID0gaWQubmF0aXZlRWxlbWVudDtcclxuXHJcbiAgICB9IGVsc2UgaWYgKGlzTmF0aXZlRWxlbWVudChpZCkpIHtcclxuXHJcbiAgICAgIHRhcmdldE5vZGUgPSBpZDtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRhcmdldE5vZGU7XHJcblxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0cmlldmUgdGhlIExpc3RlbmVyIHRhcmdldC4gVGhpcyBMaXN0ZW5lciBUYXJnZXQgaXMgdXNlZFxyXG4gICAqIHRvIGF0dGFjaCBFdmVudCBMaXN0ZW5lcnMgb24uIEluIGNhc2Ugb2YgdGhlIHRhcmdldCBiZWluZ1xyXG4gICAqIHRoZSBEb2N1bWVudCBCb2R5LCB3ZSBuZWVkIHRoZSBhY3R1YWwgYHdpbmRvd2AgdG8gbGlzdGVuXHJcbiAgICogZm9yIGV2ZW50cy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBjb250YWluZXIgICAgICAgICAgIFRoZSBIVE1MIENvbnRhaW5lciBlbGVtZW50XHJcbiAgICogQHJldHVybnMgICAgICAgICAgICAgICAgICAgVGhlIExpc3RlbmVyIFRhcmdldCB0byBhdHRhY2ggZXZlbnRzIG9uXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfZ2V0TGlzdGVuZXJUYXJnZXQoY29udGFpbmVyOiBIVE1MRWxlbWVudCk6IFNjcm9sbFRvTGlzdGVuZXJUYXJnZXQge1xyXG4gICAgaWYgKCFjb250YWluZXIpIHJldHVybiBudWxsO1xyXG4gICAgcmV0dXJuIHRoaXMuX2lzRG9jdW1lbnRCb2R5KGNvbnRhaW5lcikgPyB3aW5kb3cgOiBjb250YWluZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUZXN0IGlmIGEgZ2l2ZW4gSFRNTCBFbGVtZW50IGlzIHRoZSBEb2N1bWVudCBCb2R5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGVsZW1lbnQgICAgICAgICAgICAgVGhlIGdpdmVuIEhUTUwgRWxlbWVudFxyXG4gICAqIEByZXR1cm5zICAgICAgICAgICAgICAgICAgIFdoZXRoZXIgb3Igbm90IHRoZSBFbGVtZW50IGlzIHRoZVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIERvY3VtZW50IEJvZHkgRWxlbWVudFxyXG4gICAqL1xyXG4gIHByaXZhdGUgX2lzRG9jdW1lbnRCb2R5KGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogZWxlbWVudCBpcyBIVE1MQm9keUVsZW1lbnQge1xyXG4gICAgcmV0dXJuIGVsZW1lbnQudGFnTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnQk9EWSc7XHJcbiAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQge1xyXG4gIERpcmVjdGl2ZSxcclxuICBJbnB1dCxcclxuICBFbGVtZW50UmVmLFxyXG4gIFJlbmRlcmVyMixcclxuICBBZnRlclZpZXdJbml0XHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5pbXBvcnQge1xyXG4gIERFRkFVTFRTLFxyXG4gIEVWRU5UU1xyXG59IGZyb20gJy4vc3RhdGljcy9zY3JvbGwtdG8taGVscGVycyc7XHJcbmltcG9ydCB7XHJcbiAgU2Nyb2xsVG9Db25maWdPcHRpb25zLFxyXG4gIFNjcm9sbFRvT2Zmc2V0TWFwLFxyXG4gIFNjcm9sbFRvVGFyZ2V0XHJcbn0gZnJvbSAnLi9tb2RlbHMvc2Nyb2xsLXRvLWNvbmZpZy5tb2RlbCc7XHJcbmltcG9ydCB7XHJcbiAgU2Nyb2xsVG9BbmltYXRpb25FYXNpbmdcclxufSBmcm9tICcuL21vZGVscy9zY3JvbGwtdG8tZWFzaW5nLm1vZGVsJztcclxuaW1wb3J0IHsgU2Nyb2xsVG9FdmVudCB9IGZyb20gJy4vbW9kZWxzL3Njcm9sbC10by1ldmVudC5tb2RlbCc7XHJcbmltcG9ydCB7IFNjcm9sbFRvU2VydmljZSB9IGZyb20gJy4vc2Nyb2xsLXRvLnNlcnZpY2UnO1xyXG5cclxuQERpcmVjdGl2ZSh7XHJcbiAgc2VsZWN0b3I6ICdbbmd4LXNjcm9sbC10b10nXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBTY3JvbGxUb0RpcmVjdGl2ZSBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQge1xyXG5cclxuICBASW5wdXQoJ25neC1zY3JvbGwtdG8nKVxyXG4gIHB1YmxpYyBuZ3hTY3JvbGxUbzogU2Nyb2xsVG9UYXJnZXQgPSBERUZBVUxUUy50YXJnZXQ7XHJcblxyXG4gIEBJbnB1dCgnbmd4LXNjcm9sbC10by1ldmVudCcpXHJcbiAgcHVibGljIG5neFNjcm9sbFRvRXZlbnQ6IFNjcm9sbFRvRXZlbnQgPSBERUZBVUxUUy5hY3Rpb247XHJcblxyXG4gIEBJbnB1dCgnbmd4LXNjcm9sbC10by1kdXJhdGlvbicpXHJcbiAgcHVibGljIG5neFNjcm9sbFRvRHVyYXRpb246IG51bWJlciA9IERFRkFVTFRTLmR1cmF0aW9uO1xyXG5cclxuICBASW5wdXQoJ25neC1zY3JvbGwtdG8tZWFzaW5nJylcclxuICBwdWJsaWMgbmd4U2Nyb2xsVG9FYXNpbmc6IFNjcm9sbFRvQW5pbWF0aW9uRWFzaW5nID0gREVGQVVMVFMuZWFzaW5nO1xyXG5cclxuICBASW5wdXQoJ25neC1zY3JvbGwtdG8tb2Zmc2V0JylcclxuICBwdWJsaWMgbmd4U2Nyb2xsVG9PZmZzZXQ6IG51bWJlciA9IERFRkFVTFRTLm9mZnNldDtcclxuXHJcbiAgQElucHV0KCduZ3gtc2Nyb2xsLXRvLW9mZnNldC1tYXAnKVxyXG4gIHB1YmxpYyBuZ3hTY3JvbGxUb09mZnNldE1hcDogU2Nyb2xsVG9PZmZzZXRNYXAgPSBERUZBVUxUUy5vZmZzZXRNYXA7XHJcblxyXG4gIHByaXZhdGUgX29wdGlvbnM6IFNjcm9sbFRvQ29uZmlnT3B0aW9ucztcclxuXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLFxyXG4gICAgcHJpdmF0ZSBfc2Nyb2xsVG9TZXJ2aWNlOiBTY3JvbGxUb1NlcnZpY2UsXHJcbiAgICBwcml2YXRlIF9yZW5kZXJlcjI6IFJlbmRlcmVyMikge1xyXG5cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFuZ3VsYXIgTGlmZWN5Y2xlIEhvb2sgLSBBZnRlciBWaWV3IEluaXRcclxuICAgKlxyXG4gICAqIEB0b2RvIEltcGxlbWVudCBTdWJzY3JpcHRpb24gZm9yIEV2ZW50c1xyXG4gICAqXHJcbiAgICogQHJldHVybnMgdm9pZFxyXG4gICAqL1xyXG4gIHB1YmxpYyBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XHJcblxyXG4gICAgLy8gVGVzdCBFdmVudCBTdXBwb3J0XHJcbiAgICBpZiAoRVZFTlRTLmluZGV4T2YodGhpcy5uZ3hTY3JvbGxUb0V2ZW50KSA9PT0gLTEpIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgRXZlbnQgJyR7dGhpcy5uZ3hTY3JvbGxUb0V2ZW50fSdgKTtcclxuXHJcbiAgICAvLyBMaXN0ZW4gZm9yIHRoZSB0cmlnZ2VyLi4uXHJcbiAgICB0aGlzLl9yZW5kZXJlcjIubGlzdGVuKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgdGhpcy5uZ3hTY3JvbGxUb0V2ZW50LFxyXG4gICAgICAoZXZlbnQ6IEV2ZW50KSA9PiB7XHJcblxyXG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSB7XHJcbiAgICAgICAgICB0YXJnZXQ6IHRoaXMubmd4U2Nyb2xsVG8sXHJcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5uZ3hTY3JvbGxUb0R1cmF0aW9uLFxyXG4gICAgICAgICAgZWFzaW5nOiB0aGlzLm5neFNjcm9sbFRvRWFzaW5nLFxyXG4gICAgICAgICAgb2Zmc2V0OiB0aGlzLm5neFNjcm9sbFRvT2Zmc2V0LFxyXG4gICAgICAgICAgb2Zmc2V0TWFwOiB0aGlzLm5neFNjcm9sbFRvT2Zmc2V0TWFwXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5fc2Nyb2xsVG9TZXJ2aWNlLnNjcm9sbFRvKHRoaXMuX29wdGlvbnMpO1xyXG4gICAgICB9KTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgTmdNb2R1bGUsIE1vZHVsZVdpdGhQcm92aWRlcnMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgU2Nyb2xsVG9EaXJlY3RpdmUgfSBmcm9tICcuL3Njcm9sbC10by5kaXJlY3RpdmUnO1xyXG5pbXBvcnQgeyBTY3JvbGxUb1NlcnZpY2UgfSBmcm9tICcuL3Njcm9sbC10by5zZXJ2aWNlJztcclxuXHJcbkBOZ01vZHVsZSh7XHJcbiAgZGVjbGFyYXRpb25zOiBbXHJcbiAgICBTY3JvbGxUb0RpcmVjdGl2ZVxyXG4gIF0sXHJcbiAgZXhwb3J0czogW1xyXG4gICAgU2Nyb2xsVG9EaXJlY3RpdmVcclxuICBdXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBTY3JvbGxUb01vZHVsZSB7XHJcbiAgLyoqXHJcbiAgICogR3VhcmFudGVlZCBzaW5nbGV0b25zIGZvciBwcm92aWRlZCBTZXJ2aWNlcyBhY3Jvc3MgQXBwLlxyXG4gICAqXHJcbiAgICogQHJldHVybiAgICAgICAgICBBbiBBbmd1bGFyIE1vZHVsZSB3aXRoIFByb3ZpZGVyc1xyXG4gICAqL1xyXG4gIHN0YXRpYyBmb3JSb290KCk6IE1vZHVsZVdpdGhQcm92aWRlcnMge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbmdNb2R1bGU6IFNjcm9sbFRvTW9kdWxlLFxyXG4gICAgICBwcm92aWRlcnM6IFtcclxuICAgICAgICBTY3JvbGxUb1NlcnZpY2VcclxuICAgICAgXVxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7OztBQWVBLEFBQU8sdUJBQU0sUUFBUSxHQUFpQztJQUNwRCxNQUFNLEVBQUUsSUFBSTtJQUNaLE1BQU0sRUFBRSxPQUFPO0lBQ2YsUUFBUSxFQUFFLEdBQUc7SUFDYixNQUFNLEVBQUUsZUFBZTtJQUN2QixNQUFNLEVBQUUsQ0FBQztJQUNULFNBQVMsRUFBRSxJQUFJLEdBQUcsRUFBRTtDQUNyQixDQUFDOzs7O0FBS0YsQUFBTyx1QkFBTSxNQUFNLEdBQXNDO0lBQ3ZELFVBQVUsRUFBRSxDQUFDLElBQVk7UUFDdkIsT0FBTyxJQUFJLEdBQUcsSUFBSSxDQUFDO0tBQ3BCO0lBQ0QsV0FBVyxFQUFFLENBQUMsSUFBWTtRQUN4QixPQUFPLElBQUksSUFBSSxDQUFDLEdBQUcsSUFBSSxDQUFDLENBQUM7S0FDMUI7SUFDRCxhQUFhLEVBQUUsQ0FBQyxJQUFZO1FBQzFCLE9BQU8sSUFBSSxHQUFHLEdBQUcsR0FBRyxDQUFDLEdBQUcsSUFBSSxHQUFHLElBQUksR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxJQUFJLElB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