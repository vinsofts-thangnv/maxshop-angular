import { ElementRef, Injectable, PLATFORM_ID, Inject, Directive, Input, Renderer2, NgModule } from '@angular/core';
import { ReplaySubject, throwError } from 'rxjs/index';
import { __assign } from 'tslib';
import { DOCUMENT, isPlatformBrowser } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Default values for Component Input.
 */
var /** @type {?} */ DEFAULTS = {
    target: null,
    action: 'click',
    duration: 650,
    easing: 'easeInOutQuad',
    offset: 0,
    offsetMap: new Map()
};
/**
 * Easing Colleciton.
 */
var /** @type {?} */ EASING = {
    easeInQuad: function (time) {
        return time * time;
    },
    easeOutQuad: function (time) {
        return time * (2 - time);
    },
    easeInOutQuad: function (time) {
        return time < 0.5 ? 2 * time * time : -1 + (4 - 2 * time) * time;
    },
    easeInCubic: function (time) {
        return time * time * time;
    },
    easeOutCubic: function (time) {
        return (--time) * time * time + 1;
    },
    easeInOutCubic: function (time) {
        return time < 0.5 ? 4 * time * time * time : (time - 1) * (2 * time - 2) * (2 * time - 2) + 1;
    },
    easeInQuart: function (time) {
        return time * time * time * time;
    },
    easeOutQuart: function (time) {
        return 1 - (--time) * time * time * time;
    },
    easeInOutQuart: function (time) {
        return time < 0.5 ? 8 * time * time * time * time : 1 - 8 * (--time) * time * time * time;
    },
    easeInQuint: function (time) {
        return time * time * time * time * time;
    },
    easeOutQuint: function (time) {
        return 1 + (--time) * time * time * time * time;
    },
    easeInOutQuint: function (time) {
        return time < 0.5 ? 16 * time * time * time * time * time : 1 + 16 * (--time) * time * time * time * time;
    },
    easeOutElastic: function (time) {
        return Math.pow(2, -10 * time) * Math.sin((time - 1 / 4) * (2 * Math.PI) / 1) + 1;
    }
};
/**
 * Set of allowed events as triggers
 * for the Animation to start.
 */
var /** @type {?} */ EVENTS = [
    'click',
    'mouseenter',
    'mouseover',
    'mousedown',
    'mouseup',
    'dblclick',
    'contextmenu',
    'wheel',
    'mouseleave',
    'mouseout'
];
/**
 * Strip hash (#) from value.
 *
 * @param {?} value 				The given string value
 * @return {?} 					The stripped string value
 */
function stripHash(value) {
    return value.substring(0, 1) === '#' ? value.substring(1) : value;
}
/**
 * Test if a given value is a string.
 *
 * @param {?} value 					The given value
 * @return {?} 						Whether the given value is a string
 */
function isString(value) {
    return typeof value === 'string' || value instanceof String;
}
/**
 * Test if a given Element is the Window.
 *
 * @param {?} container 				The given Element
 * @return {?} 						Whether the given Element is Window
 */
function isWindow(container) {
    return container === window;
}
/**
 * Test if a given value is of type ElementRef.
 *
 * @param {?} value 					The given value
 * @return {?} Whether the given value is a number
 */
function isElementRef(value) {
    return value instanceof ElementRef;
}
/**
 * Whether or not the given value is a Native Element.
 *
 * @param {?} value           The given value
 * @return {?} Whether or not the value is a Native Element
 */
function isNativeElement(value) {
    return value instanceof HTMLElement;
}
/**
 * Test if a given value is type number.
 *
 * @param {?} value 					The given value
 * @return {?} 						Whether the given value is a number
 */
function isNumber(value) {
    return !isNaN(parseFloat(value)) && isFinite(value);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Scroll To Animation.
 */
var /**
 * Scroll To Animation.
 */
ScrollToAnimation = /** @class */ (function () {
    /**
     * Class Constructor.
     *
     * @param _container            The Container
     * @param _listenerTarget       The Element that listens for DOM Events
     * @param _isWindow             Whether or not the listener is the Window
     * @param _to                   Position to scroll to
     * @param _options              Additional options for scrolling
     * @param _isBrowser            Whether or not execution runs in the browser
     *                              (as opposed to the server)
     */
    function ScrollToAnimation(_container, _listenerTarget, _isWindow, _to, _options, _isBrowser) {
        var _this = this;
        this._container = _container;
        this._listenerTarget = _listenerTarget;
        this._isWindow = _isWindow;
        this._to = _to;
        this._options = _options;
        this._isBrowser = _isBrowser;
        /**
         * Recursively loop over the Scroll Animation.
         *
         * @return Void
         */
        this._loop = function () {
            _this._timeLapsed += _this._tick;
            _this._percentage = (_this._timeLapsed / _this._options.duration);
            _this._percentage = (_this._percentage > 1) ? 1 : _this._percentage;
            // Position Update
            // Position Update
            _this._position = _this._startPosition +
                ((_this._startPosition - _this._to <= 0 ? 1 : -1) *
                    _this._distance *
                    EASING[_this._options.easing](_this._percentage));
            if (_this._lastPosition !== null && _this._position === _this._lastPosition) {
                _this.stop();
            }
            else {
                _this._source$.next(_this._position);
                _this._isWindow
                    ? _this._listenerTarget.scrollTo(0, Math.floor(_this._position))
                    : _this._container.scrollTop = Math.floor(_this._position);
                _this._lastPosition = _this._position;
            }
        };
        this._tick = 16;
        this._interval = null;
        this._lastPosition = null;
        this._timeLapsed = 0;
        this._windowScrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
        if (!this._container) {
            this._startPosition = this._windowScrollTop;
        }
        else {
            this._startPosition = this._isWindow ? this._windowScrollTop : this._container.scrollTop;
        }
        // Correction for Starting Position of nested HTML Elements
        if (this._container && !this._isWindow) {
            this._to = this._to - this._container.getBoundingClientRect().top + this._startPosition;
        }
        // Set Distance
        var /** @type {?} */ directionalDistance = this._startPosition - this._to;
        this._distance = this._container ? Math.abs(this._startPosition - this._to) : this._to;
        this._mappedOffset = this._options.offset;
        // Set offset from Offset Map
        if (this._isBrowser) {
            this._options
                .offsetMap
                .forEach(function (value, key) { return _this._mappedOffset = window.innerWidth > key ? value : _this._mappedOffset; });
        }
        this._distance += this._mappedOffset * (directionalDistance <= 0 ? 1 : -1);
        this._source$ = new ReplaySubject();
    }
    /**
     * Start the new Scroll Animation.
     *
     * @return {?} Observable containing a number
     */
    ScrollToAnimation.prototype.start = /**
     * Start the new Scroll Animation.
     *
     * @return {?} Observable containing a number
     */
    function () {
        clearInterval(this._interval);
        this._interval = setInterval(this._loop, this._tick);
        return this._source$.asObservable();
    };
    /**
     * Stop the current Scroll Animation Loop.
     *
     * @return {?} Void
     */
    ScrollToAnimation.prototype.stop = /**
     * Stop the current Scroll Animation Loop.
     *
     * @return {?} Void
     */
    function () {
        clearInterval(this._interval);
        this._interval = null;
        this._source$.complete();
    };
    return ScrollToAnimation;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * The ScrollToService handles starting, interrupting
 * and ending the actual Scroll Animation. It provides
 * some utilities to find the proper HTML Element on a
 * given page to setup Event Listeners and calculate
 * distances for the Animation.
 */
var ScrollToService = /** @class */ (function () {
    /**
     * Construct and setup required paratemeters.
     *
     * @param _document         A Reference to the Document
     * @param _platformId       Angular Platform ID
     */
    function ScrollToService(_document, _platformId) {
        this._document = _document;
        this._platformId = _platformId;
        this._interruptiveEvents = ['mousewheel', 'DOMMouseScroll', 'touchstart'];
    }
    /**
     * Target an Element to scroll to. Notice that the `TimeOut` decorator
     * ensures the executing to take place in the next Angular lifecycle.
     * This allows for scrolling to elements that are e.g. initially hidden
     * by means of `*ngIf`, but ought to be scrolled to eventually.
     *
     * \@todo type 'any' in Observable should become custom type like 'ScrollToEvent' (base class), see issue comment:
     * 	- https://github.com/nicky-lenaers/ngx-scroll-to/issues/10#issuecomment-317198481
     *
     * @param {?} options         Configuration Object
     * @return {?} Observable
     */
    ScrollToService.prototype.scrollTo = /**
     * Target an Element to scroll to. Notice that the `TimeOut` decorator
     * ensures the executing to take place in the next Angular lifecycle.
     * This allows for scrolling to elements that are e.g. initially hidden
     * by means of `*ngIf`, but ought to be scrolled to eventually.
     *
     * \@todo type 'any' in Observable should become custom type like 'ScrollToEvent' (base class), see issue comment:
     * 	- https://github.com/nicky-lenaers/ngx-scroll-to/issues/10#issuecomment-317198481
     *
     * @param {?} options         Configuration Object
     * @return {?} Observable
     */
    function (options) {
        if (!isPlatformBrowser(this._platformId))
            return new ReplaySubject().asObservable();
        return this._start(options);
    };
    /**
     * Start a new Animation.
     *
     * \@todo Emit proper events from subscription
     *
     * @param {?} options         Configuration Object
     * @return {?} Observable
     */
    ScrollToService.prototype._start = /**
     * Start a new Animation.
     *
     * \@todo Emit proper events from subscription
     *
     * @param {?} options         Configuration Object
     * @return {?} Observable
     */
    function (options) {
        var _this = this;
        // Merge config with default values
        var /** @type {?} */ mergedConfigOptions = /** @type {?} */ (__assign({}, /** @type {?} */ (DEFAULTS), options));
        if (this._animation)
            this._animation.stop();
        var /** @type {?} */ targetNode = this._getNode(mergedConfigOptions.target);
        if (mergedConfigOptions.target && !targetNode)
            return throwError('Unable to find Target Element');
        var /** @type {?} */ container = this._getContainer(mergedConfigOptions, targetNode);
        if (mergedConfigOptions.container && !container)
            return throwError('Unable to find Container Element');
        var /** @type {?} */ listenerTarget = this._getListenerTarget(container) || window;
        var /** @type {?} */ to = container ? container.getBoundingClientRect().top : 0;
        if (targetNode) {
            to = isWindow(listenerTarget) ? targetNode.offsetTop : targetNode.getBoundingClientRect().top;
        }
        // Create Animation
        this._animation = new ScrollToAnimation(container, listenerTarget, isWindow(listenerTarget), to, mergedConfigOptions, isPlatformBrowser(this._platformId));
        var /** @type {?} */ onInterrupt = function () { return _this._animation.stop(); };
        this._addInterruptiveEventListeners(listenerTarget, onInterrupt);
        // Start Animation
        var /** @type {?} */ animation$ = this._animation.start();
        this._subscribeToAnimation(animation$, listenerTarget, onInterrupt);
        return animation$;
    };
    /**
     * Subscribe to the events emitted from the Scrolling
     * Animation. Events might be used for e.g. unsubscribing
     * once finished.
     *
     * @param {?} animation$              The Animation Observable
     * @param {?} listenerTarget          The Listener Target for events
     * @param {?} onInterrupt             The handler for Interruptive Events
     * @return {?} Void
     */
    ScrollToService.prototype._subscribeToAnimation = /**
     * Subscribe to the events emitted from the Scrolling
     * Animation. Events might be used for e.g. unsubscribing
     * once finished.
     *
     * @param {?} animation$              The Animation Observable
     * @param {?} listenerTarget          The Listener Target for events
     * @param {?} onInterrupt             The handler for Interruptive Events
     * @return {?} Void
     */
    function (animation$, listenerTarget, onInterrupt) {
        var _this = this;
        var /** @type {?} */ subscription = animation$
            .subscribe(function () { }, function () { }, function () {
            _this._removeInterruptiveEventListeners(_this._interruptiveEvents, listenerTarget, onInterrupt);
            subscription.unsubscribe();
        });
    };
    /**
     * Get the container HTML Element in which
     * the scrolling should happen.
     *
     * @param {?} options         The Merged Configuration Object
     * @param {?} targetNode    the targeted HTMLElement
     * @return {?}
     */
    ScrollToService.prototype._getContainer = /**
     * Get the container HTML Element in which
     * the scrolling should happen.
     *
     * @param {?} options         The Merged Configuration Object
     * @param {?} targetNode    the targeted HTMLElement
     * @return {?}
     */
    function (options, targetNode) {
        var /** @type {?} */ container = null;
        if (options.container) {
            container = this._getNode(options.container, true);
        }
        else if (targetNode) {
            container = this._getFirstScrollableParent(targetNode);
        }
        return container;
    };
    /**
     * Add listeners for the Animation Interruptive Events
     * to the Listener Target.
     *
     * @param {?} listenerTarget    Target to attach the listener on
     * @param {?} handler           Handler for when the listener fires
     * @return {?} Void
     */
    ScrollToService.prototype._addInterruptiveEventListeners = /**
     * Add listeners for the Animation Interruptive Events
     * to the Listener Target.
     *
     * @param {?} listenerTarget    Target to attach the listener on
     * @param {?} handler           Handler for when the listener fires
     * @return {?} Void
     */
    function (listenerTarget, handler) {
        if (!listenerTarget)
            listenerTarget = window;
        this._interruptiveEvents.forEach(function (event) { return listenerTarget.addEventListener(event, handler); });
    };
    /**
     * Remove listeners for the Animation Interrupt Event from
     * the Listener Target. Specifying the correct handler prevents
     * memory leaks and makes the allocated memory available for
     * Garbage Collection.
     *
     * @param {?} events            List of Interruptive Events to remove
     * @param {?} listenerTarget    Target to attach the listener on
     * @param {?} handler           Handler for when the listener fires
     * @return {?} Void
     */
    ScrollToService.prototype._removeInterruptiveEventListeners = /**
     * Remove listeners for the Animation Interrupt Event from
     * the Listener Target. Specifying the correct handler prevents
     * memory leaks and makes the allocated memory available for
     * Garbage Collection.
     *
     * @param {?} events            List of Interruptive Events to remove
     * @param {?} listenerTarget    Target to attach the listener on
     * @param {?} handler           Handler for when the listener fires
     * @return {?} Void
     */
    function (events, listenerTarget, handler) {
        if (!listenerTarget)
            listenerTarget = window;
        events.forEach(function (event) { return listenerTarget.removeEventListener(event, handler); });
    };
    /**
     * Find the first scrollable parent Node of a given
     * Element. The DOM Tree gets searched upwards
     * to find this first scrollable parent. Parents might
     * be ignored by CSS styles applied to the HTML Element.
     *
     * @param {?} nativeElement     The Element to search the DOM Tree upwards from
     * @return {?} The first scrollable parent HTML Element
     */
    ScrollToService.prototype._getFirstScrollableParent = /**
     * Find the first scrollable parent Node of a given
     * Element. The DOM Tree gets searched upwards
     * to find this first scrollable parent. Parents might
     * be ignored by CSS styles applied to the HTML Element.
     *
     * @param {?} nativeElement     The Element to search the DOM Tree upwards from
     * @return {?} The first scrollable parent HTML Element
     */
    function (nativeElement) {
        var /** @type {?} */ style = window.getComputedStyle(nativeElement);
        var /** @type {?} */ overflowRegex = /(auto|scroll)/;
        if (style.position === 'fixed')
            return null;
        for (var /** @type {?} */ parent_1 = nativeElement; parent_1 = parent_1.parentElement; null) {
            style = window.getComputedStyle(parent_1);
            if (style.position === 'absolute'
                || style.overflow === 'hidden'
                || style.overflowY === 'hidden')
                continue;
            if (overflowRegex.test(style.overflow + style.overflowY + style.overflowX)
                || parent_1.tagName === 'BODY')
                return parent_1;
        }
        return null;
    };
    /**
     * Get the Target Node to scroll to.
     *
     * @param {?} id              The given ID of the node, either a string or
     *                        an element reference
     * @param {?=} allowBodyTag    Indicate whether or not the Document Body is
     *                        considered a valid Target Node
     * @return {?} The Target Node to scroll to
     */
    ScrollToService.prototype._getNode = /**
     * Get the Target Node to scroll to.
     *
     * @param {?} id              The given ID of the node, either a string or
     *                        an element reference
     * @param {?=} allowBodyTag    Indicate whether or not the Document Body is
     *                        considered a valid Target Node
     * @return {?} The Target Node to scroll to
     */
    function (id, allowBodyTag) {
        if (allowBodyTag === void 0) { allowBodyTag = false; }
        var /** @type {?} */ targetNode;
        if (isString(id)) {
            if (allowBodyTag && (id === 'body' || id === 'BODY')) {
                targetNode = this._document.body;
            }
            else {
                targetNode = this._document.getElementById(stripHash(id));
            }
        }
        else if (isNumber(id)) {
            targetNode = this._document.getElementById(String(id));
        }
        else if (isElementRef(id)) {
            targetNode = id.nativeElement;
        }
        else if (isNativeElement(id)) {
            targetNode = id;
        }
        return targetNode;
    };
    /**
     * Retrieve the Listener target. This Listener Target is used
     * to attach Event Listeners on. In case of the target being
     * the Document Body, we need the actual `window` to listen
     * for events.
     *
     * @param {?} container           The HTML Container element
     * @return {?} The Listener Target to attach events on
     */
    ScrollToService.prototype._getListenerTarget = /**
     * Retrieve the Listener target. This Listener Target is used
     * to attach Event Listeners on. In case of the target being
     * the Document Body, we need the actual `window` to listen
     * for events.
     *
     * @param {?} container           The HTML Container element
     * @return {?} The Listener Target to attach events on
     */
    function (container) {
        if (!container)
            return null;
        return this._isDocumentBody(container) ? window : container;
    };
    /**
     * Test if a given HTML Element is the Document Body.
     *
     * @param {?} element             The given HTML Element
     * @return {?} Whether or not the Element is the
     *                            Document Body Element
     */
    ScrollToService.prototype._isDocumentBody = /**
     * Test if a given HTML Element is the Document Body.
     *
     * @param {?} element             The given HTML Element
     * @return {?} Whether or not the Element is the
     *                            Document Body Element
     */
    function (element) {
        return element.tagName.toUpperCase() === 'BODY';
    };
    ScrollToService.decorators = [
        { type: Injectable },
    ];
    /** @nocollapse */
    ScrollToService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
        { type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
    ]; };
    return ScrollToService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ScrollToDirective = /** @class */ (function () {
    function ScrollToDirective(_elementRef, _scrollToService, _renderer2) {
        this._elementRef = _elementRef;
        this._scrollToService = _scrollToService;
        this._renderer2 = _renderer2;
        this.ngxScrollTo = DEFAULTS.target;
        this.ngxScrollToEvent = DEFAULTS.action;
        this.ngxScrollToDuration = DEFAULTS.duration;
        this.ngxScrollToEasing = DEFAULTS.easing;
        this.ngxScrollToOffset = DEFAULTS.offset;
        this.ngxScrollToOffsetMap = DEFAULTS.offsetMap;
    }
    /**
     * Angular Lifecycle Hook - After View Init
     *
     * \@todo Implement Subscription for Events
     *
     * @return {?} void
     */
    ScrollToDirective.prototype.ngAfterViewInit = /**
     * Angular Lifecycle Hook - After View Init
     *
     * \@todo Implement Subscription for Events
     *
     * @return {?} void
     */
    function () {
        var _this = this;
        // Test Event Support
        if (EVENTS.indexOf(this.ngxScrollToEvent) === -1)
            throw new Error("Unsupported Event '" + this.ngxScrollToEvent + "'");
        // Listen for the trigger...
        this._renderer2.listen(this._elementRef.nativeElement, this.ngxScrollToEvent, function (event) {
            _this._options = {
                target: _this.ngxScrollTo,
                duration: _this.ngxScrollToDuration,
                easing: _this.ngxScrollToEasing,
                offset: _this.ngxScrollToOffset,
                offsetMap: _this.ngxScrollToOffsetMap
            };
            _this._scrollToService.scrollTo(_this._options);
        });
    };
    ScrollToDirective.decorators = [
        { type: Directive, args: [{
                    selector: '[ngx-scroll-to]'
                },] },
    ];
    /** @nocollapse */
    ScrollToDirective.ctorParameters = function () { return [
        { type: ElementRef },
        { type: ScrollToService },
        { type: Renderer2 }
    ]; };
    ScrollToDirective.propDecorators = {
        ngxScrollTo: [{ type: Input, args: ['ngx-scroll-to',] }],
        ngxScrollToEvent: [{ type: Input, args: ['ngx-scroll-to-event',] }],
        ngxScrollToDuration: [{ type: Input, args: ['ngx-scroll-to-duration',] }],
        ngxScrollToEasing: [{ type: Input, args: ['ngx-scroll-to-easing',] }],
        ngxScrollToOffset: [{ type: Input, args: ['ngx-scroll-to-offset',] }],
        ngxScrollToOffsetMap: [{ type: Input, args: ['ngx-scroll-to-offset-map',] }]
    };
    return ScrollToDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ScrollToModule = /** @class */ (function () {
    function ScrollToModule() {
    }
    /**
     * Guaranteed singletons for provided Services across App.
     *
     * @return          An Angular Module with Providers
     */
    /**
     * Guaranteed singletons for provided Services across App.
     *
     * @return {?} An Angular Module with Providers
     */
    ScrollToModule.forRoot = /**
     * Guaranteed singletons for provided Services across App.
     *
     * @return {?} An Angular Module with Providers
     */
    function () {
        return {
            ngModule: ScrollToModule,
            providers: [
                ScrollToService
            ]
        };
    };
    ScrollToModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [
                        ScrollToDirective
                    ],
                    exports: [
                        ScrollToDirective
                    ]
                },] },
    ];
    return ScrollToModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

export { ScrollToModule, ScrollToService, ScrollToDirective as Éµa };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmlja3ktbGVuYWVycy1uZ3gtc2Nyb2xsLXRvLmpzLm1hcCIsInNvdXJjZXMiOlsibmc6Ly9Abmlja3ktbGVuYWVycy9uZ3gtc2Nyb2xsLXRvL3NyYy9hcHAvbW9kdWxlcy9zY3JvbGwtdG8vc3RhdGljcy9zY3JvbGwtdG8taGVscGVycy50cyIsIm5nOi8vQG5pY2t5LWxlbmFlcnMvbmd4LXNjcm9sbC10by9zcmMvYXBwL21vZHVsZXMvc2Nyb2xsLXRvL3N0YXRpY3Mvc2Nyb2xsLXRvLWFuaW1hdGlvbi50cyIsIm5nOi8vQG5pY2t5LWxlbmFlcnMvbmd4LXNjcm9sbC10by9zcmMvYXBwL21vZHVsZXMvc2Nyb2xsLXRvL3Njcm9sbC10by5zZXJ2aWNlLnRzIiwibmc6Ly9Abmlja3ktbGVuYWVycy9uZ3gtc2Nyb2xsLXRvL3NyYy9hcHAvbW9kdWxlcy9zY3JvbGwtdG8vc2Nyb2xsLXRvLmRpcmVjdGl2ZS50cyIsIm5nOi8vQG5pY2t5LWxlbmFlcnMvbmd4LXNjcm9sbC10by9zcmMvYXBwL21vZHVsZXMvc2Nyb2xsLXRvL3Njcm9sbC10by5tb2R1bGUudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRWxlbWVudFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuaW1wb3J0IHtcclxuICBTY3JvbGxUb0FuaW1hdGlvbkVhc2luZyxcclxuICBTY3JvbGxUb0FuaW1hdGlvbkVhc2luZ0NvbGxlY3Rpb25cclxufSBmcm9tICcuLi9tb2RlbHMvc2Nyb2xsLXRvLWVhc2luZy5tb2RlbCc7XHJcbmltcG9ydCB7IFNjcm9sbFRvRXZlbnQgfSBmcm9tICcuLi9tb2RlbHMvc2Nyb2xsLXRvLWV2ZW50Lm1vZGVsJztcclxuaW1wb3J0IHtcclxuICBTY3JvbGxUb0NvbmZpZ09wdGlvbnMsXHJcbiAgU2Nyb2xsVG9EZWZhdWx0Q29uZmlnT3B0aW9uc1xyXG59IGZyb20gJy4uL21vZGVscy9zY3JvbGwtdG8tY29uZmlnLm1vZGVsJztcclxuXHJcbi8qKlxyXG4gKiBEZWZhdWx0IHZhbHVlcyBmb3IgQ29tcG9uZW50IElucHV0LlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IERFRkFVTFRTOiBTY3JvbGxUb0RlZmF1bHRDb25maWdPcHRpb25zID0ge1xyXG4gIHRhcmdldDogbnVsbCxcclxuICBhY3Rpb246ICdjbGljaycsXHJcbiAgZHVyYXRpb246IDY1MCxcclxuICBlYXNpbmc6ICdlYXNlSW5PdXRRdWFkJyxcclxuICBvZmZzZXQ6IDAsXHJcbiAgb2Zmc2V0TWFwOiBuZXcgTWFwKClcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFYXNpbmcgQ29sbGVjaXRvbi5cclxuICovXHJcbmV4cG9ydCBjb25zdCBFQVNJTkc6IFNjcm9sbFRvQW5pbWF0aW9uRWFzaW5nQ29sbGVjdGlvbiA9IHtcclxuICBlYXNlSW5RdWFkOiAodGltZTogbnVtYmVyKSA9PiB7XHJcbiAgICByZXR1cm4gdGltZSAqIHRpbWU7XHJcbiAgfSxcclxuICBlYXNlT3V0UXVhZDogKHRpbWU6IG51bWJlcikgPT4ge1xyXG4gICAgcmV0dXJuIHRpbWUgKiAoMiAtIHRpbWUpO1xyXG4gIH0sXHJcbiAgZWFzZUluT3V0UXVhZDogKHRpbWU6IG51bWJlcikgPT4ge1xyXG4gICAgcmV0dXJuIHRpbWUgPCAwLjUgPyAyICogdGltZSAqIHRpbWUgOiAtMSArICg0IC0gMiAqIHRpbWUpICogdGltZTtcclxuICB9LFxyXG4gIGVhc2VJbkN1YmljOiAodGltZTogbnVtYmVyKSA9PiB7XHJcbiAgICByZXR1cm4gdGltZSAqIHRpbWUgKiB0aW1lO1xyXG4gIH0sXHJcbiAgZWFzZU91dEN1YmljOiAodGltZTogbnVtYmVyKSA9PiB7XHJcbiAgICByZXR1cm4gKC0tdGltZSkgKiB0aW1lICogdGltZSArIDE7XHJcbiAgfSxcclxuICBlYXNlSW5PdXRDdWJpYzogKHRpbWU6IG51bWJlcikgPT4ge1xyXG4gICAgcmV0dXJuIHRpbWUgPCAwLjUgPyA0ICogdGltZSAqIHRpbWUgKiB0aW1lIDogKHRpbWUgLSAxKSAqICgyICogdGltZSAtIDIpICogKDIgKiB0aW1lIC0gMikgKyAxO1xyXG4gIH0sXHJcbiAgZWFzZUluUXVhcnQ6ICh0aW1lOiBudW1iZXIpID0+IHtcclxuICAgIHJldHVybiB0aW1lICogdGltZSAqIHRpbWUgKiB0aW1lO1xyXG4gIH0sXHJcbiAgZWFzZU91dFF1YXJ0OiAodGltZTogbnVtYmVyKSA9PiB7XHJcbiAgICByZXR1cm4gMSAtICgtLXRpbWUpICogdGltZSAqIHRpbWUgKiB0aW1lO1xyXG4gIH0sXHJcbiAgZWFzZUluT3V0UXVhcnQ6ICh0aW1lOiBudW1iZXIpID0+IHtcclxuICAgIHJldHVybiB0aW1lIDwgMC41ID8gOCAqIHRpbWUgKiB0aW1lICogdGltZSAqIHRpbWUgOiAxIC0gOCAqICgtLXRpbWUpICogdGltZSAqIHRpbWUgKiB0aW1lO1xyXG4gIH0sXHJcbiAgZWFzZUluUXVpbnQ6ICh0aW1lOiBudW1iZXIpID0+IHtcclxuICAgIHJldHVybiB0aW1lICogdGltZSAqIHRpbWUgKiB0aW1lICogdGltZTtcclxuICB9LFxyXG4gIGVhc2VPdXRRdWludDogKHRpbWU6IG51bWJlcikgPT4ge1xyXG4gICAgcmV0dXJuIDEgKyAoLS10aW1lKSAqIHRpbWUgKiB0aW1lICogdGltZSAqIHRpbWU7XHJcbiAgfSxcclxuICBlYXNlSW5PdXRRdWludDogKHRpbWU6IG51bWJlcikgPT4ge1xyXG4gICAgcmV0dXJuIHRpbWUgPCAwLjUgPyAxNiAqIHRpbWUgKiB0aW1lICogdGltZSAqIHRpbWUgKiB0aW1lIDogMSArIDE2ICogKC0tdGltZSkgKiB0aW1lICogdGltZSAqIHRpbWUgKiB0aW1lO1xyXG4gIH0sXHJcbiAgZWFzZU91dEVsYXN0aWM6ICh0aW1lOiBudW1iZXIpID0+IHtcclxuICAgIHJldHVybiBNYXRoLnBvdygyLCAtMTAgKiB0aW1lKSAqIE1hdGguc2luKCh0aW1lIC0gMSAvIDQpICogKDIgKiBNYXRoLlBJKSAvIDEpICsgMTtcclxuICB9XHJcbn07XHJcblxyXG4vKipcclxuICogU2V0IG9mIGFsbG93ZWQgZXZlbnRzIGFzIHRyaWdnZXJzXHJcbiAqIGZvciB0aGUgQW5pbWF0aW9uIHRvIHN0YXJ0LlxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IEVWRU5UUzogc3RyaW5nW10gPSBbXHJcbiAgJ2NsaWNrJyxcclxuICAnbW91c2VlbnRlcicsXHJcbiAgJ21vdXNlb3ZlcicsXHJcbiAgJ21vdXNlZG93bicsXHJcbiAgJ21vdXNldXAnLFxyXG4gICdkYmxjbGljaycsXHJcbiAgJ2NvbnRleHRtZW51JyxcclxuICAnd2hlZWwnLFxyXG4gICdtb3VzZWxlYXZlJyxcclxuICAnbW91c2VvdXQnXHJcbl07XHJcblxyXG4vKipcclxuICogU3RyaXAgaGFzaCAoIykgZnJvbSB2YWx1ZS5cclxuICpcclxuICogQHBhcmFtIHZhbHVlIFx0XHRcdFx0VGhlIGdpdmVuIHN0cmluZyB2YWx1ZVxyXG4gKiBAcmV0dXJucyBcdFx0XHRcdFx0VGhlIHN0cmlwcGVkIHN0cmluZyB2YWx1ZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHN0cmlwSGFzaCh2YWx1ZTogc3RyaW5nKTogc3RyaW5nIHtcclxuICByZXR1cm4gdmFsdWUuc3Vic3RyaW5nKDAsIDEpID09PSAnIycgPyB2YWx1ZS5zdWJzdHJpbmcoMSkgOiB2YWx1ZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRlc3QgaWYgYSBnaXZlbiB2YWx1ZSBpcyBhIHN0cmluZy5cclxuICpcclxuICogQHBhcmFtIHZhbHVlIFx0XHRcdFx0XHRUaGUgZ2l2ZW4gdmFsdWVcclxuICogQHJldHVybnMgXHRcdFx0XHRcdFx0V2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBzdHJpbmdcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZTogYW55KTogdmFsdWUgaXMgc3RyaW5nIHtcclxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZztcclxufVxyXG5cclxuLyoqXHJcbiAqIFRlc3QgaWYgYSBnaXZlbiBFbGVtZW50IGlzIHRoZSBXaW5kb3cuXHJcbiAqXHJcbiAqIEBwYXJhbSBjb250YWluZXIgXHRcdFx0XHRUaGUgZ2l2ZW4gRWxlbWVudFxyXG4gKiBAcmV0dXJucyBcdFx0XHRcdFx0XHRXaGV0aGVyIHRoZSBnaXZlbiBFbGVtZW50IGlzIFdpbmRvd1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzV2luZG93KGNvbnRhaW5lcjogYW55KTogY29udGFpbmVyIGlzIFdpbmRvdyB7XHJcbiAgcmV0dXJuIGNvbnRhaW5lciA9PT0gd2luZG93O1xyXG59XHJcblxyXG4vKipcclxuICogVGVzdCBpZiBhIGdpdmVuIHZhbHVlIGlzIG9mIHR5cGUgRWxlbWVudFJlZi5cclxuICpcclxuICogQHBhcmFtIHZhbHVlIFx0XHRcdFx0XHRUaGUgZ2l2ZW4gdmFsdWVcclxuICogQHJldHVybnMgICAgICAgICAgICAgICBXaGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIG51bWJlclxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGlzRWxlbWVudFJlZih2YWx1ZTogYW55KTogdmFsdWUgaXMgRWxlbWVudFJlZiB7XHJcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRWxlbWVudFJlZjtcclxufVxyXG5cclxuLyoqXHJcbiAqIFdoZXRoZXIgb3Igbm90IHRoZSBnaXZlbiB2YWx1ZSBpcyBhIE5hdGl2ZSBFbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0gdmFsdWUgICAgICAgICAgIFRoZSBnaXZlbiB2YWx1ZVxyXG4gKiBAcmV0dXJucyAgICAgICAgICAgICAgIFdoZXRoZXIgb3Igbm90IHRoZSB2YWx1ZSBpcyBhIE5hdGl2ZSBFbGVtZW50XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNOYXRpdmVFbGVtZW50KHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBIVE1MRWxlbWVudCB7XHJcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBUZXN0IGlmIGEgZ2l2ZW4gdmFsdWUgaXMgdHlwZSBudW1iZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSB2YWx1ZSBcdFx0XHRcdFx0VGhlIGdpdmVuIHZhbHVlXHJcbiAqIEByZXR1cm5zIFx0XHRcdFx0XHRcdFdoZXRoZXIgdGhlIGdpdmVuIHZhbHVlIGlzIGEgbnVtYmVyXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gaXNOdW1iZXIodmFsdWU6IGFueSk6IHZhbHVlIGlzIG51bWJlciB7XHJcbiAgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KHZhbHVlKSkgJiYgaXNGaW5pdGUodmFsdWUpO1xyXG59XHJcbiIsImltcG9ydCB7IE9ic2VydmFibGUsIFJlcGxheVN1YmplY3QgfSBmcm9tICdyeGpzL2luZGV4JztcclxuXHJcbmltcG9ydCB7IEVBU0lORyB9IGZyb20gJy4uL3N0YXRpY3Mvc2Nyb2xsLXRvLWhlbHBlcnMnO1xyXG5pbXBvcnQge1xyXG4gIFNjcm9sbFRvQ29uZmlnT3B0aW9ucyxcclxuICBTY3JvbGxUb0xpc3RlbmVyVGFyZ2V0XHJcbn0gZnJvbSAnLi4vbW9kZWxzL3Njcm9sbC10by1jb25maWcubW9kZWwnO1xyXG5cclxuLyoqXHJcbiAqIFNjcm9sbCBUbyBBbmltYXRpb24uXHJcbiAqL1xyXG5leHBvcnQgY2xhc3MgU2Nyb2xsVG9BbmltYXRpb24ge1xyXG5cclxuICAvKipcclxuICAgKiBOdW1iZXIgb2YgbWlsbGlzZWNvbmRzIGZvciBlYWNoIFRpY2suXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfdGljazogbnVtYmVyO1xyXG5cclxuICAvKipcclxuICAgKiBKYXZhU2NyaXB0IEludGVydmFsLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgX2ludGVydmFsOiBhbnk7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRpbWUgTGFwc2VkIGluIG1pbGxpc2Vjb25kcy5cclxuICAgKi9cclxuICBwcml2YXRlIF90aW1lTGFwc2VkOiBudW1iZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIFBlcmNlbnRhZ2Ugb2YgdGltZSBsYXBzZWQuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfcGVyY2VudGFnZTogbnVtYmVyO1xyXG5cclxuICAvKipcclxuICAgKiBQb3NpdGlvbiBvZiB0aGUgRWxlbWVudC5cclxuICAgKi9cclxuICBwcml2YXRlIF9wb3NpdGlvbjogbnVtYmVyO1xyXG5cclxuICAvKipcclxuICAgKiBMYXN0IFBvc2l0aW9uLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgX2xhc3RQb3NpdGlvbjogbnVtYmVyO1xyXG5cclxuICAvKipcclxuICAgKiBTdGFydCBQb3NpdGlvbiBvZiB0aGUgRWxlbWVudC5cclxuICAgKi9cclxuICBwcml2YXRlIF9zdGFydFBvc2l0aW9uOiBudW1iZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoZSBEaXN0YW5jZSB0byBzY3JvbGwuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfZGlzdGFuY2U6IG51bWJlcjtcclxuXHJcbiAgLyoqXHJcbiAgICogT2JzZXJ2YWJsZSBTb3VyY2UuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfc291cmNlJDogUmVwbGF5U3ViamVjdDxudW1iZXI+O1xyXG5cclxuICAvKipcclxuICAgKiBTY3JvbGwgVG9wIG9mIHRoZSBXaW5kb3cuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfd2luZG93U2Nyb2xsVG9wOiBudW1iZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIE1hcHBlZCBPZmZzZXQgdGFrZW4gZnJvbSB0aGUgYWN0aXZlIE9mZnNldCBNYXAuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfbWFwcGVkT2Zmc2V0OiBudW1iZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIENsYXNzIENvbnN0cnVjdG9yLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIF9jb250YWluZXIgICAgICAgICAgICBUaGUgQ29udGFpbmVyXHJcbiAgICogQHBhcmFtIF9saXN0ZW5lclRhcmdldCAgICAgICBUaGUgRWxlbWVudCB0aGF0IGxpc3RlbnMgZm9yIERPTSBFdmVudHNcclxuICAgKiBAcGFyYW0gX2lzV2luZG93ICAgICAgICAgICAgIFdoZXRoZXIgb3Igbm90IHRoZSBsaXN0ZW5lciBpcyB0aGUgV2luZG93XHJcbiAgICogQHBhcmFtIF90byAgICAgICAgICAgICAgICAgICBQb3NpdGlvbiB0byBzY3JvbGwgdG9cclxuICAgKiBAcGFyYW0gX29wdGlvbnMgICAgICAgICAgICAgIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3Igc2Nyb2xsaW5nXHJcbiAgICogQHBhcmFtIF9pc0Jyb3dzZXIgICAgICAgICAgICBXaGV0aGVyIG9yIG5vdCBleGVjdXRpb24gcnVucyBpbiB0aGUgYnJvd3NlclxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGFzIG9wcG9zZWQgdG8gdGhlIHNlcnZlcilcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHByaXZhdGUgX2NvbnRhaW5lcjogSFRNTEVsZW1lbnQsXHJcbiAgICBwcml2YXRlIF9saXN0ZW5lclRhcmdldDogU2Nyb2xsVG9MaXN0ZW5lclRhcmdldCxcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgX2lzV2luZG93OiBib29sZWFuLFxyXG4gICAgcHJpdmF0ZSByZWFkb25seSBfdG86IG51bWJlcixcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgX29wdGlvbnM6IFNjcm9sbFRvQ29uZmlnT3B0aW9ucyxcclxuICAgIHByaXZhdGUgX2lzQnJvd3NlcjogYm9vbGVhblxyXG4gICkge1xyXG4gICAgdGhpcy5fdGljayA9IDE2O1xyXG4gICAgdGhpcy5faW50ZXJ2YWwgPSBudWxsO1xyXG4gICAgdGhpcy5fbGFzdFBvc2l0aW9uID0gbnVsbDtcclxuICAgIHRoaXMuX3RpbWVMYXBzZWQgPSAwO1xyXG5cclxuICAgIHRoaXMuX3dpbmRvd1Njcm9sbFRvcCA9IHdpbmRvdy5wYWdlWU9mZnNldCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wIHx8IDA7XHJcblxyXG4gICAgaWYgKCF0aGlzLl9jb250YWluZXIpIHtcclxuICAgICAgdGhpcy5fc3RhcnRQb3NpdGlvbiA9IHRoaXMuX3dpbmRvd1Njcm9sbFRvcDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX3N0YXJ0UG9zaXRpb24gPSB0aGlzLl9pc1dpbmRvdyA/IHRoaXMuX3dpbmRvd1Njcm9sbFRvcCA6IHRoaXMuX2NvbnRhaW5lci5zY3JvbGxUb3A7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29ycmVjdGlvbiBmb3IgU3RhcnRpbmcgUG9zaXRpb24gb2YgbmVzdGVkIEhUTUwgRWxlbWVudHNcclxuICAgIGlmICh0aGlzLl9jb250YWluZXIgJiYgIXRoaXMuX2lzV2luZG93KSB7XHJcbiAgICAgIHRoaXMuX3RvID0gdGhpcy5fdG8gLSB0aGlzLl9jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wICsgdGhpcy5fc3RhcnRQb3NpdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTZXQgRGlzdGFuY2VcclxuICAgIGNvbnN0IGRpcmVjdGlvbmFsRGlzdGFuY2UgPSB0aGlzLl9zdGFydFBvc2l0aW9uIC0gdGhpcy5fdG87XHJcbiAgICB0aGlzLl9kaXN0YW5jZSA9IHRoaXMuX2NvbnRhaW5lciA/IE1hdGguYWJzKHRoaXMuX3N0YXJ0UG9zaXRpb24gLSB0aGlzLl90bykgOiB0aGlzLl90bztcclxuXHJcbiAgICB0aGlzLl9tYXBwZWRPZmZzZXQgPSB0aGlzLl9vcHRpb25zLm9mZnNldDtcclxuXHJcbiAgICAvLyBTZXQgb2Zmc2V0IGZyb20gT2Zmc2V0IE1hcFxyXG4gICAgaWYgKHRoaXMuX2lzQnJvd3Nlcikge1xyXG4gICAgICB0aGlzLl9vcHRpb25zXHJcbiAgICAgICAgLm9mZnNldE1hcFxyXG4gICAgICAgIC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB0aGlzLl9tYXBwZWRPZmZzZXQgPSB3aW5kb3cuaW5uZXJXaWR0aCA+IGtleSA/IHZhbHVlIDogdGhpcy5fbWFwcGVkT2Zmc2V0KTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9kaXN0YW5jZSArPSB0aGlzLl9tYXBwZWRPZmZzZXQgKiAoZGlyZWN0aW9uYWxEaXN0YW5jZSA8PSAwID8gMSA6IC0xKTtcclxuICAgIHRoaXMuX3NvdXJjZSQgPSBuZXcgUmVwbGF5U3ViamVjdCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RhcnQgdGhlIG5ldyBTY3JvbGwgQW5pbWF0aW9uLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMgICAgICAgICBPYnNlcnZhYmxlIGNvbnRhaW5pbmcgYSBudW1iZXJcclxuICAgKi9cclxuICBwdWJsaWMgc3RhcnQoKTogT2JzZXJ2YWJsZTxudW1iZXI+IHtcclxuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpO1xyXG4gICAgdGhpcy5faW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCh0aGlzLl9sb29wLCB0aGlzLl90aWNrKTtcclxuICAgIHJldHVybiB0aGlzLl9zb3VyY2UkLmFzT2JzZXJ2YWJsZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVjdXJzaXZlbHkgbG9vcCBvdmVyIHRoZSBTY3JvbGwgQW5pbWF0aW9uLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMgICAgICAgICAgIFZvaWRcclxuICAgKi9cclxuICBwcml2YXRlIF9sb29wID0gKCk6IHZvaWQgPT4ge1xyXG5cclxuICAgIHRoaXMuX3RpbWVMYXBzZWQgKz0gdGhpcy5fdGljaztcclxuICAgIHRoaXMuX3BlcmNlbnRhZ2UgPSAodGhpcy5fdGltZUxhcHNlZCAvIHRoaXMuX29wdGlvbnMuZHVyYXRpb24pO1xyXG4gICAgdGhpcy5fcGVyY2VudGFnZSA9ICh0aGlzLl9wZXJjZW50YWdlID4gMSkgPyAxIDogdGhpcy5fcGVyY2VudGFnZTtcclxuXHJcbiAgICAvLyBQb3NpdGlvbiBVcGRhdGVcclxuICAgIHRoaXMuX3Bvc2l0aW9uID0gdGhpcy5fc3RhcnRQb3NpdGlvbiArXHJcbiAgICAgICgodGhpcy5fc3RhcnRQb3NpdGlvbiAtIHRoaXMuX3RvIDw9IDAgPyAxIDogLTEpICpcclxuICAgICAgICB0aGlzLl9kaXN0YW5jZSAqXHJcbiAgICAgICAgRUFTSU5HW3RoaXMuX29wdGlvbnMuZWFzaW5nXSh0aGlzLl9wZXJjZW50YWdlKSk7XHJcblxyXG4gICAgaWYgKHRoaXMuX2xhc3RQb3NpdGlvbiAhPT0gbnVsbCAmJiB0aGlzLl9wb3NpdGlvbiA9PT0gdGhpcy5fbGFzdFBvc2l0aW9uKSB7XHJcbiAgICAgIHRoaXMuc3RvcCgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5fc291cmNlJC5uZXh0KHRoaXMuX3Bvc2l0aW9uKTtcclxuICAgICAgdGhpcy5faXNXaW5kb3dcclxuICAgICAgICA/IHRoaXMuX2xpc3RlbmVyVGFyZ2V0LnNjcm9sbFRvKDAsIE1hdGguZmxvb3IodGhpcy5fcG9zaXRpb24pKVxyXG4gICAgICAgIDogdGhpcy5fY29udGFpbmVyLnNjcm9sbFRvcCA9IE1hdGguZmxvb3IodGhpcy5fcG9zaXRpb24pO1xyXG4gICAgICB0aGlzLl9sYXN0UG9zaXRpb24gPSB0aGlzLl9wb3NpdGlvbjtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0b3AgdGhlIGN1cnJlbnQgU2Nyb2xsIEFuaW1hdGlvbiBMb29wLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGZvcmNlIFx0XHRcdCAgICBGb3JjZSB0byBzdG9wIHRoZSBBbmltYXRpb24gTG9vcFxyXG4gICAqIEByZXR1cm5zICAgICAgICAgICAgICAgVm9pZFxyXG4gICAqL1xyXG4gIHB1YmxpYyBzdG9wKCk6IHZvaWQge1xyXG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbCk7XHJcbiAgICB0aGlzLl9pbnRlcnZhbCA9IG51bGw7XHJcbiAgICB0aGlzLl9zb3VyY2UkLmNvbXBsZXRlKCk7XHJcbiAgfVxyXG59XHJcbiIsImltcG9ydCB7IEluamVjdGFibGUsIFBMQVRGT1JNX0lELCBJbmplY3QgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgRE9DVU1FTlQgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xyXG5pbXBvcnQgeyBpc1BsYXRmb3JtQnJvd3NlciB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbic7XHJcblxyXG5pbXBvcnQge1xyXG4gIFNjcm9sbFRvQ29uZmlnT3B0aW9ucyxcclxuICBTY3JvbGxUb1RhcmdldCxcclxuICBTY3JvbGxUb0xpc3RlbmVyVGFyZ2V0LFxyXG4gIFNjcm9sbFRvQ29uZmlnT3B0aW9uc1RhcmdldFxyXG59IGZyb20gJy4vbW9kZWxzL3Njcm9sbC10by1jb25maWcubW9kZWwnO1xyXG5pbXBvcnQgeyBTY3JvbGxUb0FuaW1hdGlvbiB9IGZyb20gJy4vc3RhdGljcy9zY3JvbGwtdG8tYW5pbWF0aW9uJztcclxuaW1wb3J0IHtcclxuICBzdHJpcEhhc2gsXHJcbiAgaXNTdHJpbmcsXHJcbiAgaXNOdW1iZXIsXHJcbiAgaXNFbGVtZW50UmVmLFxyXG4gIGlzV2luZG93LFxyXG4gIERFRkFVTFRTLFxyXG4gIGlzTmF0aXZlRWxlbWVudFxyXG59IGZyb20gJy4vc3RhdGljcy9zY3JvbGwtdG8taGVscGVycyc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUsIFJlcGxheVN1YmplY3QsIHRocm93RXJyb3IgfSBmcm9tICdyeGpzL2luZGV4JztcclxuXHJcbi8qKlxyXG4gKiBUaGUgU2Nyb2xsVG9TZXJ2aWNlIGhhbmRsZXMgc3RhcnRpbmcsIGludGVycnVwdGluZ1xyXG4gKiBhbmQgZW5kaW5nIHRoZSBhY3R1YWwgU2Nyb2xsIEFuaW1hdGlvbi4gSXQgcHJvdmlkZXNcclxuICogc29tZSB1dGlsaXRpZXMgdG8gZmluZCB0aGUgcHJvcGVyIEhUTUwgRWxlbWVudCBvbiBhXHJcbiAqIGdpdmVuIHBhZ2UgdG8gc2V0dXAgRXZlbnQgTGlzdGVuZXJzIGFuZCBjYWxjdWxhdGVcclxuICogZGlzdGFuY2VzIGZvciB0aGUgQW5pbWF0aW9uLlxyXG4gKi9cclxuQEluamVjdGFibGUoKVxyXG5leHBvcnQgY2xhc3MgU2Nyb2xsVG9TZXJ2aWNlIHtcclxuXHJcbiAgLyoqXHJcbiAgICogVGhlIGFuaW1hdGlvbiB0aGF0IHByb3ZpZGVzIHRoZSBzY3JvbGxpbmdcclxuICAgKiB0byBoYXBwZW4gc21vb3RobHkgb3ZlciB0aW1lLiBEZWZpbmluZyBpdCBoZXJlXHJcbiAgICogYWxsb3dzIGZvciB1c2FnZSBvZiBlLmcuIGBzdGFydGAgYW5kIGBzdG9wYFxyXG4gICAqIG1ldGhvZHMgd2l0aGluIHRoaXMgQW5ndWxhciBTZXJ2aWNlLlxyXG4gICAqL1xyXG4gIHByaXZhdGUgX2FuaW1hdGlvbjogU2Nyb2xsVG9BbmltYXRpb247XHJcblxyXG4gIC8qKlxyXG4gICAqIEludGVycnVwdGl2ZSBFdmVudHMgYWxsb3cgdG8gc2Nyb2xsaW5nIGFuaW1hdGlvblxyXG4gICAqIHRvIGJlIGludGVycnVwdGVkIGJlZm9yZSBpdCBpcyBmaW5pc2hlZC4gVGhlIGxpc3RcclxuICAgKiBvZiBJbnRlcnJ1cHRpdmUgRXZlbnRzIHJlcHJlc2VudHMgdGhvc2UuXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfaW50ZXJydXB0aXZlRXZlbnRzOiBzdHJpbmdbXTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3RydWN0IGFuZCBzZXR1cCByZXF1aXJlZCBwYXJhdGVtZXRlcnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gX2RvY3VtZW50ICAgICAgICAgQSBSZWZlcmVuY2UgdG8gdGhlIERvY3VtZW50XHJcbiAgICogQHBhcmFtIF9wbGF0Zm9ybUlkICAgICAgIEFuZ3VsYXIgUGxhdGZvcm0gSURcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIEBJbmplY3QoRE9DVU1FTlQpIHByaXZhdGUgX2RvY3VtZW50OiBhbnksXHJcbiAgICBASW5qZWN0KFBMQVRGT1JNX0lEKSBwcml2YXRlIF9wbGF0Zm9ybUlkOiBhbnlcclxuICApIHtcclxuICAgIHRoaXMuX2ludGVycnVwdGl2ZUV2ZW50cyA9IFsnbW91c2V3aGVlbCcsICdET01Nb3VzZVNjcm9sbCcsICd0b3VjaHN0YXJ0J107XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUYXJnZXQgYW4gRWxlbWVudCB0byBzY3JvbGwgdG8uIE5vdGljZSB0aGF0IHRoZSBgVGltZU91dGAgZGVjb3JhdG9yXHJcbiAgICogZW5zdXJlcyB0aGUgZXhlY3V0aW5nIHRvIHRha2UgcGxhY2UgaW4gdGhlIG5leHQgQW5ndWxhciBsaWZlY3ljbGUuXHJcbiAgICogVGhpcyBhbGxvd3MgZm9yIHNjcm9sbGluZyB0byBlbGVtZW50cyB0aGF0IGFyZSBlLmcuIGluaXRpYWxseSBoaWRkZW5cclxuICAgKiBieSBtZWFucyBvZiBgKm5nSWZgLCBidXQgb3VnaHQgdG8gYmUgc2Nyb2xsZWQgdG8gZXZlbnR1YWxseS5cclxuICAgKlxyXG4gICAqIEB0b2RvIHR5cGUgJ2FueScgaW4gT2JzZXJ2YWJsZSBzaG91bGQgYmVjb21lIGN1c3RvbSB0eXBlIGxpa2UgJ1Njcm9sbFRvRXZlbnQnIChiYXNlIGNsYXNzKSwgc2VlIGlzc3VlIGNvbW1lbnQ6XHJcbiAgICogXHQtIGh0dHBzOi8vZ2l0aHViLmNvbS9uaWNreS1sZW5hZXJzL25neC1zY3JvbGwtdG8vaXNzdWVzLzEwI2lzc3VlY29tbWVudC0zMTcxOTg0ODFcclxuICAgKlxyXG4gICAqIEBwYXJhbSBvcHRpb25zICAgICAgICAgQ29uZmlndXJhdGlvbiBPYmplY3RcclxuICAgKiBAcmV0dXJucyAgICAgICAgICAgICAgIE9ic2VydmFibGVcclxuICAgKi9cclxuICBwdWJsaWMgc2Nyb2xsVG8ob3B0aW9uczogU2Nyb2xsVG9Db25maWdPcHRpb25zKTogT2JzZXJ2YWJsZTxhbnk+IHtcclxuXHJcbiAgICBpZiAoIWlzUGxhdGZvcm1Ccm93c2VyKHRoaXMuX3BsYXRmb3JtSWQpKSByZXR1cm4gbmV3IFJlcGxheVN1YmplY3QoKS5hc09ic2VydmFibGUoKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5fc3RhcnQob3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdGFydCBhIG5ldyBBbmltYXRpb24uXHJcbiAgICpcclxuICAgKiBAdG9kbyBFbWl0IHByb3BlciBldmVudHMgZnJvbSBzdWJzY3JpcHRpb25cclxuICAgKlxyXG4gICAqIEBwYXJhbSBvcHRpb25zICAgICAgICAgQ29uZmlndXJhdGlvbiBPYmplY3RcclxuICAgKiBAcmV0dXJucyAgICAgICAgICAgICAgIE9ic2VydmFibGVcclxuICAgKi9cclxuICBwcml2YXRlIF9zdGFydChvcHRpb25zOiBTY3JvbGxUb0NvbmZpZ09wdGlvbnMpOiBPYnNlcnZhYmxlPG51bWJlcj4ge1xyXG5cclxuICAgIC8vIE1lcmdlIGNvbmZpZyB3aXRoIGRlZmF1bHQgdmFsdWVzXHJcbiAgICBjb25zdCBtZXJnZWRDb25maWdPcHRpb25zID0ge1xyXG4gICAgICAuLi5ERUZBVUxUUyBhcyBTY3JvbGxUb0NvbmZpZ09wdGlvbnMsXHJcbiAgICAgIC4uLm9wdGlvbnNcclxuICAgIH0gYXMgU2Nyb2xsVG9Db25maWdPcHRpb25zVGFyZ2V0O1xyXG5cclxuICAgIGlmICh0aGlzLl9hbmltYXRpb24pIHRoaXMuX2FuaW1hdGlvbi5zdG9wKCk7XHJcblxyXG4gICAgY29uc3QgdGFyZ2V0Tm9kZSA9IHRoaXMuX2dldE5vZGUobWVyZ2VkQ29uZmlnT3B0aW9ucy50YXJnZXQpO1xyXG4gICAgaWYgKG1lcmdlZENvbmZpZ09wdGlvbnMudGFyZ2V0ICYmICF0YXJnZXROb2RlKSByZXR1cm4gdGhyb3dFcnJvcignVW5hYmxlIHRvIGZpbmQgVGFyZ2V0IEVsZW1lbnQnKTtcclxuXHJcbiAgICBjb25zdCBjb250YWluZXI6IEhUTUxFbGVtZW50ID0gdGhpcy5fZ2V0Q29udGFpbmVyKG1lcmdlZENvbmZpZ09wdGlvbnMsIHRhcmdldE5vZGUpO1xyXG4gICAgaWYgKG1lcmdlZENvbmZpZ09wdGlvbnMuY29udGFpbmVyICYmICFjb250YWluZXIpIHJldHVybiB0aHJvd0Vycm9yKCdVbmFibGUgdG8gZmluZCBDb250YWluZXIgRWxlbWVudCcpO1xyXG5cclxuICAgIGNvbnN0IGxpc3RlbmVyVGFyZ2V0ID0gdGhpcy5fZ2V0TGlzdGVuZXJUYXJnZXQoY29udGFpbmVyKSB8fCB3aW5kb3c7XHJcblxyXG4gICAgbGV0IHRvID0gY29udGFpbmVyID8gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCA6IDA7XHJcblxyXG4gICAgaWYgKHRhcmdldE5vZGUpIHtcclxuICAgICAgdG8gPSBpc1dpbmRvdyhsaXN0ZW5lclRhcmdldCkgPyB0YXJnZXROb2RlLm9mZnNldFRvcCA6IHRhcmdldE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENyZWF0ZSBBbmltYXRpb25cclxuICAgIHRoaXMuX2FuaW1hdGlvbiA9IG5ldyBTY3JvbGxUb0FuaW1hdGlvbihcclxuICAgICAgY29udGFpbmVyLFxyXG4gICAgICBsaXN0ZW5lclRhcmdldCxcclxuICAgICAgaXNXaW5kb3cobGlzdGVuZXJUYXJnZXQpLFxyXG4gICAgICB0byxcclxuICAgICAgbWVyZ2VkQ29uZmlnT3B0aW9ucyxcclxuICAgICAgaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5fcGxhdGZvcm1JZClcclxuICAgICk7XHJcbiAgICBjb25zdCBvbkludGVycnVwdCA9ICgpID0+IHRoaXMuX2FuaW1hdGlvbi5zdG9wKCk7XHJcbiAgICB0aGlzLl9hZGRJbnRlcnJ1cHRpdmVFdmVudExpc3RlbmVycyhsaXN0ZW5lclRhcmdldCwgb25JbnRlcnJ1cHQpO1xyXG5cclxuICAgIC8vIFN0YXJ0IEFuaW1hdGlvblxyXG4gICAgY29uc3QgYW5pbWF0aW9uJCA9IHRoaXMuX2FuaW1hdGlvbi5zdGFydCgpO1xyXG4gICAgdGhpcy5fc3Vic2NyaWJlVG9BbmltYXRpb24oYW5pbWF0aW9uJCwgbGlzdGVuZXJUYXJnZXQsIG9uSW50ZXJydXB0KTtcclxuXHJcbiAgICByZXR1cm4gYW5pbWF0aW9uJDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN1YnNjcmliZSB0byB0aGUgZXZlbnRzIGVtaXR0ZWQgZnJvbSB0aGUgU2Nyb2xsaW5nXHJcbiAgICogQW5pbWF0aW9uLiBFdmVudHMgbWlnaHQgYmUgdXNlZCBmb3IgZS5nLiB1bnN1YnNjcmliaW5nXHJcbiAgICogb25jZSBmaW5pc2hlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBhbmltYXRpb24kICAgICAgICAgICAgICBUaGUgQW5pbWF0aW9uIE9ic2VydmFibGVcclxuICAgKiBAcGFyYW0gbGlzdGVuZXJUYXJnZXQgICAgICAgICAgVGhlIExpc3RlbmVyIFRhcmdldCBmb3IgZXZlbnRzXHJcbiAgICogQHBhcmFtIG9uSW50ZXJydXB0ICAgICAgICAgICAgIFRoZSBoYW5kbGVyIGZvciBJbnRlcnJ1cHRpdmUgRXZlbnRzXHJcbiAgICogQHJldHVybnMgICAgICAgICAgICAgICAgICAgICAgIFZvaWRcclxuICAgKi9cclxuICBwcml2YXRlIF9zdWJzY3JpYmVUb0FuaW1hdGlvbihcclxuICAgICAgYW5pbWF0aW9uJDogT2JzZXJ2YWJsZTxhbnk+LFxyXG4gICAgICBsaXN0ZW5lclRhcmdldDogU2Nyb2xsVG9MaXN0ZW5lclRhcmdldCxcclxuICAgICAgb25JbnRlcnJ1cHQ6IEV2ZW50TGlzdGVuZXJPckV2ZW50TGlzdGVuZXJPYmplY3QpIHtcclxuICAgIGNvbnN0IHN1YnNjcmlwdGlvbiA9IGFuaW1hdGlvbiRcclxuICAgICAgLnN1YnNjcmliZShcclxuICAgICAgICAoKSA9PiB7IH0sXHJcbiAgICAgICAgKCkgPT4geyB9LFxyXG4gICAgICAgICgpID0+IHtcclxuICAgICAgICAgIHRoaXMuX3JlbW92ZUludGVycnVwdGl2ZUV2ZW50TGlzdGVuZXJzKHRoaXMuX2ludGVycnVwdGl2ZUV2ZW50cywgbGlzdGVuZXJUYXJnZXQsIG9uSW50ZXJydXB0KTtcclxuICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgY29udGFpbmVyIEhUTUwgRWxlbWVudCBpbiB3aGljaFxyXG4gICAqIHRoZSBzY3JvbGxpbmcgc2hvdWxkIGhhcHBlbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBvcHRpb25zICAgICAgICAgVGhlIE1lcmdlZCBDb25maWd1cmF0aW9uIE9iamVjdFxyXG4gICAqIEBwYXJhbSB0YXJnZXROb2RlICAgIHRoZSB0YXJnZXRlZCBIVE1MRWxlbWVudFxyXG4gICAqIEByZXR1cm5zXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfZ2V0Q29udGFpbmVyKG9wdGlvbnM6IFNjcm9sbFRvQ29uZmlnT3B0aW9ucywgdGFyZ2V0Tm9kZTogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudCB8IG51bGwge1xyXG5cclxuICAgIGxldCBjb250YWluZXI6IEhUTUxFbGVtZW50IHwgbnVsbCA9IG51bGw7XHJcblxyXG4gICAgaWYgKG9wdGlvbnMuY29udGFpbmVyKSB7XHJcbiAgICAgIGNvbnRhaW5lciA9IHRoaXMuX2dldE5vZGUob3B0aW9ucy5jb250YWluZXIsIHRydWUpO1xyXG4gICAgfSBlbHNlIGlmICh0YXJnZXROb2RlKSB7XHJcbiAgICAgIGNvbnRhaW5lciA9IHRoaXMuX2dldEZpcnN0U2Nyb2xsYWJsZVBhcmVudCh0YXJnZXROb2RlKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY29udGFpbmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIGxpc3RlbmVycyBmb3IgdGhlIEFuaW1hdGlvbiBJbnRlcnJ1cHRpdmUgRXZlbnRzXHJcbiAgICogdG8gdGhlIExpc3RlbmVyIFRhcmdldC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBldmVudHMgICAgICAgICAgICBMaXN0IG9mIGV2ZW50cyB0byBsaXN0ZW4gdG9cclxuICAgKiBAcGFyYW0gbGlzdGVuZXJUYXJnZXQgICAgVGFyZ2V0IHRvIGF0dGFjaCB0aGUgbGlzdGVuZXIgb25cclxuICAgKiBAcGFyYW0gaGFuZGxlciAgICAgICAgICAgSGFuZGxlciBmb3Igd2hlbiB0aGUgbGlzdGVuZXIgZmlyZXNcclxuICAgKiBAcmV0dXJucyAgICAgICAgICAgICAgICAgVm9pZFxyXG4gICAqL1xyXG4gIHByaXZhdGUgX2FkZEludGVycnVwdGl2ZUV2ZW50TGlzdGVuZXJzKFxyXG4gICAgbGlzdGVuZXJUYXJnZXQ6IFNjcm9sbFRvTGlzdGVuZXJUYXJnZXQsXHJcbiAgICBoYW5kbGVyOiBFdmVudExpc3RlbmVyT3JFdmVudExpc3RlbmVyT2JqZWN0KTogdm9pZCB7XHJcblxyXG4gICAgICBpZiAoIWxpc3RlbmVyVGFyZ2V0KSBsaXN0ZW5lclRhcmdldCA9IHdpbmRvdztcclxuXHJcbiAgICB0aGlzLl9pbnRlcnJ1cHRpdmVFdmVudHMuZm9yRWFjaChldmVudCA9PiBsaXN0ZW5lclRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmUgbGlzdGVuZXJzIGZvciB0aGUgQW5pbWF0aW9uIEludGVycnVwdCBFdmVudCBmcm9tXHJcbiAgICogdGhlIExpc3RlbmVyIFRhcmdldC4gU3BlY2lmeWluZyB0aGUgY29ycmVjdCBoYW5kbGVyIHByZXZlbnRzXHJcbiAgICogbWVtb3J5IGxlYWtzIGFuZCBtYWtlcyB0aGUgYWxsb2NhdGVkIG1lbW9yeSBhdmFpbGFibGUgZm9yXHJcbiAgICogR2FyYmFnZSBDb2xsZWN0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGV2ZW50cyAgICAgICAgICAgIExpc3Qgb2YgSW50ZXJydXB0aXZlIEV2ZW50cyB0byByZW1vdmVcclxuICAgKiBAcGFyYW0gbGlzdGVuZXJUYXJnZXQgICAgVGFyZ2V0IHRvIGF0dGFjaCB0aGUgbGlzdGVuZXIgb25cclxuICAgKiBAcGFyYW0gaGFuZGxlciAgICAgICAgICAgSGFuZGxlciBmb3Igd2hlbiB0aGUgbGlzdGVuZXIgZmlyZXNcclxuICAgKiBAcmV0dXJucyAgICAgICAgICAgICAgICAgVm9pZFxyXG4gICAqL1xyXG4gIHByaXZhdGUgX3JlbW92ZUludGVycnVwdGl2ZUV2ZW50TGlzdGVuZXJzKFxyXG4gICAgZXZlbnRzOiBzdHJpbmdbXSxcclxuICAgIGxpc3RlbmVyVGFyZ2V0OiBTY3JvbGxUb0xpc3RlbmVyVGFyZ2V0LFxyXG4gICAgaGFuZGxlcjogRXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdCk6IHZvaWQge1xyXG5cclxuICAgIGlmICghbGlzdGVuZXJUYXJnZXQpIGxpc3RlbmVyVGFyZ2V0ID0gd2luZG93O1xyXG4gICAgZXZlbnRzLmZvckVhY2goZXZlbnQgPT4gbGlzdGVuZXJUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlcikpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRmluZCB0aGUgZmlyc3Qgc2Nyb2xsYWJsZSBwYXJlbnQgTm9kZSBvZiBhIGdpdmVuXHJcbiAgICogRWxlbWVudC4gVGhlIERPTSBUcmVlIGdldHMgc2VhcmNoZWQgdXB3YXJkc1xyXG4gICAqIHRvIGZpbmQgdGhpcyBmaXJzdCBzY3JvbGxhYmxlIHBhcmVudC4gUGFyZW50cyBtaWdodFxyXG4gICAqIGJlIGlnbm9yZWQgYnkgQ1NTIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBIVE1MIEVsZW1lbnQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0gbmF0aXZlRWxlbWVudCAgICAgVGhlIEVsZW1lbnQgdG8gc2VhcmNoIHRoZSBET00gVHJlZSB1cHdhcmRzIGZyb21cclxuICAgKiBAcmV0dXJucyAgICAgICAgICAgICAgICAgVGhlIGZpcnN0IHNjcm9sbGFibGUgcGFyZW50IEhUTUwgRWxlbWVudFxyXG4gICAqL1xyXG4gIHByaXZhdGUgX2dldEZpcnN0U2Nyb2xsYWJsZVBhcmVudChuYXRpdmVFbGVtZW50OiBIVE1MRWxlbWVudCk6IEhUTUxFbGVtZW50IHtcclxuXHJcbiAgICBsZXQgc3R5bGU6IENTU1N0eWxlRGVjbGFyYXRpb24gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShuYXRpdmVFbGVtZW50KTtcclxuXHJcbiAgICBjb25zdCBvdmVyZmxvd1JlZ2V4OiBSZWdFeHAgPSAvKGF1dG98c2Nyb2xsKS87XHJcblxyXG4gICAgaWYgKHN0eWxlLnBvc2l0aW9uID09PSAnZml4ZWQnKSByZXR1cm4gbnVsbDtcclxuXHJcbiAgICBmb3IgKGxldCBwYXJlbnQgPSBuYXRpdmVFbGVtZW50OyBwYXJlbnQgPSBwYXJlbnQucGFyZW50RWxlbWVudDsgbnVsbCkge1xyXG5cclxuICAgICAgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwYXJlbnQpO1xyXG5cclxuICAgICAgaWYgKHN0eWxlLnBvc2l0aW9uID09PSAnYWJzb2x1dGUnXHJcbiAgICAgICAgfHwgc3R5bGUub3ZlcmZsb3cgPT09ICdoaWRkZW4nXHJcbiAgICAgICAgfHwgc3R5bGUub3ZlcmZsb3dZID09PSAnaGlkZGVuJykgY29udGludWU7XHJcblxyXG4gICAgICBpZiAob3ZlcmZsb3dSZWdleC50ZXN0KHN0eWxlLm92ZXJmbG93ICsgc3R5bGUub3ZlcmZsb3dZICsgc3R5bGUub3ZlcmZsb3dYKVxyXG4gICAgICAgIHx8IHBhcmVudC50YWdOYW1lID09PSAnQk9EWScpIHJldHVybiBwYXJlbnQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXQgdGhlIFRhcmdldCBOb2RlIHRvIHNjcm9sbCB0by5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBpZCAgICAgICAgICAgICAgVGhlIGdpdmVuIElEIG9mIHRoZSBub2RlLCBlaXRoZXIgYSBzdHJpbmcgb3JcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgIGFuIGVsZW1lbnQgcmVmZXJlbmNlXHJcbiAgICogQHBhcmFtIGFsbG93Qm9keVRhZyAgICBJbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGUgRG9jdW1lbnQgQm9keSBpc1xyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgY29uc2lkZXJlZCBhIHZhbGlkIFRhcmdldCBOb2RlXHJcbiAgICogQHJldHVybnMgICAgICAgICAgICAgICBUaGUgVGFyZ2V0IE5vZGUgdG8gc2Nyb2xsIHRvXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfZ2V0Tm9kZShpZDogU2Nyb2xsVG9UYXJnZXQsIGFsbG93Qm9keVRhZzogYm9vbGVhbiA9IGZhbHNlKTogSFRNTEVsZW1lbnQge1xyXG5cclxuICAgIGxldCB0YXJnZXROb2RlOiBIVE1MRWxlbWVudDtcclxuXHJcbiAgICBpZiAoaXNTdHJpbmcoaWQpKSB7XHJcblxyXG4gICAgICBpZiAoYWxsb3dCb2R5VGFnICYmIChpZCA9PT0gJ2JvZHknIHx8IGlkID09PSAnQk9EWScpKSB7XHJcblxyXG4gICAgICAgIHRhcmdldE5vZGUgPSB0aGlzLl9kb2N1bWVudC5ib2R5O1xyXG5cclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgdGFyZ2V0Tm9kZSA9IHRoaXMuX2RvY3VtZW50LmdldEVsZW1lbnRCeUlkKHN0cmlwSGFzaChpZCkpO1xyXG5cclxuICAgICAgfVxyXG5cclxuICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoaWQpKSB7XHJcblxyXG4gICAgICB0YXJnZXROb2RlID0gdGhpcy5fZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoU3RyaW5nKGlkKSk7XHJcblxyXG4gICAgfSBlbHNlIGlmIChpc0VsZW1lbnRSZWYoaWQpKSB7XHJcblxyXG4gICAgICB0YXJnZXROb2RlID0gaWQubmF0aXZlRWxlbWVudDtcclxuXHJcbiAgICB9IGVsc2UgaWYgKGlzTmF0aXZlRWxlbWVudChpZCkpIHtcclxuXHJcbiAgICAgIHRhcmdldE5vZGUgPSBpZDtcclxuXHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRhcmdldE5vZGU7XHJcblxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0cmlldmUgdGhlIExpc3RlbmVyIHRhcmdldC4gVGhpcyBMaXN0ZW5lciBUYXJnZXQgaXMgdXNlZFxyXG4gICAqIHRvIGF0dGFjaCBFdmVudCBMaXN0ZW5lcnMgb24uIEluIGNhc2Ugb2YgdGhlIHRhcmdldCBiZWluZ1xyXG4gICAqIHRoZSBEb2N1bWVudCBCb2R5LCB3ZSBuZWVkIHRoZSBhY3R1YWwgYHdpbmRvd2AgdG8gbGlzdGVuXHJcbiAgICogZm9yIGV2ZW50cy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBjb250YWluZXIgICAgICAgICAgIFRoZSBIVE1MIENvbnRhaW5lciBlbGVtZW50XHJcbiAgICogQHJldHVybnMgICAgICAgICAgICAgICAgICAgVGhlIExpc3RlbmVyIFRhcmdldCB0byBhdHRhY2ggZXZlbnRzIG9uXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBfZ2V0TGlzdGVuZXJUYXJnZXQoY29udGFpbmVyOiBIVE1MRWxlbWVudCk6IFNjcm9sbFRvTGlzdGVuZXJUYXJnZXQge1xyXG4gICAgaWYgKCFjb250YWluZXIpIHJldHVybiBudWxsO1xyXG4gICAgcmV0dXJuIHRoaXMuX2lzRG9jdW1lbnRCb2R5KGNvbnRhaW5lcikgPyB3aW5kb3cgOiBjb250YWluZXI7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBUZXN0IGlmIGEgZ2l2ZW4gSFRNTCBFbGVtZW50IGlzIHRoZSBEb2N1bWVudCBCb2R5LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIGVsZW1lbnQgICAgICAgICAgICAgVGhlIGdpdmVuIEhUTUwgRWxlbWVudFxyXG4gICAqIEByZXR1cm5zICAgICAgICAgICAgICAgICAgIFdoZXRoZXIgb3Igbm90IHRoZSBFbGVtZW50IGlzIHRoZVxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIERvY3VtZW50IEJvZHkgRWxlbWVudFxyXG4gICAqL1xyXG4gIHByaXZhdGUgX2lzRG9jdW1lbnRCb2R5KGVsZW1lbnQ6IEhUTUxFbGVtZW50KTogZWxlbWVudCBpcyBIVE1MQm9keUVsZW1lbnQge1xyXG4gICAgcmV0dXJuIGVsZW1lbnQudGFnTmFtZS50b1VwcGVyQ2FzZSgpID09PSAnQk9EWSc7XHJcbiAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQge1xyXG4gIERpcmVjdGl2ZSxcclxuICBJbnB1dCxcclxuICBFbGVtZW50UmVmLFxyXG4gIFJlbmRlcmVyMixcclxuICBBZnRlclZpZXdJbml0XHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5pbXBvcnQge1xyXG4gIERFRkFVTFRTLFxyXG4gIEVWRU5UU1xyXG59IGZyb20gJy4vc3RhdGljcy9zY3JvbGwtdG8taGVscGVycyc7XHJcbmltcG9ydCB7XHJcbiAgU2Nyb2xsVG9Db25maWdPcHRpb25zLFxyXG4gIFNjcm9sbFRvT2Zmc2V0TWFwLFxyXG4gIFNjcm9sbFRvVGFyZ2V0XHJcbn0gZnJvbSAnLi9tb2RlbHMvc2Nyb2xsLXRvLWNvbmZpZy5tb2RlbCc7XHJcbmltcG9ydCB7XHJcbiAgU2Nyb2xsVG9BbmltYXRpb25FYXNpbmdcclxufSBmcm9tICcuL21vZGVscy9zY3JvbGwtdG8tZWFzaW5nLm1vZGVsJztcclxuaW1wb3J0IHsgU2Nyb2xsVG9FdmVudCB9IGZyb20gJy4vbW9kZWxzL3Njcm9sbC10by1ldmVudC5tb2RlbCc7XHJcbmltcG9ydCB7IFNjcm9sbFRvU2VydmljZSB9IGZyb20gJy4vc2Nyb2xsLXRvLnNlcnZpY2UnO1xyXG5cclxuQERpcmVjdGl2ZSh7XHJcbiAgc2VsZWN0b3I6ICdbbmd4LXNjcm9sbC10b10nXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBTY3JvbGxUb0RpcmVjdGl2ZSBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQge1xyXG5cclxuICBASW5wdXQoJ25neC1zY3JvbGwtdG8nKVxyXG4gIHB1YmxpYyBuZ3hTY3JvbGxUbzogU2Nyb2xsVG9UYXJnZXQgPSBERUZBVUxUUy50YXJnZXQ7XHJcblxyXG4gIEBJbnB1dCgnbmd4LXNjcm9sbC10by1ldmVudCcpXHJcbiAgcHVibGljIG5neFNjcm9sbFRvRXZlbnQ6IFNjcm9sbFRvRXZlbnQgPSBERUZBVUxUUy5hY3Rpb247XHJcblxyXG4gIEBJbnB1dCgnbmd4LXNjcm9sbC10by1kdXJhdGlvbicpXHJcbiAgcHVibGljIG5neFNjcm9sbFRvRHVyYXRpb246IG51bWJlciA9IERFRkFVTFRTLmR1cmF0aW9uO1xyXG5cclxuICBASW5wdXQoJ25neC1zY3JvbGwtdG8tZWFzaW5nJylcclxuICBwdWJsaWMgbmd4U2Nyb2xsVG9FYXNpbmc6IFNjcm9sbFRvQW5pbWF0aW9uRWFzaW5nID0gREVGQVVMVFMuZWFzaW5nO1xyXG5cclxuICBASW5wdXQoJ25neC1zY3JvbGwtdG8tb2Zmc2V0JylcclxuICBwdWJsaWMgbmd4U2Nyb2xsVG9PZmZzZXQ6IG51bWJlciA9IERFRkFVTFRTLm9mZnNldDtcclxuXHJcbiAgQElucHV0KCduZ3gtc2Nyb2xsLXRvLW9mZnNldC1tYXAnKVxyXG4gIHB1YmxpYyBuZ3hTY3JvbGxUb09mZnNldE1hcDogU2Nyb2xsVG9PZmZzZXRNYXAgPSBERUZBVUxUUy5vZmZzZXRNYXA7XHJcblxyXG4gIHByaXZhdGUgX29wdGlvbnM6IFNjcm9sbFRvQ29uZmlnT3B0aW9ucztcclxuXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLFxyXG4gICAgcHJpdmF0ZSBfc2Nyb2xsVG9TZXJ2aWNlOiBTY3JvbGxUb1NlcnZpY2UsXHJcbiAgICBwcml2YXRlIF9yZW5kZXJlcjI6IFJlbmRlcmVyMikge1xyXG5cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFuZ3VsYXIgTGlmZWN5Y2xlIEhvb2sgLSBBZnRlciBWaWV3IEluaXRcclxuICAgKlxyXG4gICAqIEB0b2RvIEltcGxlbWVudCBTdWJzY3JpcHRpb24gZm9yIEV2ZW50c1xyXG4gICAqXHJcbiAgICogQHJldHVybnMgdm9pZFxyXG4gICAqL1xyXG4gIHB1YmxpYyBuZ0FmdGVyVmlld0luaXQoKTogdm9pZCB7XHJcblxyXG4gICAgLy8gVGVzdCBFdmVudCBTdXBwb3J0XHJcbiAgICBpZiAoRVZFTlRTLmluZGV4T2YodGhpcy5uZ3hTY3JvbGxUb0V2ZW50KSA9PT0gLTEpIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgRXZlbnQgJyR7dGhpcy5uZ3hTY3JvbGxUb0V2ZW50fSdgKTtcclxuXHJcbiAgICAvLyBMaXN0ZW4gZm9yIHRoZSB0cmlnZ2VyLi4uXHJcbiAgICB0aGlzLl9yZW5kZXJlcjIubGlzdGVuKHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgdGhpcy5uZ3hTY3JvbGxUb0V2ZW50LFxyXG4gICAgICAoZXZlbnQ6IEV2ZW50KSA9PiB7XHJcblxyXG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSB7XHJcbiAgICAgICAgICB0YXJnZXQ6IHRoaXMubmd4U2Nyb2xsVG8sXHJcbiAgICAgICAgICBkdXJhdGlvbjogdGhpcy5uZ3hTY3JvbGxUb0R1cmF0aW9uLFxyXG4gICAgICAgICAgZWFzaW5nOiB0aGlzLm5neFNjcm9sbFRvRWFzaW5nLFxyXG4gICAgICAgICAgb2Zmc2V0OiB0aGlzLm5neFNjcm9sbFRvT2Zmc2V0LFxyXG4gICAgICAgICAgb2Zmc2V0TWFwOiB0aGlzLm5neFNjcm9sbFRvT2Zmc2V0TWFwXHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgdGhpcy5fc2Nyb2xsVG9TZXJ2aWNlLnNjcm9sbFRvKHRoaXMuX29wdGlvbnMpO1xyXG4gICAgICB9KTtcclxuICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgTmdNb2R1bGUsIE1vZHVsZVdpdGhQcm92aWRlcnMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgU2Nyb2xsVG9EaXJlY3RpdmUgfSBmcm9tICcuL3Njcm9sbC10by5kaXJlY3RpdmUnO1xyXG5pbXBvcnQgeyBTY3JvbGxUb1NlcnZpY2UgfSBmcm9tICcuL3Njcm9sbC10by5zZXJ2aWNlJztcclxuXHJcbkBOZ01vZHVsZSh7XHJcbiAgZGVjbGFyYXRpb25zOiBbXHJcbiAgICBTY3JvbGxUb0RpcmVjdGl2ZVxyXG4gIF0sXHJcbiAgZXhwb3J0czogW1xyXG4gICAgU2Nyb2xsVG9EaXJlY3RpdmVcclxuICBdXHJcbn0pXHJcbmV4cG9ydCBjbGFzcyBTY3JvbGxUb01vZHVsZSB7XHJcbiAgLyoqXHJcbiAgICogR3VhcmFudGVlZCBzaW5nbGV0b25zIGZvciBwcm92aWRlZCBTZXJ2aWNlcyBhY3Jvc3MgQXBwLlxyXG4gICAqXHJcbiAgICogQHJldHVybiAgICAgICAgICBBbiBBbmd1bGFyIE1vZHVsZSB3aXRoIFByb3ZpZGVyc1xyXG4gICAqL1xyXG4gIHN0YXRpYyBmb3JSb290KCk6IE1vZHVsZVdpdGhQcm92aWRlcnMge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbmdNb2R1bGU6IFNjcm9sbFRvTW9kdWxlLFxyXG4gICAgICBwcm92aWRlcnM6IFtcclxuICAgICAgICBTY3JvbGxUb1NlcnZpY2VcclxuICAgICAgXVxyXG4gICAgfTtcclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbInRzbGliXzEuX19hc3NpZ24iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOzs7QUFlQSxBQUFPLHFCQUFNLFFBQVEsR0FBaUM7SUFDcEQsTUFBTSxFQUFFLElBQUk7SUFDWixNQUFNLEVBQUUsT0FBTztJQUNmLFFBQVEsRUFBRSxHQUFHO0lBQ2IsTUFBTSxFQUFFLGVBQWU7SUFDdkIsTUFBTSxFQUFFLENBQUM7SUFDVCxTQUFTLEVBQUUsSUFBSSxHQUFHLEVBQUU7Q0FDckIsQ0FBQzs7OztBQUtGLEFBQU8scUJBQU0sTUFBTSxHQUFzQztJQUN2RCxVQUFVLEVBQUUsVUFBQyxJQUFZO1FBQ3ZCLE9BQU8sSUFBSSxHQUFHLElBQUksQ0FBQztLQUNwQjtJQUNELFdBQVcsRUFBRSxVQUFDLElBQVk7UUFDeEIsT0FBTyxJQUFJLElBQUksQ0FBQyxHQUFHLElBQUksQ0FBQyxDQUFDO0tBQzFCO0lBQ0QsYUFBYSxFQUFFLFVBQUMsSUFBWTtRQUMxQixPQUFPLElBQUksR0FBRyxHQUFHLEdBQUcsQ0FBQyxHQUFHLElBQUksR0FBRyxJQUFJLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FB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